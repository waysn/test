Oinone7 天从⼊⻔到精通 目录 【内容简介】
.................................................................................................................................
4 【序篇】
.........................................................................................................................................
4 庄卓然
.....................................................................................................................................
5 陈浩
.........................................................................................................................................
6 李强
.........................................................................................................................................
7 梅丛银
.....................................................................................................................................
8 蒋江伟
.....................................................................................................................................
9 【开篇】致 Oinone
读者..............................................................................................................
10

no ne

书籍纲领................................................................................................................................
10 第 1 章 揭开面纱，理解
Oinone.................................................................................................
11 1.1 Oinone
的萌芽...............................................................................................................
11 1.2 Oinone
的致敬...............................................................................................................
12

杰

克

-O i

n 1.2.1 数字化时代 Oinone 接棒 Odoo
.................................................................. 13 n
1.2.2 Oinone 与 Odoo 的不同之处
.......................................................................
13 1.3 Oinone
的生态思考.......................................................................................................
14 n 1.3.1 与中台的渊源
............................................................................................
15 n 1.3.2 找解决方案
................................................................................................
16 n 1.3.3 生态建设
....................................................................................................
18 1.4 Oinone
与行业对比.......................................................................................................
18 n 1.4.1 整体视角对比
............................................................................................
19 n 1.4.2 从技术角度对比
........................................................................................
19 n 1.4.3 从产品角度对比
........................................................................................
20 第 2 章 Oinone
的技术独特性.....................................................................................................
23 2.1 数字化时代软件业的另一个本质变化
........................................................................
23 2.2 互联网架构作为最佳实践为何失效
............................................................................
24 2.3 Oinone 独特性之源，元数据与设计原则
................................................................... 27
2.4 Oinone
的三大独特性...................................................................................................
29 n 2.4.1 Oinone 独特性之单体与分布式的灵活切换
........................................... 30 n 2.4.2 Oinone
独特性之每一个需求都可以是一个模块 ...................................
33 n 2.4.3 Oinone 独特性之低无一体
.......................................................................
37 第 3 章 Oinone
的基础入门.........................................................................................................
42 3.1
环境搭建.........................................................................................................................
42 n 3.1.1 环境准备（Mac 版）
..................................................................................
43 n 3.1.2 环境准备（Windows 版）
..........................................................................
50 3.2 Oinone
以模块为组织...................................................................................................
58 n 3.2.1 构建第一个 Module
....................................................................................
58 n 3.2.2 启动前端工程
.............................................................................................
73 n 3.2.3 应用中心
.....................................................................................................
77 3.3 Oinone
以模型为驱动...................................................................................................
79 n 3.3.1 构建第一个 Model
......................................................................................
79 n 3.3.2 模型的类型
.................................................................................................
85 1

Oinone7 天从⼊⻔到精通

杰

克

-O i

no ne

n 3.2.3 模型的数据管理器
.....................................................................................
97 n 3.2.4 模型的继承
...............................................................................................
100 n 3.2.5 模型编码生成器
.......................................................................................
127 n 3.2.6 枚举与数据字典
.......................................................................................
131 n 3.3.7 字段之序列化方式
...................................................................................
142 n 3.3.8 字段类型之基础与复合
...........................................................................
148 n 3.2.9 字段类型之关系与引用
...........................................................................
154 3.4 Oinone
以函数为内在.................................................................................................
166 n 3.4.1 构建第一个 Function
..............................................................................
166 n 3.4.2 函数的开放级别与类型
...........................................................................
173 n 3.4.3 函数的相关特性
.......................................................................................
174 3.5 Oinone
以交互为外在.................................................................................................
186 n 3.5.1 构建第一个 Menu
......................................................................................
186 n 3.5.2 构建第一个 View
......................................................................................
189 n 3.5.3 Action 的类型
.........................................................................................
213 n 3.5.4 Ux 注解详解
.............................................................................................
224 n 3.5.5 设计器的结合
...........................................................................................
226 n 3.5.6 DSL 配置大全
...........................................................................................
232 n 3.5.7 前端组件自定义(初级篇)
.......................................................................
280 第 4 章 Oinone
的高级特性.......................................................................................................
344 4.1
后端高级特性...............................................................................................................
345 n 4.1.1 模块之 yml 文件结构详解
.......................................................................
345 n 4.1.2 模块之启动指令
.......................................................................................
357 n 4.1.3 模块之生命周期
.......................................................................................
361 n 4.1.4 模块之元数据详解
...................................................................................
365 n 4.1.5 模型之持久层配置
...................................................................................
368 n 4.1.6 模型之元数据详解
...................................................................................
372 n 4.1.7 函数之元数据详解
...................................................................................
387 n 4.1.8 函数之事务管理
.......................................................................................
391 n 4.1.9 函数之元位指令
.......................................................................................
396 n 4.1.10 函数之触发与定时
.................................................................................
400 n 4.1.11 函数之异步执行
.....................................................................................
412 n 4.1.12 函数之内置函数与表达式
.....................................................................
424 n 4.1.13 Action 之校验
.......................................................................................
437 n 4.1.14 Search 之非存储字段条件
................................................................... 439
n 4.1.15 框架之网关协议
.....................................................................................
441 n 4.1.16 框架之网关协议-RQSL 及扩展
.............................................................. 445 n
4.1.17 框架之网关协议-GraphQL 协议
............................................................ 447 n
4.1.18 框架之网关协议-Variables 变量
........................................................ 449 n 4.1.19
框架之网关协议-后端占位符
............................................................... 450 n
4.1.20 框架之 Session
......................................................................................
452 n 4.1.21 框架之分布式消息
.................................................................................
456 n 4.1.22 框架之分布式缓存
.................................................................................
470 n 4.1.23 框架之信息传递
.....................................................................................
470 2

Oinone7 天从⼊⻔到精通

杰

克

-O i

no ne

n 4.1.24 框架之分库分表
.....................................................................................
472 n 4.1.25 框架之搜索引擎
.....................................................................................
478 4.2
前端高级特性...............................................................................................................
486 n 4.2.1 组件之生命周期
.......................................................................................
487 n 4.2.2 框架之 MessageHub
..................................................................................
491 n 4.2.3 框架之 SPI 机制
.......................................................................................
496 n 4.2.4 框架之网络请求-HttpClient
................................................................. 497 n
4.2.5 框架之网络请求-Request
.......................................................................
502 n 4.2.6 框架之网络请求-拦截器
.........................................................................
506 n 4.2.7 框架之翻译工具
.......................................................................................
513 4.3 Oinone
的分布式体验.................................................................................................
518 4.4 Oinone 的分布式体验进阶
.........................................................................................
530 4.5
研发辅助......................................................................................................................
535 n 4.5.1 研发辅助之插件-结构性代码
................................................................. 535 n
4.5.2 研发辅助之 SQL 优化
...............................................................................
538 第五章 Oinone 的 CDM
................................................................................................................
541 5.1 CDM
的背景介绍...........................................................................................................
541 5.2 CDM
之工程模式...........................................................................................................
543 5.3 基础支撑之用户与客户域
..........................................................................................
545 5.4 基础支撑之商业关系域
..............................................................................................
552 5.5
基础支撑之结算域......................................................................................................
555 5.6
商业支撑之商品域......................................................................................................
558 5.7
商业支撑之库存域......................................................................................................
560 5.8
商业支撑之执行域......................................................................................................
562 第六章 Oinone
的通用能力.......................................................................................................
564 6.2
集成平台......................................................................................................................
578 6.3
数据审计......................................................................................................................
616 6.4
国际化之多语言..........................................................................................................
618 6.5
权限体系......................................................................................................................
623 6.6 消息
.............................................................................................................................
629 第七章 Oinone
的设计器们........................................................................................................
636 7.2 实战训练（积分发放）
...............................................................................................
642 7.3 实战训练（全员营销为例）
.......................................................................................
696 n 7.3.1 去除资源上传大小限制
...........................................................................
696 n 7.3.2 原业务加审批流程
...................................................................................
705 7.4 Oinone
的低无一体.....................................................................................................
719
【附件一】下载说明..................................................................................................................
723

3

Oinone7 天从入门到精通 【内容简介】

no ne

数式科技希望通过 Oinone
的开源项目为中国软件行业带来改变，提升整体工程化水平，
并与广大软件工程师一起为客户创造价值！《Oinone 7 天从入门到精通》是
Oinone 开源项 目的配套书籍，旨在系统化地介绍如何基于 Oinone
开源项目，简单快速地开发出高质量的 软件系统。全书共 7
大章节，内容大致分为 3 部分： 第 1 部分（第 1-2
章）可以更好地帮助读者理解数式科技设计 Oinone 的初衷； 第 2 部分（第 2-6
章）重点面向研发人员，提供一步步操作案例，让读者快速上手并完
成业务系统的开发； 第 3 部分（第 7 章）面向非研发人员，通过使用 Oinone
的可视化设计器，让读者无需
任何研发能力就能轻松完成对系统的适用性修改。而在 Oinone
的无代码开发环境中，读者 还可以找到其他解决方案，并寻求研发帮助。

杰

克

-O i

《Oinone 7 天从入门到精通》是由数式科技的创始人亲自编写的书籍，为研发
及非研发业务人员提供了一份实战培训资料。该书籍中的每个细节都经过创始人
亲自审核，以确保每一位进入 Oinone 生态的伙伴都能获得更好的体验。

【序篇】 4

Oinone7 天从入门到精通

庄卓然

克

-O i

no ne

从 2009 年加入阿里至今，经历了“三淘”时期、天猫时期、双十一，到最后的 all
in
无线手淘时期，几乎是赶上了淘系发展的所有历史性事件。在这个过程中，每一次业务的变
革都催生着技术的变迁，倒逼着我们用技术的方式去解决业务问题：在存储、IO、网络等环
节满足不了淘系的业务规模时，开始去
IOE，最后演化成了阿里云；当业务的规模大到不能
通过简单加机器的方式去做调整、当开发的规模大到所有人在一起开发会互相影响的的时候，
我们开始做 SOA
改造，最后演化成了业务中台；在经历了几届双十一后的巨大挑战后，我们
开创了里程碑式的全链路压测；在手淘时代，为了解决动态发版问题，我们植入容器概念，
搭建了可动态插拔的三层架构，一年实现了 500
多次的发版；为了同时满足写一套代码就解
决多端开发和高并发的性能问题，我们做了 weex，最后还捐给了开源社区……
每一次的业务需求推动技术进步，而技术的进步永远会超出我们的想象！
同为技术宅，我在 Oinone
身上能清晰地感受到技术演进的脉络，企业在数字化时代，
需要一个能快速上手、全面设计、灵活适应且低成本的技术工具，时代的变迁推动了
Oinone 的诞生。Oinone 是一种全新的开发方式，在数字化时代，Oinone
在提升研发效率上做出的
创新性“低无一体”的设计对传统软件代码开发或者无代码开发一定会有巨大冲击，这种冲
击会对软件市场格局造成什么样的变化，我拭目以待。
最后，愿我们这些追光人，在时代的洪流中，都能留下一抹印迹，不辜负时代，不辜负
自己。

杰

现任阿里巴巴副总裁，飞猪总裁 曾任阿里大文娱 CTO 兼优酷 COO、淘宝 CTO
庄卓然（南天）

5

Oinone7 天从入门到精通

陈浩

杰

克

-O i

no ne

自 2017 年中国推进数字建设以来，数字经济规模持续增长，“十四五”规划和
2035
远景目标纲要中明确强调企业和政府需大力推动数字化转型，中国正在迈进一个崭新的数字
经济时代。
在这个过程中，软件已经从工具变成信息化的基础设施，如何有效应对该变化所带来的
一系列新的核心技术挑战，是整个软件行业发展遇到的另一难题。我认为，开源创新是解决
这些难题的有效手段之一，也是未来软件发展的重要方向。如果说，数字化转型是时代趋势，
那么开源创新也已成为时代主流。十四五规划纲要首提开源，2021 年 11
月工信部印发《十
四五软件和信息技术服务业发展规划》中提到开源重塑软件发展新生态，并将开源重塑软件
发展新生态作为十四五期间我国软件产业的四大发展形势之一进行重点阐述。支持国产化开
源创新体系发展，建设自己的开源社区和开源平台，其所具有的大众协同、开放共享、持续
创新等特点，可有效推动各行业自主可控的数字化转型。 Oinone
所倡导的开源理念和生态共建，与国家开源战略不谋而合：将开源作为一种合
作手段，通过完善社区注重开源治理，吸引更多的企业和个体参与其中。湖南大学作为首批
国家示范性软件学院的双一流建设高校，一直致力于推进和引导国产化开源软件体系的建设，
并为此开展多种形式的产学研研究和实践。基于 Oinone
微服务分布式的设计理念和面向生
态的开源特性，湖南大学结合自身在大数据分布式存储、多元异构数据汇聚融合和大数据智
能分析等方面的研究成果，与 Oinone
展开了深度的技术创新合作，并在多个大中型企业数
字化应用和数字政府应用中取得了良好的效果。 随着 Oinone
的开源，相信能激发更多的开发者参与到国产软件建设中，通过开源模式
实现更广泛参与方的共享、共创、共生、共赢，构建价值驱动的数字创新生态平台，为我国
数字经济发展贡献科技力量。

湖南大学教授：陈浩

6

Oinone7 天从入门到精通

李强

杰

克

-O i

no ne

我们常说“在今天所有的不确定性当中，数字化是最大的确定性”，数字化一定会全面
改造所有的行业更是确定的。在菜鸟九年的探索中，我们最大的感受是“未来，任何一个物
流企业都会是一个技术公司，真正拉开差距的是：技术与实体产业的结合有多深”。菜鸟“简
单极致，贴地疾飞”的技术文化也深刻体现了这一点——好的技术要能解决实际问题。数字
化并不是简单地上线一个或几个系统，这是一个贴近业务持续迭代的过程，伴随着这个过程，
我相信会诞生非常多的创新技术。
在本书中我看到了工程思维在推进技术创新的缩影，把难的问题转化为简单的问题，用
成熟实用的技术分而解之。高性能的微服务框架、CDM、元数据、低代码、无代码等，都是
当下非常热门的技术课题，Oinone
把这一切都有机地结合起来，形成了一种具备先进理念
的全新一代软件产品，每一个特性都贴合企业数字化遇到的实际问题。Oinone
的产品设计，
把“大道至简，软件自造”贯穿始终，用最简单的方式，帮助企业驾驭数字化，相信会给企
业带来不一样的体验。
就跟本书提到的“「企业视角由内部管理转向业务在线、生态在线(协同)带来一系列新
的诉求」这一大背景下，以及云、端等新技术的发展，对研发人员的需求越来越大，同时要
求越来越高，低代码平台是提升研发效率，降低研发成本的核心手段”，低代码已经不是需
不需要的问题，而是怎么选的问题。菜鸟网络自身也在推进自有低代码开发平台，我们有幸
邀请本书作者陈鹏程来到菜鸟网络进行了分享交流，收获非常大。如您正在选型低代码开发
平台，向您推荐这本书，低无一体的 Oinone 肯定会打动您。

菜鸟网络 CTO 李强（在宽）

7

Oinone7 天从入门到精通

no ne

梅丛银

杰

克

-O i

认识史昂及数式核心团队同学已经有一段时间了，在我们多次的交流讨论中时常会谈及：
未来中国哪家软件企业能在互联网云原生时代走出来超越传统软件企业？史昂说这是他的
梦想，也是他们团队这么多年坚持技术和产品研发与应用优先思考之路。史昂及数式核心团
队面向企业应用市场历经三年的潜心研发和实战交付，推出 Oinone
产品及配套的低代码平
台工具：对比国内外应用软件平台在开放生态和云原生均有它的继承性和独特性，此外将技
术平台赋予企业各种业务领域属性，便于企业客户和开发伙伴的二次开发并能快速搭建各类
企业核心应用场景是 Oinone 的最大亮点。 Oinone
的内在特点之一是参考了全球最大开源 ERP Odoo
的元数据模型设计，同时基于业务中台架构和云原生技术，形成了自己一套国际化的
快速开发平台、建模规范和应用产品，通过自己进场落地很多品牌企业的应用中台化不断迭
代升级，走出了一条具有显著特色的新应用软件之路。
史昂及团队特点谦卑、善于思考，善于吸收他山之精华，这是创业团队难能可贵之点，
由此能善于与生态伙伴合作也是能够走的更远更长的基础基因。最后希望和祝愿
Oinone 能
为中国企业在云时代数字化实践做出更多的贡献，为软件产业构建强大的应用生态和开发社
区，真正树立起 Oinone 自己的软件品牌形象。

资深 IT 咨询专家&浩鲸云智能专家学院院长：梅丛银

8

Oinone7 天从入门到精通

蒋江伟

杰

克

-O i

no ne

企业数字化转型经过多年演进，其趋势价值已经毋庸置疑。近些年来，随着流媒体平台
的崛起，对企业的营销方式、渠道建设方式甚至供应链都带来了新的挑战，我们可以清晰地
感觉到世界每时每刻都在发生变化。在未来的企业竞争中，谁数字化走在前沿，谁就更能掌
握主动权。数字化是为了满足业务的持续创新，只有持续创新才能更好的迎接未知变化。而
过去很多企业的技术路径是一个采购型的发展路径，买来的 ERP 和
CRM，升级都是各自管各
自的，有一天推出一个新概念或者业务发生新需求，又去采购另外一家企业的 ERP
和 CRM，
整个替换掉了，烟囱式地迭代演进模式。企业不怕重复建设，怕的是不断重复建设，企业不
怕系统延期上线，怕的是错过业务发展的机会窗口。
本书主要介绍了一种全新的数字化构建理念和技术落地方式——用低代码的方式一站
式支撑企业的商业场景并能满足商业化持续创新，和其他低代码不同的是：既结合了中台架
构，又兼顾了传统企业的 IT
发展水平，更符合企业数字化发展需求，持续保持企业竞争力，
对各行业在做数字化选型的时候有很大的帮助。
很高兴看到阿里校友史昂（本书作者）在这条路上发光发热，也把此书推荐给 IT
从业
者、程序员以及爱好计算机应用软件的所有同学，希望对大家学习新型、更高效的系统构建
方式有所启发。

阿里巴巴高级研究员 蒋江伟（小邪）

9

Oinone7 天从入门到精通 【开篇】致 Oinone 读者 欢迎来到 Oinone
生态，我们为您提供了一站式低代码商业支撑平台，数式科技已经用
其服务了如中烟、得力、上海电气、中航金网、雾芯科技等多个知名企业，我们的技术实力
在商业场景得到了很好的验证。我们希望通过开源 Oinone
项目，为中国软件行业带来变革，
提升整体工程化水平，与广大软件工程师一起为客户创造价值！《Oinone 7
天从入门到精 通》一书是 Oinone
开源项目的配套书籍，系统化地介绍了如何基于 Oinone 开源项目，快速
开发高质量的软件系统。此外，如果您开发的项目是用于商业化而非企业自用，我们还为您
提供了一种可选的商业化变现途径：申请成为 Oinone
的合作伙伴，并提交相关产品，详情 请访问 www.oinone.top 网站。

no ne

书籍纲领

杰

克

-O i

本书的章节安排如下： 第一章至第二章：【揭开面纱，理解 Oinone】和【Oinone
的技术独特性】。这两个章 节可以帮助您更好地理解我们设计 Oinone
的初衷以及特性的由来。 第三章：面向研发人员的【Oinone
的基础入门】。如果您是专业的研发人员，本章可
以帮助您快速上手并做出业务系统。只要按着里面的 case
一步步操作下来就可以。 第四章至第六章：面向研发人员的【Oinone
的高级特性】、【Oinone 的 CDM】、【Oinone
的通用能力】。这三篇章节重点介绍了 Oinone
的高级技术特性、提供的通用数据模型和通
用基础能力。它们能够帮助我们更快地进行业务开发，从容应对业务的特殊场景要求，比较
适合进阶的研发人员。 第七章：面向非研发人员的【Oinone
的设计器们】和【Oinone 的低无一体】。如果您
并不是专业的研发人员，本章可以帮助您通过使用 Oinone
的无代码可视化设计器轻松自主
解决业务需求，并且当可视化设计器满足不了的时候，您还可以在【Oinone
的低无一体】 中找到方式，并寻求研发帮助

10

Oinone7 天从入门到精通 第 1 章 揭开面纱，理解 Oinone
本章旨在从以下几个维度逐步揭开 Oinone 的面纱，让大家了解 Oinone
的初心与愿景，
以及它是如何站在软件领域的巨人肩膀上，结合企业数字化转型的深入，形成全新的理念，
帮助企业完成数字化转型。 具体来说，本章会从以下四个方面逐一展开： 1.
中国软件行业的发展和自身职业发展经历，以此谈论 Oinone 的初心和愿景 2.
Oinone 向西方软件业新贵 odoo 致敬 3. 从企业数字化转型的困境出发，阐述
Oinone 的全新思路 4. 通过行业对比，让您从不同的视角来理解 Oinone。

1.1 Oinone 的萌芽

杰

克

-O i

no ne

在信息化时代，中国并没有涌现出一家世界知名的软件公司。这是因为像
SAP、Oracle、 IBM、Salesforce、NetSuite、Odoo
等西方巨头所拥有的最佳实践在业务、技术和模式方面，
给予了它们在企业信息化建设中高额利润的优势。中国软件业在这个时代的角色是学习和追
随者，而最优秀的追随者是金蝶和用友，它们能在国家推行会计电算化的机遇中占据领先地
位。但是，追随者始终只是追随者，没有真正的突破。
我自己进入软件行业的经历可以追溯到 2015
年。当时资本市场非常热门，大家都在创
业。我认为这是一个时代的机会，就像国家改革开放一样。于是，我和很多同事一起开始了
创业之旅。在数式之前，我加入并创办了三家公司：500mi、数列和端点。整个过程给了我
宝贵的经验和启示，帮助我找到了最终想要的方向。 在 500mi
公司时，我从技术岗位转型为业务经营，起步并不顺利。然而，我从这份经历
中获得了一堂重要的课：做自己擅长的事情，有助于渡过创业启动期最艰难的阶段。同时，
市场调研为我提供了一个信号：传统企业对于 IT
的需求正逐渐向互联网靠拢。这个信号像 注入了一剂强心剂，激励我继续前行。
2016
年，我和三个曾在阿里工作的同事一起创办了一家新公司——数列，我们决定专
注于我们最擅长的领域，即软件服务商。在没有任何商务资源的情况下，我们第一年就完成
了 1000
多万的合同，这相较之前是一个非常成功的开端。然而，对于公司未来的发展方向，
我们花费了长达大半年的时间进行思考：应该坚持做底层的 PaaS
还是专注于企业可见的上
层应用和业务产品？我倾向于后者。尽管我们持续存在分歧，但凭借着多年的革命友情，最
终我们友好地分道扬镳。数列此前的成功让我更加坚信：在数字化时代，软件需求将会有井
喷式的增长，数字化软件服务将是未来 5-10
年的重要方向。而在这个领域，专业的技能将 是应对未来不确定性的真正力量。
提到数字化，就不得不提阿里巴巴提出的中台理念。中台理念在 15
年前被阿里巴巴提
出，当时引起了广泛的关注和讨论。企业之所以认同中台理念，是因为他们的核心需求已经
从内部转向外部：从关注管理、流程、效率的提升，转向关注外部协同、运营、创新。他们
已经不再只担心企业的效率和成本，而是担心自己是否有能力跟上时代的快速变化。现今做
生意的渠道已经不再是单一的线下渠道，而是包括淘宝、天猫、京东、拼多多、抖音、快手
等多个线上渠道，以及海外市场，这种变化速度非常快。而中台的核心理念是敏捷响应、低
成本快速创新，正好解决了企业主的核心焦虑。
企业的视角正在从内部管理向业务在线和生态在线（协同）转变，这种转变带来了一系
列新的需求（如下图 1-1
所示）。这种转变不仅是为了支持现有业务的发展，也为企业未来
的业务发展和创新提供了支持，并将变化实时反映到上下游合作伙伴中。 11

no ne

Oinone7 天从入门到精通

图 1-1 企业视角转变带来一系列新的诉求

杰

克

-O i

在 2017
年下半年，阿里云收购了端点科技，打算重启阿里软件。那个时候，市场上涌
现出一批中台厂商，整个行业也比较混乱，很多人对互联网架构本身的理解不够深入，快速
学习拿到阿里云认证后就开始做定制化的中台架构开发，但最终的效果无法达到预期。因此，
阿里云和端点科技的联姻是为了弥补阿里云没有向外输出上层应用产品能力的缺陷。多年来，
软件市场一直被国外厂商掌控，中国一直缺乏一个强大的本土软件公司。阿里收购端点，承
载着无数中国人的软件梦想。在这种背景下，我回到了阿里体系，加入了端点科技。后来，
我参与了许多中台项目，深刻地认识到搭建中台技术架构和一些基础能力，为上层应用场景
落地并不难。但是，当客户接手扩展中台能力和新的上层应用场景时，效果往往不尽如人意，
这并不是中台架构理念的问题，而是因为传统企业客户的 IT
能力大多较弱，这是一个硬伤。
许多文章都在讲述中台战略，长篇大论地描述组织中台、技术中台、业务中台、数据中台，
我们不去评论这些方法论的对错，从技术角度回到初衷，我们只关注一个问题：技术是为商
业服务的，中台如何快速满足企业业务多变的需求？
我们经历了多个行业的中台建设，每次都向客户强调第一阶段是打好基础，因此需要较
长的周期，并且每个项目都需要顶级架构师来把控整体项目。如何找到互联网架构与传统软
件良好结合点，降低对组织的要求，实现中台架构的标准化输出？这是我回归阿里后致力于
解决的问题。然而，随着阿里云对端点战略发展思路的变化，阿里不再提供 SaaS
服务，而
只愿意做平台被其他企业集成。因此，我离开了端点，并决定把自己的技术思考转化为现实，
于是数式科技诞生了。
在数字化时代，无论是业务、技术还是商业模式的最佳实践，都源自中国。中国已经从
追随者转变为互联网领域的全面引领者。我们有理由相信，中国一定会崛起一家世界级的软
件公司，而 Oinone 将始终以此为愿景。

1.2 Oinone 的致敬 12

Oinone7 天从入门到精通 占在巨人的肩膀上，天地孤影任我行。

n 1.2.1 数字化时代 Oinone 接棒 Odoo

no ne

在数字化时代，中国在互联网化的应用、技术的领先毋庸置疑，但在软件的工程化、产
品化输出方面仍有许多改进的空间。这时，我了解到了
Odoo——一个国外非常优秀的开源 ERP 厂商，全球 ERP
用户数量排名第一，百级别员工服务全球客户。Odoo 的工程化能力和商
业模式深深吸引了我，它是软件行业典型的产品制胜和长期主义者的胜利之一。
在 2019
年，也就是数式刚成立的时候，我们跟很多投资人聊起公司的对标是谁，我不
是要成为数字化时代的 SAP， 而是要成为 Odoo。 然而，
当时大部分国内投资人并不了解 Odoo， 尽管它已经是全球最大的 ERP
厂商之一，因为当时 Odoo 还没有明确的估值。直到 2021 年 7 月份获得 Summit
Partners 的 2.15 亿美元投资后，Odoo 才正式成为 IT 独角兽企业。 Odoo
对我们提供了极大的启示，因此我们致敬 Odoo，同样选择开源，每年对产品进行
升级发布。如今，Odoo15 已经发布，而 Oinone 也已推出第三版，恰好相隔 12
年，这是一 个时代的接棒，从信息化升迁至数字化。

-O i

n 1.2.2 Oinone 与 Odoo 的不同之处 1. 技术方面的不同

杰

克

在技术上，Oinone 和 Odoo
有相同之处，也有不同之处。它们都基于元数据驱动的软件
系统，但是它们在如何让元数据运作的机制上存在巨大差异。Odoo
是企业管理场景的单体 应用，而 Oinone
则致力于企业商业场景的云原生应用。因此，它们在技术栈的选择、前后
端协议设计、架构设计等方面存在差异。

2.  场景方面的不同

在场景上，Oinone 和 Odoo 呈现许多差异。相对于 SAP 这些老牌 ERP
厂商，Odoo 算是西
方在企业级软件领域的后起之秀，其软件构建方式、开源模式和管理理念在国外取得了非凡
的成就。然而，在国内，Odoo 并没有那么成功或者并没有那么知名。国内做 Odoo
的伙伴普 遍认为，Odoo
与中国用户的交互风格不符，收费模式设计以及外汇管制使商业活动受到限
制，本地化服务不到位，国内生态没有形成合力，伙伴们交流合作都非常少。另外，Odoo
在场景方面主要围绕内部流程管理，与国内老牌 ERP
如用友、金蝶重叠，市场竞争激烈。相 比之下，Oinone
看准了企业视角由内部管理转向业务在线、生态在线（协同）带来的新变
化，聚焦新场景，利用云、端等新技术的发展，从企业内外部协同入手，以业务在线驱动企
业管理流程升级。它先立足于国内，做好国内生态服务，再着眼未来的国际化。

13

Oinone7 天从入门到精通 3. 无代码设计器的定位

杰

克

-O i

no ne

Odoo 的无代码设计器是一个非常轻量的辅助工具，因为在 ERP
场景下，一个企业实施
完以后，基本几年不会变，流程稳定度非常高。与之相反，Oinone
为了适应企业业务在线
化后，所有的业务变化与创新都需要通过系统来触达上下游，从而实现敏捷响应和快速创新
的需求，重点打造了五大设计器（如下图 1-2 所示）。

图 1-2 Oinone 五大设计器

在数字化时代中国软件将接棒世界，而 Oinone 也要接棒
Odoo，把数字化业务与技术的
最佳实践赋能给企业，帮助企业数字化转型不走弯路！

1.3 Oinone 的生态思考
以“企业级软件生态”的方式去帮助企业建立“一站式的商业智能软件”。 14

Oinone7 天从入门到精通

no ne

通过观察信息化到数字化的软件行业发展历程（如下图 1-3
所示），我们可以发现，企
业真正需要的是一站式的软件产品。然而，一站式的软件产品往往都是从单个领域的需求满
足开始，这在信息化时代和数字化时代都是如此。在信息化时代，以 ERP
为终点的一站式趋
势逐渐形成；而在数字化时代，中台概念的提出则标志着一站式的趋势重新开始。本文将从
企业数字化转型所面临的困境出发，探讨 Oinone 的生态思考。

图 1-3 从信息化到数字化软件行业发展历程

n 1.3.1 与中台的渊源

杰

克

-O i

中台概念的提出标志着企业数字化改造进入了一个新的时代。随着数字化转型不断深入，
企业面临着严重的数据割裂、系统隔离等问题。在这样的背景下，“敏捷响应，低成本地快
速创新”成为了推动一站式商业智能软件的内在诉求。需要澄清的是，互联网中台架构只是
一种企业解决数据割裂、系统隔离，建立一站式商业智能软件的技术概念之一，并不是技术
标准。而且这种方式只适用于企业自建模式。在多供应商环境下，则会适得其反，导致建立
更复杂的烟囱系统。 阿里于 15
年提出中台架构概念，抓住了企业数字化转型的核心诉求，即“敏捷响应，
低成本快速创新”。然而，阿里作为一家生态公司，在 16
年时基本上是带着合作伙伴来给
企业交付，但由于伙伴对互联网技术的理解和能力的限制，基本上都做得不好，甚至失败。
在 2017
年，阿里成立了原生交付团队，希望能够树立一些标杆案例。我和公司的核心成员
也都来自于这个团队。在做完几个客户后，我发现阿里也做不好，但这次做不好的原因不是
技术不行或项目上不了线，而是上线以后预期的效果没有达到，其本质是企业的
IT 组织能
力无法驾驭复杂的互联网中台架构。当无法驾驭的时候，所谓的目标“敏捷响应，快速创新”
就无从说起了。结果客户会反馈以下三类问题： 1.
不是说敏捷响应吗？为什么改个需求这么慢，不但时间更长，付出的成本也更高了？
是因为中台架构需要一定的技术能力和经验才能有效地应用，就像一个只会骑自行车的人给
他一辆汽车或者飞机，他也不能驾驭它们，更不用说是手动挡的。 2.
不是说能力中心吗？当引入新供应商或有新场景开发的时候，为什么前期做的能力
中心不能支撑了？是因为能力中心是一种面向业务的能力组织方式，它将不同的业务能力抽
象出来，以服务的形式对内提供。然而，由于业务场景的差异，不同的业务需要的能力也会
不同，因此能力中心需要不断迭代和升级。对于新引入的供应商或新场景开发，需要根据实
际情况对能力中心进行定制化和扩展化，但谁来负责呢？新项目的供应商还是客户自己？
3.
不是说性能好吗？为什么我投入的物理资源更多了？是因为中台架构采用微服务来
解决单点瓶颈问题，提高系统性能和可用性，但是在初始阶段，投入的资源可能会更多。每
15

Oinone7 天从入门到精通
个模块至少需要两个实例来保障高可用性，因此物理资源的投入量可能会比以前更多。

n 1.3.2 找解决方案

no ne

在考虑解决方案之前，我们需要思考企业数字化软件的最终状态将是什么样子。目前有
两种主要的方案（如下图 1-4 所示）：
第一种是以自建研发团队为核心。中国的大型企业已经开始尝试这种模式，看起来似乎
是一个时下比较流行的可行性方案。然而，绝大多数企业由于成本、人才团队等原因而难以
坚持下去，只能与供应商合作开发。
第二种是以供应商为核心。由于大多数企业无法选择第一种路径，他们必须接受目前分
散的情况，并通过系统集成尽可能拉通各个系统。尽管如此，在数字化时代中，真正意义上
的一站式商业智能软件供应商还未出现。

杰

克

-O i

图 1-4 企业数字化的桎梏和囹圄
对企业来说，这两种方案都非常艰难，但在大规模数字化历程中又不得不做出选择。此
外，我们还能清晰看到以下几点： 1.
"敏捷响应，低成本地快速创新"成为企业推动一站式商业智能软件的内在诉求 2.
目前没有一家软件供应商能满足企业所有外围商业场景，也不可能有这样的供应商
3. 绝大部分企业需要软件供应商，而不是自建
如何突破这种局面也成为中国软件行业发展的一个机遇。强化第一种路线只能服务于极
少数头部企业，因此我们更希望优化第二种路线并形成全新的模式。因此，我的思考是：
1.
我们的目标不是让企业学会复杂的互联网架构，而是降低互联网架构的门槛，让更
多企业真正拥有“敏捷响应，低成本快速创新”的能力。 2.
我们的目标不是输出中台方法论，而是提供中台建设的技术平台。 3.
我们的目标不是只服务大企业，而是真正赋能不同 IT
组织能力的企业，让它们都具 备持续创新的能力。
今天，许多中台软件公司告诉企业：“中台是持续演进和快速迭代的过程，因此企业需
要组建中台架构团队来实现，而他们则通过中台项目落地将中台建设方法论传授给企业。”
这句话的前半部分是正确的，因为我们之前提到企业需要具备敏捷响应业务的能力，即应变
能力，因为应变是不断变化的。然而，后半部分是不正确的，因为今天的企业已经有能力组
建团队，那么这些中台软件公司到底有什么用呢？企业真的缺少方法论吗？在 19
年，我就
提出了自己的看法：没有低代码能力的中台公司都在收取智商税，都在欺诈，因为很多企业
根本找不到足够懂互联网架构的人才。明白流氓在哪里了吗？这些流氓公司赚了很多钱，最
后责怪企业无法招到人才，这是企业的责任。因此，仍然认为“最好的赋能是降低门槛，而
不是让客户提高技术水平”。
最终，我们得出了一个服务模式的想法：构建企业级的软件生态。企业级软件生态的确
切定义是：通过开放的方式，让企业本身以及不同的软件供应商共同参与，遵循相同的技术
16

Oinone7 天从入门到精通
和数据规范，打造一体化、无需集成的各类企业级软件。如果要打造企业级软件生态，我们
列出了六个要点（如下图 1-5 所示）。

图 1-5 打造企业级软件生态需要具备的六大能力

杰

克

-O i

no ne

我很幸运地有机会通过“企业级软件生态”的方式，为企业建立“一站式的商业支持平
台”提供帮助。我们的 Oinone
平台结合了低代码开发、通用数据模型和业务产品的优势（如 下图 1-6 所示）。

图 1-6 Oinone=低代码开发平台+通用数据模型+业务产品

我们对 Oinone 一站式低代码商业支撑平台展开介绍，它大致分为 4 部分： 1.
以低代码开发平台为基础，输出具备互联网架构下的软件快速开发标准。这可以帮
助企业快速构建符合互联网架构标准的应用程序，从而实现快速响应和低成本创新。
2.
以通用数据模型为基础，满足不同软件基于同一套数据标准的扩展能力。这可以确
保不同软件系统之间的数据兼容性和互操作性，避免数据孤岛和信息隔离。 3.
在业务产品层面上，企业和伙伴基于相同的技术标准和数据标准共同提供解决方案。
这可以帮助企业和伙伴共同开发出符合标准的商业支撑平台，以提高业务效率和创新能力。
4.
最后是无代码设计器，用于满足项目开展中，超出业务标品范围之外的需求，或者
针对标品的临时需求。这可以帮助业务人员在不需要专业软件支持的情况下，自主解决业务
需求，并支持部门间的协同工作。

17

Oinone7 天从入门到精通 n 1.3.3 生态建设

杰

克

-O i

no ne

Oinone
致力于打造全球最大的无需集成的商业应用程序及其生态系统，通过开源内核、
汇集数千名开发人员和业务专家，为企业提供成本效益、一体化、模块化的解决方案，解决
所有商业需求，让不同技术之间的合作变得简单易行，摆脱烦恼的集成问题。
在客户和场景领域，我们严格限定了自身的专注领域。针对超大型头部企业，我们专注
于树立标杆，而对于大、中、小型企业，则交由我们的伙伴来支持。小微企业可以通过我们
的开源社区版获得覆盖。在企业数字化转型的核心领域中，我们的解决方案涵盖了数字化交
易场景、全渠道订单履约场景、数字化采购场景、数字化营销等产品。在其他领域，我们完
全交由伙伴来建设。由于我们自身在企业协同商务领域拥有深厚的背景，因此在该领域提供
的产品拥有特别的优势。

图 1-7 企业数字化转型核心领域

1.4 Oinone 与行业对比

18

Oinone7 天从入门到精通
随着企业数字化转型的推进，软件公司获得了许多机会。尽管竞争日趋激烈，但由于需
求旺盛，各种模式仍在不断涌现。因此，当前市场上存在各种各样的数字化转型解决方案，
围绕企业的各个方面展开。每种解决方案都有其优点和缺点。本文将从定位、技术和产品等
方面简单比较，帮助您从不同的视角了解 Oinone 的差异。

n 1.4.1 整体视角对比 一、与对标公司 Odoo 的对比 Odoo

需求变化

一站式全业务链管理平台：赋能企业信息化
一站式低代码商业支撑平台：赋能企业数字化 升级

升级

no ne

定位

Oinone

关注单一企业的管理、流程、效率的提升

关注企业价值链的网络竞争，围绕外部协同、 运营、数据、商业展开

除了稳定、安全、功能丰富度以外，更强调需

技术更替

关注稳定、安全、功能丰富度

求响应速度、用户体验、系统承载极限与弹性

-O i

扩展、智能化

表 1-1 Oinone 与对标公司 Odoo 的对比

二、与国内低代码或无代码公司对比

克

低代码或无代码公司

Oinone

低代码开发工具：提供各类系统模版，基于模 平台型
SaaS：提供各类系统产品，产品安装
版快速搭建和个性化配置。但系统模版无法再
后客户可以根据需求进行个性化调整，同时产

杰

定位

升级

品永远在线可升级 从内外部协同的商业场景出发，关注企业核心

只能支持企业内部人员使用，以完成部门级边
业务场景，适应【企业业务在线化后，所有的 场景差异

缘系统为主，一般多为没有专业软件厂商支撑
业务变化与创新都需要通过系统来触达上下 和强临时性特性

游】的时代背景，以敏捷响应业务的变化与创 新为目标

支撑单模型数据过亿，无单点瓶颈。封装互联 技术代差

单表支撑 100 万数据已是业内天花板

网架构并且做到单体与分布式的灵活部署，为 不同大小公司提供不同技术支撑

表 1-2 Oinone 与国内低代码/无代码公司对比

n 1.4.2 从技术角度对比 19

Oinone7 天从入门到精通

杰

克

-O i

no ne

我们不会与其他无代码平台进行比较，因为它们不能解决业务复杂性的问题。相反，我
们将重点介绍三种不同的低代码平台模式（如下图 1-8 所示）。
第一种模式是最基础的低代码平台，也被称为代码生成器。它通过预定义应用程序模板
和必要的配置生成代码，简化了工程搭建并提供了一些基础逻辑。虽然在信息化时代内部流
程标准化方面较为适合，但在数字化时代外部协同业务在线的情况下就不那么合适了。因为
这种模式不能减少研发难度和提高效率，也无法体现敏捷迭代快速创新的优势。
第二种模式是经典的低代码平台，以元数据为基础，以模型为驱动。当无法满足需要时，
通过特定方式将代码以插件的形式注入平台，作为低代码平台的内置逻辑，供设计器使用。
它的优点在于降低了研发门槛，当无法满足需求时才需要编写代码。它可以实现企业内部的
复杂流程和复杂逻辑，但其性能和工程管理存在局限性。性能问题使其不适合处理互联网化
的在线业务，而工程管理问题则使其不适合处理快速变化的业务。这也是许多研发人员反对
低代码的核心原因之一，因为研发人员变成了辅助角色，而软件工程是一门需要技术能力的
学科，让没有技术能力的人主导是违反常理的。对于软件产品公司来说，产品需要迭代规划，
需要多人协作，需要工程化管理。 第三种模式是 oinone
提出的基于互联网架构的低代码平台，它采用无一体的设计。首 先，oinone
屏蔽了互联网架构带来的复杂性。其次，同样以元数据为基础，以模型为驱动，
但是元数据的生成方式有两种：一种是使用无代码设计器（与经典低代码相同），另一种是
通过代码来描述元数据。通过使用代码来描述元数据，可以无缝地与代码衔接，并在不改变
研发习惯的情况下降低门槛、提高效率，并进行工程化管理。
最后总结来说：低无一体不仅仅是指两种模式的结合，还包括两种模式的融合应用方式。
具体来说，这种融合应用方式可以分为两种情况： 1.
当开发核心产品时，主要采用低代码开发，无代码设计器作为辅助。这种方式可以提高
开发效率和代码质量，同时保证产品的快速迭代和升级。 2.
当需要满足个性化或非产品支持的需求时，主要采用无代码设计器，低代码作为辅助。
这种方式可以快速地满足客户需求，并且避免对产品的核心代码产生影响。
简单来说，低代码模式适用于产品的迭代升级，而无代码设计器则适用于满足个性化和
非产品支撑的额外需求。低代码和无代码模式在整个软件生命周期中都有各自的价值，在不
同场景下可以相互融合，发挥最大的优势。

图 1-8 代码生成器、低代码平台与 Oinone 的优缺点对比

n 1.4.3 从产品角度对比 20

Oinone7 天从入门到精通
产品上的对比，从客户、场景满足度、再次销售三个方面来做简易的对比。

一、Oinone vs 数字化软件服务商 客户

满足度

销售

满足企业核心业务需求， 一站式商业智能软件，更高 并联合伙伴一起满足企业
性价比、用户体验客户范 所有需求，无需集成提供 Oinone

围：5000 万\~5 亿、5 亿～ 统一工作台、数据接口、 100 亿、

底层协议，无论基于

标杆：100 亿～1000 亿、 Oinone 的开源框架还是增 1000 亿以上

加其他应用都有很好的扩

支持 OP+SaaS 两种模式，收 费方式不同：OP 按买断方 式进行，SaaS
按效果付费 跟账号数无关，新的模块进 行二次销售

no ne

展性

针对成熟的大型企业需投 数字化软件服务商

入巨大资源和成本客户范

围：100 亿～1000 亿、1000 亿以上

满足企业部分需求，无法

输出技术标准，无法解决 OP 模式进行销售，通过设 多供应商一起开发的问

置权限来进行来实现二次

题，只能通过集成实现对 销售或无法进行二次销售 接

-O i

表 1-3 Oinone vs 数字化软件服务商

二、Oinone vs 低代码或无代码行业

克

客户

满足度

销售

从外部商业场景出发，强 业务场景驱动，符合企业

杰

一站式商业智能软件客户 从信息化管理到业务创新 支持 OP+SaaS 两种模式，
范围：5000 万\~5 亿、5 亿～ 的数字化转变的趋势。提 收费方式不同：OP
按买断

Oinone

100 亿、

供统一工作台、数据接口、方式进行，SaaS 按效果付

标杆：100 亿～1000 亿、 底层协议，无论基于 1000 亿以上

费跟账号数无关，新的模

Oinone 的开源框架还是增 块进行二次销售 加其他应用都有很好的扩 展性

针对小微企业内部信息化 低代码或无代码公司

管理诉求，以表单流程为 主客户范围：5 亿以下

满足企业部门级信息化的 适应性需求，无法满足企 按应用模块进行收费，新
业核心业务管理与业务创 的模块进行二次销售 新诉求

表 1-4 Oinone vs 低代码或无代码行业

三、Oinone vs 国外对标公司 Odoo

21

Oinone7 天从入门到精通 客户

满足度

销售

从外部商业场景出发，强 业务场景驱动，符合企业 一站式商业智能软件客户
范围：5000 万\~5 亿、5 亿～ Oinone

从信息化管理到业务创新 的数字化转变的趋势。基

支持 OP+SaaS 两种模式，

收费方式不同：OP 按买断 线产品覆盖：采购、营销、 100 亿、 方式进行，SaaS
按效果付 服务、销售、交易等企业 标杆：100 亿～1000 亿、 费跟账号数无关
商业领域。主要涉及行业： 1000 亿以上 新的模块进行二次销售
零售品牌。其他领域或行 业靠合作伙伴共建方式进

no ne

行

从企业内部管理需求出

发，逐渐拥有互联网相关

一站式企业管理软件客户 应用组件，但还是属于强 支持 OP+SaaS 两种模式，
范围：5000 万\~5 亿、5 亿～ 内部管理、弱外部场景。 收费方式相同： 100
亿、

基线产品覆盖：业务财务 按用户数+应用模块进行

-O i

标杆：100 亿～1000 亿、 一体化、人财务、进销存。收费 1000 亿以上

主要涉及行业：建造业。 新的模块进行二次销售 其他领域或行业靠合作伙
伴共建方式进行

克

表 1-4 Oinone vs 国外对标公司 Odoo

杰

Odoo

22

Oinone7 天从入门到精通 第 2 章 Oinone 的技术独特性
本章的主要目的是通过分析企业商业支撑软件的项目特性和关注点，找到企业软件发展
的另一个本质变化——新技术流派的产生。在对“互联网架构做为最佳实践为何失效”的思
考基础上，我们分析互联网中台架构的发展历史以及企业实际现状，找出其水土不服的原因。
进而引出 Oinone
的低代码开发平台如何结合互联网架构并完成创新，以满足企业数字化转
型的需求。 具体而言，本章包括以下内容：
企业软件发展的另一个本质变化：新技术流派的产生；
最佳实践为何失效？Oinone 如何打造具有企业特色的互联网架构； Oinone
独特性之源：元数据与设计原则； Oinone 独特性之单体与分布式的灵活切换；
Oinone 独特性之每一个需求都是一个模块； Oinone 独特性之低无一体。

no ne

1.  2.  3.  4.  5.  6.  

-O i

2.1 数字化时代软件业的另一个本质变化

杰

克

随着企业从信息化向数字化转变，软件公司提供的产品也由传统的企业管理软件向企业
商业支撑软件发展。这一变化带来了许多技术上的挑战和机遇。在之前的章节中，我们提到
企业的视角已经从内部管理转向业务在线和生态在线协同，这也带来了一系列新的需求。但
是，我们常常会忽视这一变化所带来的对系统要求的变化。在本章中，我们将探讨这些技术
上的变化，以及这些变化所带来的机遇和挑战。

图 2-1 从信息化到数字化软件本质变化
在信息化时代，企业的业务围绕着内部管理效率展开，借鉴国外优秀的管理经验，企业
将其管理流程固化下来，典型的例子是 ERP
项目。这类项目上线后往往长期稳定，不轻易更
改，因此信息化时代软件的技术流派侧重于通过模型对业务进行全面支持。例如，SAP
具有
丰富的配置能力，将已有企业管理思想抽象到极致。其功能基本上可以通过配置来实现，因
23

Oinone7 天从入门到精通

克

-O i

no ne

此其模型设计特别复杂。但是，我们也应该清楚地了解到，配置是面向已知问题的。在数字
化时代，创新和业务迭代速度非常快，这种方法可能就不太适合了。我们知道，模型抽象是
在设计时具有前瞻性的，一旦不适合，修改起来就会异常困难。
随着数字化时代的到来，企业主的关注点已经从单一企业内部管理转变为了围绕企业上
下游价值链的协同展开。这种变化给企业信息化系统提出了更高的要求，例如业务需求的响
应速度、系统性能和用户体验等方面。现在，企业对软件不仅是管理需求的承载，更是业务
在线化的承载。传统的重模型设计软件模式已经不再适用，因为业务本身不断创新和变化。
因此，数字化时代需要新的软件技术流派，这种流派必须是轻模型加上低代码技术的结合体。
通过模型抽象 80%的通用场景，剩余的
20%个性化需求可以通过技术手段来完成。这样的设
计可以让每家企业的研发人员轻松理解模型，而不像 ERP
模型那样异常复杂，无法进行修改。
此外，配合低代码技术可以快速研发和上线。如果说配置化是面向已知问题的，那么低代码
就是面向未知问题设计的。虽然低代码的概念可以追溯到上个世纪 80
年代，当时是为了满
足企业内部部门之间有协同需求，但又没有专业软件支撑，定制化开发又不划算的辅助场景。
但现在它的核心原因是企业数字化的核心场景不稳定，变化很快，每家企业都有强烈的个性
化需求。因此，低代码成为解决这些问题的核心手段，数字化时代的低代码需要具备处理复
杂场景的能力，而不仅仅是围绕着内部管理展开。
企业在数字化转型的过程中需要考虑到不仅是成熟的全链路业务解决方案，还要应对数
字化场景的快速变化和持续创新的需求。为此，Oinone
打造了一站式低代码商业支撑平台，
从业务与技术两个维度来帮助企业建立开放、链接、安全的数字化平台。这将在水平和垂直
两个维度上全面推动企业数字化转型。
另外，低代码的另一个好处是完成了软件本身的数字化建设。通过基于元数据设计，元
数据成为软件中数据、逻辑和交互的数据，软件结合 AI
可以有更多的创造可能。想象一下， AI
了解软件的元数据后可以自我运作，人在极少情况下才需要参与，人机交互也会发生大
的改变。未来的软件交互不再需要研发提前预设，而是能够实现用户所需即所呈现的效果。
作为一家帮助企业进行数字化转型的软件公司，请问您的数字化转型是否已经完成呢？

2.2 互联网架构作为最佳实践为何失效

杰

如果把互联网架构比作社会主义，Oinone
就是也要做有中国特色的社会主义，才能符 合国情。
随着业务和生态的发展，企业对效率、性能、体验和智能化等方面的要求越来越高，但
很多企业的系统面临着严重的系统架构落后和系统间割裂等问题，这些问题导致原有系统在
业务发展下面临着效率和性能的双重挑战。与此同时，互联网平台的技术水平远远领先于传
统企业系统，但是是否可以直接将互联网架构照搬到企业数字化转型中呢？显然，这是不合
适的，因为互联网架构在企业数字化转型中面临着许多水土不服的问题。本章节将结合互联
网中台架构的发展，分析这些问题的原因。 l

借鉴互联网中台理念

我们要先看互联网架构的发展，是如何一步步到今天提的中台架构概念的，每一步又解
决了什么具体问题，我们以阿里架构变迁史为例来看下（如下图 2-2）：

24

no ne

Oinone7 天从入门到精通

图 2-2 阿里架构变迁史

杰

克

-O i

在 2009
年，淘宝上线了五彩石项目，这标志着淘宝从单体应用向服务化应用的时代迈
出了一步。那么，淘宝为什么要开发五彩石项目呢？因为当时淘宝面临两个非常严峻的问题，
一个是性能问题，数据库连接不足，数据库成为了瓶颈；另一个是效率问题，当时淘宝有百
余个研发人员，但核心系统只有一套测试、预发、线上环境，导致研发需求排队等待。在开
始五彩石项目之前，淘宝还做了千岛湖项目，用来验证服务化架构的可行性，将用户中心独
立出来。随后，淘宝开启了五彩石项目，目标是通过增加人力来提升效率，通过增加机器来
提升性能。
随着淘宝的业务发展，他们又面临了一个问题：各个服务之间有很多重复的建设，效率
低下。为了解决这个问题，淘宝开始从服务化转向平台化，并创立了“共享业务事业部”，
将重复建设的公共业务分配给这个事业部，以避免成本浪费。这些公共业务包括商品平台、
交易平台和结算平台等。平台化的目标是规避服务化没有规划导致的重复建设问题。
但是随着业务的快速发展，淘宝变成了一个拥有几十个事业部的巨型企业，而这带来了
新的问题：效率问题。例如，如果需要在一个业务线上做出改动，需要与十几个平台进行沟
通，这是非常低效的。同时，对于一个平台来说，需要面对来自不同事业部的需求，这需要
平台研发人员具备理解和抽象所有业务线需求的能力，这让平台研发人员感觉回到了单体应
用时代，所有的需求都要排队，即使增加人力也无法提高效率。这个问题主要表现在交易平
台上。
为了解决这个问题，淘宝提出了中台的概念，中台是在一套规范下建立的，让具有专业
技能的团队自主决策业务系统发展的平台。中台的目标是弱化平台的业务特性，提供通用能
力。简而言之，就是将“共享业务”中的“业务”两个字去掉，只提供通用能力的平台
我们将每个阶段的核心目标总结为一句话： 1.
从单体到服务：通过增加人员和机器来提高效率和性能； 2.
从服务化到平台化：解决服务化阶段因缺乏规划而导致的重复建设问题； 3.
平台化到中台化：在一套规范下，让各业务团队自行决定业务系统发展，适用于多个
业务线或多个场景应用的独立发展。
类似地，在企业数字化转型过程中，也面临着类似的问题： 25

Oinone7 天从入门到精通 1.
随着企业业务在线化，对系统性能和稳定性提出了更高的要求，但由于内部系统之间
的割裂，导致很多重复建设。因此，我们需要进行服务化和平台化； 2.
没有一个供应商能够解决企业所有的商业场景问题，所以需要多个供应商共同参与。
我们可以将供应商类比为各业务线，在一套规范下让供应商或业务线自行决定业务系统的发
展。
然而，阿里的中台架构方案并不能直接照搬到企业中。因为阿里的中台架构采用了平台
共建模式，即让业务线基于平台设计的规范共同开发。这本质上还是平台主导模式，对企业
来说历史包袱较大。在企业中，让不同背景的研发一起共建交易或商品平台是非常复杂的事
情。平台化已经足够复杂，再加上共建会导致企业架构的负载过重，这对企业来说就不再是
赋能，而是“内耗”。

l

互联网中台架构在企业实践中遇到的问题

克

-O i

no ne

在《Oinone
的生态思考》一文中，《与中台的渊源》部分提到，在阿里云为企业提供
数字化项目时，客户经常会对以下三个问题提出质疑，这些问题非常突出： 1.
我们听说你们具备敏捷响应能力，但为什么改动需求如此缓慢？不仅所需时间更长，
而且成本更高？ 2.
我们听说你们有能力中心，但为什么当我们引入新供应商或开发新场景时，前期建
立的能力中心无法支持我们？ 3.
我们听说你们的性能很好，但为什么我们需要投入更多的物理资源来支持项目？
在探讨互联网架构的适用性时，我想提出以下两个问题： 1.
企业应用程序的性能问题是否与互联网平台公司遇到的性能问题相同？ 2.
企业应用程序的开发效率问题是否与互联网平台公司遇到的效率问题相同？
通过比较企业和互联网之间的差异，我们可以了解水土不服的核心原因。

企业

杰

企业 IT 组织能力无法与数字化转型的速度匹配，缺
乏足够的人才支持。为了提高开发效率，企业需要寻
找工具和技术来降低开发难度，同时提高个人开发效 率

企业无法制定并主导技术规范，这导致了能力复用的
不足。为了提高效率和减少开发成本，企业需要建立
统一的技术规范和标准，以便能力复用和组织协同。

互联网

互联网企业拥有众多优秀的人才，需要解决团队协作和
知识共享的问题，即协同开发的效率。

互联网企业可以自定义技术规范，因此能力复用更易于 保障。

企业往往当前业务量相对小，期望数字化建设能打动
互联网企业起步时的系统目标负载就高，通常会忽略资
业务发展，对业务发展的预期比较高，所以企业的诉
源起步门槛的问题，当然也可以通过自动扩容、云计算
求是即满足当下成本效应又能兼顾未来对发展预期。
等方式来解决初期的负载问题。

表 2-1 从企业与互联网的对比，看水土不服的核心原因
我们可以看到企业和互联网架构在很多方面存在着不同的需求和问题。因此，在提供数
字化服务时，Oinone
需要注意与企业的组织能力进行匹配，并根据企业自身的特性来提供
在线化的服务能力。这就像在社会主义制度下需要有中国特色一样，Oinone
也需要有适合 中国企业的特色。

26

Oinone7 天从入门到精通 2.3 Oinone 独特性之源，元数据与设计原则

杰

克

-O i

no ne

让我们来揭开 Oinone
元数据的神秘面纱，了解它的核心组成、获取方式、面向对象特
性以及带来的好处。您或许会想，这些特性能否解决企业数字化转型中互联网架构遇到的挑
战呢？ 元数据是本文多次提到的重要概念。作为 LCDP
的基础，元数据支持企业所有研发范式。
它数字化描述了软件本身，包括数据、行为和视图等方面。在描述数据时，元数据本身就是
数据的数据；在描述行为时，它就是行为的数据；在描述视图时，它就是视图的数据。只有
深入理解元数据，才能全面了解 Oinone 的其他特性。
本章节将介绍元数据的整体概览（如下图 2-3
所示），带领您了解其核心组成、面向对
象特性以及组织方式。请注意，本章节将不会详细展开元数据的细节，这些细节将在后续的
相关章程中深入介绍。

图 2-3 元数据整体视图

一：以下是元数据的核心组成介绍：

1.  模块(Module)：它是将程序划分成若干个子功能，每个模块完成了一个子功能，再
    把这些模块总起来组成一个整体。它是按业务领域划分和管理的最小单元，是一组功能、界
    面的集合。
2.  模型（Model）：Oinone
    一切从模型出发，是数据及对行为的载体。它是对所需要描
    述的实体进行必要的简化，并用适当的变现形式或规则把它的主要特征描述出来所得到的系
    统模仿品。它包括元信息、字段、数据管理器和自定义函数。同时遵循面向对象设计原则，
    包括封装、继承和多态。
3.  交互组件（UI Componment）：它用菜单、视图和 Action
    来勾绘出模块的前端交互
    拓扑，并且用组件化的方式统一管理、布局和视图。它用 Action
    来描述所有可操作行为。
4.  函数（Function）：它是 Oinone
    可执行逻辑单元，跟模型绑定则对应模型的方法。 27

Oinone7 天从入门到精通

-O i

no ne

它描述满足数学领域函数定义，含有三个要素：定义域 A、值域 C{f（x），x
属于 A}和对应 法则 f。其中核心是对应法则
f，它是函数关系的本质特征。它满足面向对象原则，可以设
置不同开放级别，本地与远程智能切换。 5.
元数据注册表：它以模块为单位的安装记录，在模块安装时，相关的元数据都会在
元数据注册表中记录。
二：元数据的产生方式，既可以通过代码注解扫描获取，也可以通过可视化编辑器直接添
加。 1. 从代码注解中扫描获取，示例如下代码（如下图 2-4 所示）。

图 2-4 从代码注解中扫描获取元数据

克

2.  可视化的编辑器添加，具体介绍参见《Oinone 的设计器》章节 三：Oinone
    是一种通用低代码开发平台，其元数据设计满足应用开发所需的所有元素，并

杰

支持所有研发范式。

它基于元数据的具体实现秉承以下原则： 1. 部署与研发无关； 2.
以模型驱动，符合面向对象设计原则； 3.
代码与数据相互融合，编辑器产生的元数据以面向对象的方式继承扩展标准产品的
元数据。 这些原则的集合使整个平台能够实现以下功能特性： 1.
开发分布式应用与单体应用一样简单，部署方式由后期决定。如果要部署为分布式
应用，则需要在 boot 工程中引入 Oinone 的 rpc 包。详见《Oinone
的分布式体验》 一章节； 2.
面向对象的特性使得每个需求都可以是独立模块，独立安装与卸载，让系统像乐高
积木一样搭建； 3.
支持两种元数据产生方式，融合的原则确保标准产品迭代与个性化保持独立，真正
做到低无一体。
四：这些特性刚好也解决了《互联网架构作为最佳实践为何失效》一章节中客户挑战的三
个刺眼问题 28

Oinone7 天从入门到精通 互联网架构落地企业数字化转型面临的问题

不是说敏捷响应吗？为什么改个需求这么慢，不单时间
更长，付出的成本也更高了？

Oinone 应对的策略

特性 1、特性 2、特性 3

不是说能力中心吗？当引入新供应商或有新场景开发的
时候，为什么前期做的能力中心不能支撑了？
不是说性能好吗？为什么我投入的物理资源更多了？

特性 2、特性 3

特性 1

表 2-2 互联网架构落地企业数字化转型面临的问题及 Oinone 应对策略

2.4 Oinone 的三大独特性

杰

克

-O i

no ne

Oinone
在技术方面通过整合互联网架构和低代码技术，实现了三个独特的关键创新点
（如图 2-5 所示）：
1．独立模块化的个性化定制：每个需求都可以被视为一个独立的模块，从而实现个性
化定制，提高软件生产效率。此外，这些独立模块也不会影响产品的迭代和升级，为客户带
来无忧的体验。
2．灵活的部署方式：单体部署和分布式部署的灵活切换，为企业业务的发展提供了便
利，同时适用于不同规模的公司，有助于有效地节约企业成本，提升创新效率，并让互联网
技术更加亲民。 3．低代码和无代码的结合：低无一体为不同的 IT
组织和业务用户提供了有效的协同工
作方式，能够快速部署安全、可扩展的应用程序和解决方案，帮助企业/组织更好地管理业
务流程并不断优化。

图 2-5 Oinone 的三大独特性

29

Oinone7 天从入门到精通 n 2.4.1 Oinone 独特性之单体与分布式的灵活切换

-O i

no ne

企业数字化转型需要处理分布式带来的复杂性和成本问题。尽管这些问题令人望而却步，
但分布式架构对于大部分企业仍然是必须的选择。如果一个低代码平台缺乏分布式能力，那
么它的性能就无法满足客户的要求。相比之下，Oinone
平台通过对部署的创新（如图 2-6
所示），成功实现了分布式架构的支持，而且能够按照客户的业务发展需求，灵活选择不同
的部署模式，同时节约企业成本，提升创新效率。这一创新是 Oinone
平台与其他低代码平 台的重要区别，能够满足客户预期发展并兼顾成本效益。

实现原理

克

图 2-6 传统部署方式 VS Oinone 部署方式

杰

要实现灵活部署的特性，必须满足两个基本要求：
1．开发过程中不需要过多关注分布式技术，就像开发单体应用一样简单。代码在运行
时应该能够根据模块是否在运行容器中，来决定路由走本地还是远程。这样可以大大减少研
发人员的工作量和技术复杂度。
2．研发与部署要分离，即"开发单体应用一样开发分布式应用，而部署形式由后期决定
"。为此，我们的工程结构支持多种启动模式，并逐一介绍了针对不同场景的工程结构类型
（如下图 2-7
所示）。这样可以让客户在后期根据业务发展情况和需求，选择最适合的部署
模式，从而达到灵活部署的目的。

30

杰

克

-O i

no ne

Oinone7 天从入门到精通

图 2-7 Oinone 工程结构梳理

在整个工程结构上，我们秉承了 Spring Boot
的规范，不会改变大家的工程习惯。而 Oinone
的部署能力则可以让我们更灵活地应对各种情况。现在，我们来逐一介绍几种常规
的工程结构以及它们适用的场景： 1. 单模块工程结构（常规操作） a.
这是非常标准的 Spring Boot 工程， 适用于简单的应用场景开发以及入门学习。
2. 多模块工程结构（常规操作） a. 这是非常标准的多 Spring Boot
工程，可以实现分布式独立启动，适用于常规 的分布式应用场景开发。 3.
多模块工程结构-独立 boot 工程模式 a.
这种工程结构在多模块工程的基础上，通过独立的 boot 工程来支撑多部署方
式。适用于中大型分布式应用场景开发。 31

Oinone7 天从入门到精通

克

-O i

no ne

b.  然而，随着工程越来越多，我们也会面临一些问题：

<!-- -->

a)  研发：环境准备非常困难，每个模块都要单独启动，研发调试跟踪困难。
b)  部署：分布式的高可靠性保证需要每个模块至少有两个部署节点，但在模
    块较多的情况下，起步成本非常高。同时，企业初期业务不稳定且规模较
    小，使用多模块工程的第二种模式会增加问题排查难度和成本。

<!-- -->

c.  此时， Oinone 的多模块工程下的独立 boot
    工程模式部署就可以发挥其灵活性， 让研发和业务起步阶段可以选择
    all-in-one 模式，等到业务发展到一定规模
    的时候，只需要把线上部署模式切换成模块独立部署，而研发还可以保留
    all-in-one 模式的优势。
d.  值得注意的是，分分合合的部署模式在传统互联网架构和低代码或无代码平台
    上都是有代价的，但是 Oinone 却可以灵活适配，只需要在 boot 工程的 yml
    文件中写入需要加载的模块就可以解决。此处我们仅介绍多模块加载配置，选
    择性忽略其他无关配置，具体配置（如下图 2-8 所示）。

图 2-8 Oinone yml 配置图

杰

4.  大型多场景工程结构-独立 boot 工程模式：

<!-- -->

a.  在多模块工程结构基础上的加强版，增加 CDM
    层设计，让不同场景即保持数据
    统一，又保持逻辑独立。这种工程结构特别适用于大型企业软件开发，其中涉
    及到多个场景的情况，例如 B 端和 C
    端的应用，或者跨不同业务线的应用，能
    够保证数据的一致性，同时也能够保持逻辑独立，避免不同场景间的代码冲突。
b.  这种工程结构是我们 Oinone 支撑“企业级软件生态”的核心，我们可以把场
    景 A 当作我们官方应用， 场景 B 当作其他第三方伙伴应用。
    在这个工程结构下，
    我们的客户可以定制化开发自己的应用，同时我们也可以通过这种模式来支持
    我们的伙伴们进行开发，实现多方共赢。
c.  基于独立 boot 工程模式，我们同样对应多种部署模式应对不同情况，并统一
    管理所有伙伴应用。这种工程结构的优点是扩展性好，可以支持不同规模的应
    用，并且可以根据需要进行快速扩展或缩小规模，具有很高的灵活性。
    基于标准产品的二开工程结构，是指基于标准产品进行二次开发，满足客户特定需求的工程
    结构。这种模式下，Oinone
    提供标准产品，客户可以根据自己的需求进行二次开发，实现
    定制化需求，同时可以利用我们的模块化开发特性，将每一个需求作为一个模块进行开发和
    管理。这种工程结构的优点是能够快速满足客户特定需求，同时也具有很好的可维护性和可
    32

Oinone7 天从入门到精通
扩展性，因为每个需求都是一个独立的模块，可以方便地进行维护和扩展。在下一篇“Oinone
独特性之每一个需求都是一个模块”文章中有详细介绍。

n

2.4.2 Oinone 独特性之每一个需求都可以是一个模块

杰

克

-O i

no ne

我们的 Oinone
平台采用模型驱动的方式，并符合面向对象设计原则，每个需求都可以
是一个独立模块，可以独立安装、升级和卸载。这让系统真正像乐高积木一样搭建，具有高
度的灵活性和可维护性。
与大部分低代码或无代码平台不同的是，它们的应用市场上的应用往往是模板式的，也
就是说，这是一个拷贝，个性化只能在应用上直接修改，而且一旦修改就不能升级。这对于
软件公司和客户来说都非常痛苦。客户无法享受到软件公司产品的升级功能，而软件公司在
服务大量客户时，也会面临不同版本的维护问题，成本也非常高。而我们的
Oinone 平台完 全避免了这些问题，让客户和软件公司都可以从中受益（如下图
2-9、2-10 所示）。

图 2-9 软件公司与客户项目的关系-让标准与个性化共存

33

no ne

Oinone7 天从入门到精通

图 2-10 软件公司与客户项目的关系-让升级无忧

实现原理

杰

克

-O i

在满足客户个性化定制需求时，传统的方法通常是直接修改标准产品源码，但这样做会
带来一个问题：标准产品无法持续升级。相反，无论是在 OP 模式还是 SaaS
模式下，Oinone
都采用全新的模块为客户进行个性化开发，保持标准产品和个性化模块的独立维护和升级。
这是因为在元数据设计时，Oinone
采用了面向对象的设计原则，实现了元数据设计与面向
对象设计思想的完美融合。 面向对象设计的核心特征包括封装、继承、多态，而
Oinone 的元数据设计完全融入了 这些思想。下面是几个例子，说明 Oinone
的元数据设计如何体现面向对象设计的核心特征， 并带来了什么好处：
1．继承：在继承原有模型的字段、逻辑、展示的情况下，增加一段代码来扩展模型的
字段、逻辑、展示。
2．多态：在继承原有模型的字段、逻辑、展示的情况下，增加一段代码来覆盖模型的
原有字段、逻辑、展示。
3．封装：外部无需关心模型内部如何实现，只需按照不同场景调用模型对应开放级别
的字段、逻辑、展示。 这些特征和优势使得 Oinone
在满足客户个性化需求时更加灵活和可持续，同时使得标
准产品的维护和升级变得更加容易和高效。 在 Java
语言设计中，万物皆对象，一切都以对象为基础。而 Oinone 的元数据设计则是
以模型为出发点，作为数据和行为的承载体。如下图 2-11 清晰地描述了 Java
面向对象编程 中封装、继承、多态在 Oinone 元数据中的对应关系。Oinone
元数据描述了 B 对象继承 A 对 象并拥有其所有属性和方法，并覆盖了 A
对象的属性 1 和方法 1，同时新增了属性 3 和方法 3。 此外，Oinone
的面向对象特性是用元数据来描述的。一方面，我们基于 Java 编码规范
收集相关元数据，以保持不改变 Java
编程习惯。另一方面，方法和对象的挂载是松耦合的，
只要按照元数据规范进行挂载，就能轻松地将其附加到模型上。在不改变原有 A
对象的情况 下，我们可以直接增加方法和属性（如下图 2-12 所示）。

34

-O i

no ne

Oinone7 天从入门到精通

杰

克

图 2-11 java 面向对象在 Oinone 元数据中对应

图 2-12 java 对象的修改 VS Oinone 元数据模型的修改 Oinone
函数不仅支持面向对象的继承和多态特性，还提供了面向切面的拦截器和 SPI
机制的扩展点，以应对方法逻辑的覆盖和扩展，以及系统层面的逻辑扩展（如下图
2-13 所 示）。这些扩展功能可以独立地在模块中维护。

35

Oinone7 天从入门到精通

-O i

no ne

其中，拦截器可以在不侵入函数逻辑的情况下，根据优先级为满足条件的函数添加执行
前和执行后的逻辑。 扩展点是一种类似于 SPI
机制的逻辑扩展机制，用于扩展函数的逻辑。通过这一机制，
可以对函数逻辑进行灵活的扩展，以满足不同的业务需求。

图 2-13 Oinone 函数拦截与扩展机制

杰

克

不管是对象、属性还是方法，都可以以独立的模块方式来扩展，这就使得每一个需求都
可以成为一个独立的模块，方便我们在研发标准产品时进行模块化的划分，同时也让我们在
以低代码模式为客户进行二次开发时，能够更好地支持“标准产品迭代与个性化保持独立”
的需求。在【oinone
独特性之低无一体】一文中，我们也提到了这个特性，但那是在低无
一体的情况下，通过元数据融合来实现的。让我们看看基于低代码开发模式下，典型的
Oinone 二次开发工程结构（如下图 2-14
所示），就可以更好地理解这个特性啦！

36

杰

克

-O i

no ne

Oinone7 天从入门到精通

图 2-15 Oinone 典型的二开工程结构

n 2.4.3 Oinone 独特性之低无一体
当今企业软件开发行业，低代码和无代码已经成为热门话题。它们的优势很明显：加速
软件开发周期、减少代码开发时间、降低开发成本、易于维护等等。而 Oinone
作为一个低 无一体的开发平台，更是在这些优势上做出了巨大的创新。

技术亮点 低代码-在不改变研发习惯的前提下，提升效率降低难度（如下图 2-16
所示）

一、提高专业开发人员效率
低代码开发模式大大降低了繁琐、重复的工作，模型定义完后，数据
API、数据管理器、
基础管理的界面都不需要再进行开发。同时，低代码模式让分布式微服务架构的系统开发变
得简单，研发人员不需要考虑分布式部署能力和大数据能力，也不需要去关心一些业务无关
37

Oinone7 天从入门到精通

杰

克

-O i

no ne

的通用能力，如权限、导入导出、国际化翻译、消息、审计等。这样，开发人员可以专注于
业务研发，从而大幅提高开发效率。 二、提升系统扩展性
在研发标品的时候，低代码模式让开发人员不再需要关心系统的扩展性。与传统模式不
同，低代码模式更加注重元数据的管理，这样就可以更好地保障系统扩展性。
三、保留研发人员习惯 Oinone
平台非常开放，满足开发人员的各种习惯，比如原有的 IDE 环境、熟悉的 Spring
Boot 工程结构等。而且在 Oinone
的低代码模式下，研发人员还可以通过无代码方
式，在线可视化地修改应用。这样，即使在使用低代码模式的情况下，开发人员也可以保留
原有的习惯，提升开发效率。 四、提供更加开放的解决方案 Oinone
提供了非常开放的解决方案，让开发人员可以自由定制和组合各种功能。当行
业出现特殊的功能需求时，开发人员可以整合成平台组件，并集成到应用中。Oinone
的低
代码模式具有高度的开放性和灵活性，这使得它在与其他低代码平台的比较中具有明显的优
势。相比其他低代码平台，Oinone
不会在无法满足特定需求的情况下限制开发人员的创造 力（如下图 2-17
所示）。

图 2-16 Oinone 低代码特性介绍

图 2-17 Oinone 低代码的被集成特性示意图 38

Oinone7 天从入门到精通
无代码-五大设计器覆盖研发方方面面，让业务、实施也能参与

杰

克

-O i

no ne

它是 LCDP 的产品化呈现，是露在外面大家看得到的冰山，核心还是在 LCDP
本身。这部 分实时在演进迭代，如您想体验最新版本，可以在 Oinone
官网：https://www.oinone.top 注册。

图 2-18 Oinone 无代码-五大设计器简述

39

Oinone7 天从入门到精通 真正的低无一体，体现在一体化的融合能力上

克

-O i

no ne

在做核心产品的时候以低代码开发为主，以无代码为辅助。见低代码开发的基础入门篇
中【设计器的结合】一文。
在做实施或临时性需求则是以无代码为主，低代码为辅助，见本教材的最后一篇【Oinone
的低无一体】，这种模式比较特殊只在 SaaS
模式下提供。当客户个性化部分无法通过无代 码设计器完成，则可以通过 SaaS
提供“低无一体”模块提供“反向生成 API 代码”的功能， 生成对应的扩展工程和
API 依赖包，再由专业研发人员基于扩展工程，利用 API 包进行开发
并上传至平台。

图 2-19 不同场景适配方式说明

杰

三、实现原理

本章节我们将从以下三个方面来解读 Oinone 的低无一体。
一：低无一体的设计原则及好处：
真正的低无一体平台应该确保标准产品迭代与个性化保持独立，让软件企业具备为客户
提供在线化的快速响应、个性化定制、持续更新等服务的能力，让企业客户能够真正自主做
到敏捷响应和快速创新。所以 Oinone
的元数据融合方案跟其他平台有所区别（如下图 2-20 所示）。

40

no ne

Oinone7 天从入门到精通

图 2-21 Oinone 与其他平台的元数据融合对比图

二：低无一体中低与无的关系：

-O i

无代码是低代码平台的图形化呈现，是低代码的一个子集，它将无限接近低代码的能力，
同时也将成为低代码平台的必备特征，是通过低代码开发的标准产品的二开配套工具。
三：低无一体中低与无的定位：

杰

克

通过表 2-3 可以看出，低代码和无代码在 Oinone
的体系中相互融合，共同构成了一个
完整的低无一体模式，提供更加开放、灵活和可扩展的解决方案，让用户能够更加轻松地完
成开发和实施。

低代码模式

无代码模式

用户群体

专业研发

产品经理、需求分析师、直接业务人员

支撑场景

企业全场景软件以及二开

核心能力

不改变研发习惯，提升研发效率

核心定位

开发标准模块

企业全场景软件以及二开，专业化场景 比较高的则需低代码支持
可视化编程无需专业编程语言知识 标准模块的二开 无标品支撑场景的新模块开发

表 2-3 Oinone 低代码开发平台的两种开发模式对比

41

Oinone7 天从入门到精通 第 3 章 Oinone 的基础入门
本章节主要是带大家快速入门， 了解基于 Oinone
如何进行开发。我们将从环境准 备、 构建自己的第一个 Oinone 的
Module、通过完成一个个小功能等维度出发带大家全面 地了解 Oinone，
这将是一个美妙的开始。 1. 环境搭建：Windows 以及 Mac 版环境准备 2.
全面了解 Oinone 之 Oinone 以模块为组织 3. 全面了解 Oinone 之 Oinone
以模型为驱动 4. 全面了解 Oinone 之 Oinone 以函数为内在 5. 全面了解
Oinone 之 Oinone 以交互为外在

no ne

3.1 环境搭建 一、基础环境说明 内容

是否必须

说明

JDK1.8

-O i

后端基础环境

必须

java 的基础运行环境 8.0.26 版本以上需要注意点： 修改：my.cnf (macOS ) /
my.ini (windows)

Idea

必须

克

杰

Mysql

时区、大小写敏感设置 lower\_case\_table\_names = 2 default-time-zone =
'+08:00' 需要注意点： 1.禁用 Lombok 插件

必须

2.java Compiler 增加 -parameters(不然 java 反射获取方法入参名会变成
arg\*) 指令 3.安装 Oinone 插件

DB GUI

非必须

Datagrip、MySQLWorkbench、DBEaver 选其一

Insomnia

非必须

GraphQL 测试工具

Git

必须

2.2.0 以上 3.8.1 以上 需要注意点：

Maven

必须

1.配置 mvn 的 settings 文件下载地址见 Oinone 开源社区群公告， 也可以联系
Oinone 合作伙伴或 服务人员 42

Oinone7 天从入门到精通 2.把 settings.xml 拷贝一份到 maven 安装目录 conf
目录下 RocketMQ

必须

4.7.1 以上

Redis

必须

5.0.2 以上

Zookeeper

必须

3.5.8 以上

前端基础环境

nvm

非必须

方便 node 的版本管理

no ne

版本要求为 12.12.0 注意事项：

nodejs

必须

1.npm 的源配置为

http://nexus.shushi.pro/repository/kunlun/ 2.源的用户名、密码见 Oinone
开源社区群公告，

-O i

也可以联系 Oinone 合作伙伴或服务人员

vue-cli

必须

vue 脚手架工具

表 3-1 基础环境说明

杰

二、基础知识准备

克

其他：canal 和 Es 的环境搭建见具体学习章节。

前端必备知识

vue3、typescript、graphql

后端必备知识

SpringBoot、MybatisPlus 表 3-2 基础知识准备

三、学习安装 Mac 见：【环境准备（Mac 版）】一文 Windows
见：【环境准备（Windows 版）】一文

n 3.1.1 环境准备（Mac 版） 工欲善其事，必先利其器。
在进行学习前，大家务必先检查环境。为了降低大家环境准备难度，基础环境全程用安
装包无脑模式进行环境配置，安装下载请移至文末参见【附件一】（提供 Mac
版本安装包， 其他操作系统请自行网上下载与安装）。 43

Oinone7 天从入门到精通 一、后端相关 （一）基础环境准备 1. 安装 jdk 1.8
（下载地址见文末【附件一】） 2. 安装 mysql 8.0.26
（下载地址见文末【附件一】）

① 安装 mysql，并配置环境变量参见第 8 点； ② 如果 mysql
启动失败，则在命令行加执行以下命令（如下图 3-1 所示）：

图 3-1 mysql 启动失败需执行的命令 3. 安装 idea
社区版（官方下载链接见文末【附件一】）

杰

克

-O i

no ne

③ 根据不同版本下载不同的 idea 插件，并安装 a.
下载后去除后缀.txt，请根据各自 Idea 版本下载对应插件（具体参见文末【附
件一】）

图 3-2 不同版本下载不同的 idea 插件

b.  点击 Preferences 菜单（快捷键 comand+,）
c.  选择 Plugins，进入插件管理页面，接下来按图操作即可（如下图 3-3
    所示）

44

Oinone7 天从入门到精通

no ne

d.  

图 3-3 插件管理页面操作示意

杰

克

-O i

e.  选择.zip 文件，不需要解压 ④ 如果安装了 Lombok，请禁用 ⑤ idea 的 Java
    Complier，不然 java 反射获取方法入参名会变成 arg\*，导致元数据
    默认取值出错。或者 pom 中加入 Complier
    插件，此方法为正解，不然上线也会有问题，我 们学习的工程都会选用 mvn
    插件方式。

图 3-4 界面操作示意图

45

Oinone7 天从入门到精通

图 3-5 完整代码 4. 安装 dataGrip 最新版本的

杰

克

-O i

no ne

过期就去删“
\~/Library/Application Support/JetBrains/DataGrip202xxxx”相关
的目录，无限期试用，或者安装其他 mysql GUI 工具。 5. 安装 git
2.2.0（下载地址见文末【附件一】） 6. 安装 GraphQL 的客户端工具 Insomnia
第一次使用看 demo【Module
启动后如何用该工具验证后端启动成功】，更多使用技巧
自行百度，下载文件见文末【附件一】，下载后需修改文件名去除.txt 后缀。 7.
安装 maven，并配置环境变量（下载地址下载地址见文末【附件一】） ① 配置
mvn 的 settings，下载附件 settings-open.xml，并重命名为
settings.xml,建议直 接放在\~/.m2/下面。下载地址见 Oinone
开源社区群公告，也可以联系 Oinone 合作伙伴或服 务人员； ② 把
settings.xml 拷贝一份到 maven 安装目录 conf 目录下。 8. 环境变量设置 vi
\~/.bash\_profile ，并执行 source ～/.bash\_profile

图 3-6 环境变量设置 ① 查看主机名：

图 3-7 查看主机名 ② 根据主机名，配置/etc/hosts
文件。此步如果没有配置，可能导致 mac 机器在启动 模块时出现 dubbo
超时,从而导致系统启动巨慢，记得把 OinonedeMacBook-Pro.local 换成自
己的主机名：

46

Oinone7 天从入门到精通

图 3-8 配置/etc/hosts 文件
（二）必备中间件安装脚本（rocketmq、zk、redis） 1. zk
（下载地址见文末【附件一】），解压并

no ne

① vi ～/.bash\_profile ，追加以下两行，并执行 source ～/.bash\_profile

图 3-9 执行 source ～/.bash\_profile ② 启动 zk

-O i

图 3-10 启动 zk

2.  rocketmq （下载地址见文末【附件一】）

克

① vi ～/.bash\_profile ，追加以下两行，并执行 source ～/.bash\_profile

杰

图 3-11 追加并执行 source ～/.bash\_profile

② 到 bin 目录下修改配置文件 runserver.sh 和 runbroker.sh

图 3-12 bin 目录下修改配置文件 ③ 启停 rocketmq

47

Oinone7 天从入门到精通

图 3-13 启停 rocketmq 3. redis （下载地址见文末【附件一】）

no ne

① 安装

图 3-14 安装 redis

-O i

② vi ～/.brah\_profile ，追加以下两行，并执行 source ～/.brah\_profile

杰

③ 启停

克

图 3-15 执行 source ～/.brah\_profile

图 3-16 启停

（三）晋级中间件安装脚本（canel，es）

TBD

二、前端环境准备 1. 安装 nvm，便于 node 的版本管理 http://nvm.sh

图 3-17 安装 nvm 2. vi ～/.bash\_profile ，追加以下一行，并执行
source～/.bash\_profile 48

Oinone7 天从入门到精通

图 3-18 执行 source～/.bash\_profile 3. 用 nvm 安装 nodejs 版本 12.12.0

图 3-19 用 nvm 安装 nodejs

no ne

4.  vi ～/.bash\_profile ，追加以下一行，并执行 source ～/.bash\_profile

图 3-20 执行 source ～/.bash\_profile

-O i

5.  安装 vue-cli

图 3-21 安装 vue-cli

杰

克

6.  配置 npm 源

图 3-22 配置 npm 源

7.  登录 npm 账号

图 3-23 登录 npm 账号 username、password、email 请见 Oinone
开源社区群公告，也可以联系 0inone 合作伙 伴或服务人员。 8. 安装 cnpm

图 3-24 安装 cnpm 49

Oinone7 天从入门到精通
至此所有环境准备好了，我们就正式要进入学习如何使用 Oinone
进行业务开发了。

三、其他说明 解决一些新版 mac 系统“每次都需 source
～/.bash\_profile”的问题，vi \~/.zshrc 新 建.zshrc 文件，添加内容为
source .bash\_profile，保存退出后执行 source \~/.zshrc 命 令

n 3.1.2 环境准备（Windows 版） 一、后端基础环境准备 （一）安装 JDK 1.8
（下载地址见文末【附件一】） 打开 Windows 环境变量配置页

no ne

1.  

克

-O i

此电脑 =&gt; 右键属性 =&gt; 系统高级设置 =&gt; 环境变量 2. 配置环境变量
在用户环境变量中新建变量为 JAVA\_HOME 的项,值为 JDK 安装之后的：

图 3-25 新建变量 JAVA\_HOM

杰

编辑变量为 Path 的项添加一个值%JAVA\_HOME%\bin：

图 3-26 添加一个值%JAVA\_HOME%\bin
3.

PowerShell 或者 CMD 中验证：

50

Oinone7 天从入门到精通

图 3-27 验证 输出类似信息为安装配置成功。 （二）安装 Apache Maven
3.8+（下载地址见文末【附件一】）

克

-O i

no ne

1.  删除 Maven 安装目录下的 conf/settings.xml
2.  下载到 C:\Users\你的用户名.m2 目录中并重命名为 settings.xml
3.  配置环境变量 在用户环境变量中新建变量为 M2\_HOME 的项,值为 Maven
    安装路径：

图 3-28 新建变量 M2\_HOME

杰

编辑变量为 Path 的项添加一个值%M2\_HOME%\bin：

图 3-29 添加一个值%M2\_HOME%\bin
4. 验证

51

Oinone7 天从入门到精通 图 3-30 验证 （三）安装 Jetbrains IDEA 2020.2.4
（下载地址见文末【附件一】）

克

-O i

no ne

1.  插件安装（详见文末【附件一】）
2.  如果 IDEA 安装了 Lombok 插件,请禁用 Lombok 插件
3.  点击菜单项 File =&gt; Settings =&gt; Plugins

图 3-31 点击菜单项 File =&gt; Settings =&gt; Plugins

杰

选择下载的插件包，下载后去除后缀.txt，请根据各自 Idea
版本下载对应插件（具体 参见文末【附件一】）

图 3-32 不同 Idea 版本对应插件 52

Oinone7 天从入门到精通

no ne

,

杰

克

-O i

图 3-33 操作指引

图 3-34 操作指引

（四）安装 MySQL 8 （下载地址见文末【附件一】）

1.  解压下载的 ZIP 安装包, 复制到自定义安装目录
2.  设置环境变量 MYSQL\_BASE\_DIR 提换成 MySQL 安装目录路径
3.  把 %MYSQL\_BASE\_DIR%\bin 加入到系统环境变量中 在 PowerShell
    中可以使用 Get-Command mysqld 命令验证环境变量是否配置成功，执行
    成功输出 mysqld 的所在路径
4.  初始化 在命令行中执行 mysqld --initialize-insecure --user=mysql
5.  安装 mysqld -install
6.  启动 MySQL 服务 mysqld -install
7.  设置 root 用户密码 53

Oinone7 天从入门到精通

杰

克

-O i

no ne

alter user 'root'@'localhost' identified with mysql\_native\_password by
'Oinone'; flush privileges; （五）安装 DB GUI 工具
Datagrip、MySQLWorkbench、DBEaver 选其一 （六）安装
Git（下载地址见文末【附件一】） （七）安装 GraphQL 测试工具
Insomnia（下载地址见文末【附件一】） （八）安装
RocketMQ（下载地址见文末【附件一】） 1. 修改安装目录下 bin 中的 ①
runserver.cmd 文件内容 -Xms2g -Xmx2g 为 -Xms1g -Xmx1g ② runbroker.com
文件内容 -Xms2g -Xmx2g 为 -Xms1g -Xmx1g，以及 -XX:G1HeapRegionSize=1m 2.
启动 RocketMQ NameServer RocketMQ 安装目录\bin\mqnamesrv.cmd start 3.
启动 RocketMQ Broker RocketMQ 安装目录\bin\mqbroker.cmd -n
localhost:9876 4. 停止 mqshutdown.cmd broker mqshutdown.cmd namesrv
（九）安装 ElasticSearch 版本 8.4.1 （下载地址见文末【附件一】） ES
运行时需要 JDK18 及以上版本 JDK 运行环境, ES 安装包中包含了一个 JDK18
版本 set JAVA\_HOME=ES 安装路径\jdk
1. 启动 ES 安装路径\bin\elasticsearch.bat 2. 停止 ctrl+c 或者关闭
cmd、PowerShell 的窗口 （十）安装 Redis（下载地址见文末【附件一】） 1.
解压安装包到安装目录； 2. 在 PowerShell 进入到 Redis 安装目录； 3. 在
PowerShell 中执行.\redis-server.exe， 输出图中类似信息 （如下图 3-35
所示） ：

图 3-35 在 PowerShell 中执行.\redis-server.exe

54

Oinone7 天从入门到精通 4. 新开 PowerShell 窗口, 进入到 Redis 安装目录,
执行.\redis-cli.exe 回车，输入 ping 回车输出 PONG 即表示 Redis
安装成功。

图 3-36 执行.\redis-cli.exe 回车 （十一）Zookeeper
安装（下载地址见文末【附件一】）

-O i

no ne

1.  解压安装, 在 PowerShell 中执行 tar zxvf 安装包路径(tar.gz 包) -C Zk
    安装目录
2.  进入 Zk 安装目录\conf\复制 zoo\_sample.cfg 文件为 zoo.cfg
3.  修改 zoo.cfg 文件的内容（其中 dataDir 需要自己设定）

克

图 3-37 操作演示

杰

4.  进入 Zk 安装目录\bin\执行 zkServer.cmd
5.  新开 PowerShell 窗口, 进入到 Zk 安装目录, 执行
    zkCli.cmd，连接成功后输入 ls / 输出类似信息即安装成功

图 3-38 操作演示

二、前端环境准备 （一）安装 nodejs 版本 12.12.0
（下载地址见文末【附件一】

1.  下载 zip 包之后解压到安装目录
2.  配置环境变量 ① 添加 NODE\_HOME 环境变量

55

no ne

Oinone7 天从入门到精通

图 3-39 添加 NODE\_HOME 环境变量

杰

克

-O i

② 编辑 PATH 环境变量

图 3-40 编辑 PATH 环境变量 3. 打开 PowerShell 输入

56

Oinone7 天从入门到精通 图 3-41 打开 PowerShell 输入
输出类似信息，即为成功安装 node 与 npm

no ne

图 3-42 成功安装 node 与 npm （二）安装 vue-cli

-O i

图 3-43 安装 vue-cli

克

安装完成之后执行 vue --version

图 3-44 执行 vue --version

杰

输出类似信息，即为成功安装 vue/cli （三）配置 NPM 源

图 3-45 配置 NPM 源 （四）登录 NPM 源账号

图 3-46 登录 NPM 源账号指令

57

Oinone7 天从入门到精通 图 3-47 登录 NPM 源账号

图 3-48 登录 NPM 源账号

no ne

（五）安装 cnpm （参见 https://www.npmjs.com/package/cnpm）

-O i

图 3-49 安装 cnpm 指令

克

图 3-50 安装 cnpm

杰

3.2 Oinone 以模块为组织

模块(module):是按业务领域划分和管理的最小单元，是一组功能、界面的集合。
带大家快速认识下如何构建一个 Oinone
的模块并启动它。我会从以下几个维度去介绍
模块的构建与启动方式、模块详解。让大家直观且全方位地了解 Oinone
的模块所包含的内 容： 1. 构建第一个 Module 2. 启动前端工程 3. 应用中心

n

3.2.1 构建第一个 Module

所有环境准备就绪，就让我们踏上 Oinone 的奇妙之旅吧。先搞个 demo
模块【展示名为 “Oinone 的 Demo
工程”，名称为“demoCore”，编码为“demo\_core”】试试看，本节学
习目的就是能把它启动起来，有个大概的认知。

一、后端工程脚手架 使用如下命令来利用项目脚手架生成启动工程： 1. 新建
archetype-project-generate.sh 脚本，或者直接下载 58

杰

克

-O i

no ne

Oinone7 天从入门到精通

59

no ne

Oinone7 天从入门到精通

-O i

图 3-51 新建 archetype-project-generate.sh 脚本

克

2.  Linux/Unix/Mac 需要执行以下命令添加执行权限

图 3-52 执行命令添加执行权限

杰

3.  根据脚本中的注释修改项目变量（demo 工程可无需编辑）
4.  执行脚本

图 3-53 执行脚本

二、后端工程结构介绍 通过脚手架生成的 demo 工程是我们【Oinone
独特性之单体与分布式的灵活切换】一文
中介绍的单模块工程结构，属于入门级的一种，麻雀虽小五脏俱全，特别适合新手学习。
1. 结构示意图（如下图 3-54）

60

no ne

Oinone7 天从入门到精通

图 3-54 结构示意图 2. 工程结构说明 工程名

包名

说明

-O i

对外 api 包，如果有其他模块需

杰

克

pamirs-demo-api

要依赖 demo 模块，则可以在其 pom 中引入 pamirs-demo-api 包

constant

常量的包路径

enumeration

枚举类的包路径

Model

该领域核心模型的包路径

service

tModel

DemoModule

pamirs-demo-boot

该领域对外暴露接口 api 的包路 径 存放该领域的非存储模型如：用
于传输的临时模型 该类是 Demo 模块的定义

demo 模块的启动类

boot

DemoApplication

启动类的包路径 Demo 模块的应用启动类，遵循 spring boot 规范

61

Oinone7 天从入门到精通 resources/config/application-dev.yml

resources/bootstrap.yml

研发环境的 yml 配置文件，遵循 spring boot 规范 启动的 yml 配置文件，遵循
spring boot 规范

pamirs-demo-core

action

模型对外交互的行为的包路径

init

模块初始化工作的包路径 manager 是 service 的一些公共
逻辑，不会定义为独立的

no ne

manager

function 的类

service 是对应 api 工程中

service

service 接口的实现类，是模型 的 function

三、pom.xml （一）父 pom 的依赖管理

-O i

表 3-3 工程结构说明

杰

克

1.  一个是启动包依赖 ① pamirs-boot
    里是有我们多种启动模式依赖包。教程只介绍标准启动模式 ②
    pamirs-base-standard
2.  这里为了方便介绍下面的 demo-boot 工程和匹配 Oinone
    的前端应用，我们直接引入 了
    pamirs-core，它提供了一些基础业务功能，比如国际化、消息、用户、权限、商业关系
    等等模块，这些基础的功能模块为我们前端工程提供的一些基础能力，这个在后续会介绍。
    如果不用我们的 Oinone 提供的前端工程，可以不依赖。

62

-O i

no ne

Oinone7 天从入门到精通

图 3-55 父 pom 的依赖管理

杰

克

（二）pamirs-domo-api 一个标准 java 工程，可以看出只是依赖了，我们的
pamirs-base-standard

图 3-56 pamirs-domo-api

（三）pamirs-demo-core 一个标准 java 工程，可以看出只是依赖了，我们的
pamirs-demo-api

63

no ne

Oinone7 天从入门到精通

图 3-57 pamirs-demo-core

（四）pamirs-demo-boot

杰

克

-O i

把启动的时候，需要启动的 module（模块）对应的
jar，进行依赖引入。这样就可以在 我们的 yml 文件中进行启动 module 的配置
1. 所需 module（模块）对应的 jar（如下图 3-58）

图 3-58 所需 module（模块）对应的 jar 2. yml 文件基础配置，boot 工程的
yml 配置详情请见【模块之 yml 文件结构详解】介 绍这一节

64

Oinone7 天从入门到精通

图 3-59 yml 文件基础配置

四、DemoModule 的定义

杰

克

-O i

no ne

到此我们一个 Oinone 中的一个 module
对应的工程就介绍完了。到目前为止跟一般的 spring boot
的工程没有太多区别，就多做了一个 DemoModule 的定义，Oinone 的所有 Module
都继承自 PamirsModule。

图 3-60 DemoModule 的定义

（一）配置注解 通过@Module 的 name
属性配置模块技术名称，前端与后端交互协议使用模块技术名称 来定位模块。
通过@Module 的 displayName 属性配置模块展示名称，在产品视觉交互层展现。
通过@Module 的 version
属性配置模块版本，系统会比较版本号来决定模块是否需要进 行升级。
通过@Module 的 priority
属性配置模块优先级（数字越小，优先级越高），系统会根
据优先级取优先级最高的应用设置的首页来作为整个平台的首页。

65

Oinone7 天从入门到精通 通过@Module 的 dependencies 属性和 exclusions
属性来配置模块间的依赖互斥关系，
值为模块编码数组。如果模块继承了另一模块的模型或者与另一模块的模型建立了关联关系，
则需要为该模块的依赖模块列表配置另一模块的模块编码。 通过@Module.module
配置模块编码，模块编码是模块在系统中的唯一标识。 通过@Module.Advanced 的
selfBuilt 属性配置模块是否为平台自建模块。 通过@Module.Advanced 的
application 属性配置模块是否为应用（具有视觉交互页面
的模块）。模块切换组件只能查看到应用。 通过@UxHomepage
注解配置首页。@UxHomepage 注解的 Model 属性指定跳转页面的模型 编码，name
属性指定跳转页面的视图动作，默认为列表页。如果配置首页为列表页且未定 义
ViewAction，系统会根据首页配置自动生成。 更多 Module
的详细元数据描述介绍参见【模块元数据详解】

（二）配置扫描路径

no ne

设置扫描模型配置的包路径： l 使用 packagePrefix
方法来配置模块需要扫描模型配置的包路径 l 使用 dependentPackagePrefix
方法来配置依赖模块的模型配置的包路径；如果不
配置，会默认根据依赖模块的配置扫描模型配置的包路径扫描依赖模型 l
不同模块包路径包含会导致模型加载模块出问题

（三）命名规范

默认取值规则

命名规范

-O i

属性

1.  使用下划线命名法

无默认值

module

开发人员定义规范示例：

name

杰

克

{项目名称}\_{模块功能示意名称}

2.  仅支持数字、大写或小写字母、下划线
3.  必须以字母开头
4.  不能以下划线结尾
5.  长度必须小于等于 128 个字符

6.  使用大驼峰命名法
7.  仅支持数字、字母

无默认值

3.  必须以字母开头
4.  长度必须小于等于 128 个字符

表 3-4 命名规范

五、DemoModule 的启动 1. 修改 yml
文件中数据源配置，数据库地址与密码修改为自己本地。 2.
需要为启动或依赖模块配置扫描路径，配置扫描路径：pmairs 是我们的 Oinone
的 基 础 包 （ 必 选 ） ， himalaya ， tanggula 是 我 们 的 业 务 模 型
基 础 包 （ 可 选 ） ， pro.shushi.pamirs.demo
是我们测试项目包路径（必选，只不过它也在 pamirs 路径下，不 填也不错)。

66

no ne

Oinone7 天从入门到精通

图 3-61 数据源配置

杰

克

-O i

3.  启动应用，我们会发现报错。这个错误主要因为 Oinone 默认的是
    RELOAD（重启）模 式，这种模式下只会从数据库中读取已安装模块并与 yml
    文件中配置需要加载的模块对比。
    如果数据库中没有则会报没有安装过\*\*模块，而我们是第一次启动，前面必然没有安装过模
    块，所以我们要把模式变为
    INSTALL，启动参数相见【模块启动指令】一节。如果整个平台
    第一次启动则回报 'base\_sequence\_config' doesn't exist。

图 3-62 启动应用会发现会报错

67

Oinone7 天从入门到精通

图 3-63 因为首次启动未没有安装相关模块

克

-O i

no ne

4.  把模式变为 INSTALL 再次启动：

杰

图 3-64 把模式变为 INSTALL 再次启动

5.  查看日志，看到对应启动字样才代表启动完成，而非 Spring Boot
    的启动完成日志。 我们的 Oinone 的启动是在 Spring Boot
    启动完以后异步启动的：

图 3-65 查看日志 6. 打开 GraphQL 客户端 Insomnia 看对应服务是否暴露 ①
创建一个 demo 项目： 68

-O i

no ne

Oinone7 天从入门到精通

杰

克

图 3-66 创建一个新项目

图 3-67 命名为 demo

② 为 demo 项目创建一个请求集合：

69

Oinone7 天从入门到精通 图 3-68 为 demo 项目创建一个请求集合（第一步）

-O i

no ne

图 3-69 为 demo 项目创建一个请求集合（第二步）

克

图 3-70 为 demo 项目创建一个请求集合（第三步）

杰

③ 创建一个请求 command+N：

图 3-71 创建一个请求 command+N

70

Oinone7 天从入门到精通 图 3-72 选择 POST

杰

克

-O i

no ne

图 3-73 输入地址

图 3-74 切换结构并选择 GQL

④ 检验结果，对应后端提供的服务已经有提示了:

71

no ne

Oinone7 天从入门到精通

图 3-75 检验结果

杰

克

-O i

⑤ 查看 schema 文档

图 3-76 选择文档

72

Oinone7 天从入门到精通

no ne

图 3-77 查看 schema 文档

图 3-78 查看细节说明

-O i

恭喜第一个 Oinone 的模块已经启动完成，在下一节中我们来通过页面来看看
Oinone 的系统长啥样。

n 3.2.2 启动前端工程

克

本节核心是带大家直观的感受下我们上节构建的 demo
模块，并搭建前端环境为后续学 习打下基础.

杰

一、使用 vue-cli 构建工程

图 3-79 使用 vue-cli 构建工程

如果启动报错，清除 node\_modules 后重新 npm i mac 清除命令：npm run
cleanOs windows 清除命令: npm run clean 二、启动前端工程 找到 README.MD
文件，根据文件一步一步就行 1. 找到 vue.config.js 文件，修改
devServer.proxy.pamirs.target 为后端服务的地 址和端口；

73

克

-O i

no ne

Oinone7 天从入门到精通

杰

图 3-80 修改 devServer.proxy.pamirs.target

注：要用 localhost 域名访问，.env 文件这里也要改成
localhost。如果开发中一定要 出现前后端域名不一致，老版本 Chrome
会有问题，修改可以请参考
https://www.cnblogs.com/willingtolove/p/12350429.html。或者下载新版本
Chrome。 2. 进入前端工程 demo-front 文件目录下，执行 npm run
dev，最后出现下图就代表启 动成功；

图 3-81 启动成功界面

74

Oinone7 天从入门到精通 3. 使用 http://127.0.0.1:8081/login
进行访问，并用 admin 账号登陆，默认密码为 admin；

no ne

图 3-82 登录界面

克

-O i

4.  点击左上角进行应用切换，会进入 App Finder
    页面，可以看到所有已经安装的应用， 可以对照 boot 的 yml
    配置文件看。但细心的小伙伴应该注意到了，在 App Finder 页面出现
    的应用跟我们启动工程 yml
    配置文件中加载的启动模块数不是一一对应的，同时也没有看到 我们 demo
    模块。

杰

图 3-83 已安装应用界面

boot 工作的 yml 文件中加载模块

App Finder 的应用

说明

-   base
-   common
-   sequence

无

模块的 application = false

有

模块的 application = true

无

刚建的 OinoneDemo 工程，默认为 false

-   international
-   resource
-   user
-   auth
-   business
-   message
-   apps
-   demo\_core

75

Oinone7 天从入门到精通 设计器：无

设计器：无

因为 boot 中没有加载设计器模块，所以 App Finder 中的设计器 tab
选项卡下没有应用

表 3-5 boot 工作的 yml 文件中加载模块及 App Finder 应用说明

no ne

5.  只需要修改 OinoneDemo 工程的模块定义如下图（如下图 3-84
    所示），那么就可以 在 App Finder 页面看见“OinoneDemo 工程”。

杰

克

-O i

图 3-84 修改 OinoneDemo 工程的模块定义

图 3-85 在 App Finder 页面即可看见“OinoneDemo 工程”

目前 Oinone 的 Demo
模块还是一个全空的模块，所以我们还点击不了。在后续的学习过
程中我们会不断完善该模块 至此恭喜您，前端工程已经启动完成。

三、前端工程结构介绍 ├── public 发布用的目录，index.html
入口文件将在这里 │ ├── src 源代码 │ ├── actions 扩展动作的目录 │ ├──
assets css/image 等静态资源目录 │ ├── field 模型字段对应控件目录 │ ├──
layout 布局控件目录 │ ├── middleware 中间件 │ │ └── network-interceptor
网络请求拦截处理 76

Oinone7 天从入门到精通 │ ├── view 自定义视图目录 │ └── main.ts
应用入口文件 这里会注册 providers/application.ts ├── .env.example
启动的环境变量，后端 api 的请求地址在这里 ├── package.json 包描述文件
├── tsconfig.json ts 配置文件，可配置语法校验 └── vue.config.js vue
的配置文件，里面可以配置 webpack 参数和开发模式的后端 api 请求地址

n 3.2.3 应用中心 在 App Finder 中点击应用中心可以进入 Oinone
的应用中心，可以看到 Oinone 平台所
有应用列表、应用大屏、以及技术可视化。

no ne

一、应用列表

杰

克

-O i

标准版本不支持在线安装，只能通过 boot 工程的 yml 文件来配置安装模块。在
www.oinone.top 官方 SaaS
平台客户可以在线管理应用生命周期如：安装、升级、卸载。同
时针对已安装应用可以进行无代码设计（前提安装了设计器），针对应用类的模块则可进行
收藏，收藏后会在 App Finder
中我收藏的应用中出现。在应用列表中可以看到我们已经安
装的应用以及模块，Oinone Demo 工程也在其中。

图 3-86 在线管理应用生命周期

77

Oinone7 天从入门到精通

图 3-87 收藏后会在 App Finder 中的我收藏的应用中出现

no ne

二、应用大屏

杰

克

-O i

但我们的测试应用没有设置应用类目，则无法在应用大屏中呈现。

图 3-88 未设置应用类目则无法在应用大屏中呈现

三、技术可视化
在技术可视化页面，出展示已经安装模块的元数据，并进行分类呈现。

78

Oinone7 天从入门到精通

3.3 Oinone 以模型为驱动

no ne

图 3-89 技术可视化分类呈现

杰

克

-O i

模型（Model）：Oinone 一切从模型出发，是数据及对行为的载体： a.
是对所需要描述的实体进行必要的简化，并用适当的变现形式或规则把它的主要特
征描述出来所得到的系统模仿品。模型由元信息、字段、数据管理器和自定义函数
构成； b. 符合面向对象设计原则包括：封装、继承、多态。
本章将带大家快速而全方位地认识 Oinone
的模型，会从以下几个维度去对模型展开详 细介绍。 1. 构建第一个 Model 2.
模型的类型 3. 模型的数据管理器 4. 模型的继承 5. 模型编码生成器 6.
枚举与数据字典 7. 字段序列化方式 8. 字段类型之基础与复合 9.
字段类型之关系与引用

n

3.3.1 构建第一个 Model

定义模型，并配上相应的菜单或配置模块的 homepage
为该模型，模块就具备了可访问
的该模型对应的列表页、新增页、修改页、删除记录和导入导出功能。 都说
Oinone 是以 Model 为驱动，对于模型的理解，希望通过本节跟给大家带来一个初
步的认识。

一、构建宠物店铺模型

79

Oinone7 天从入门到精通

no ne

图 3-90 构建宠物店铺模型

二、配置注解

克

-O i

模型类必需使用@Model 注解来标识当前类为模型类。
可以使用@Model.Model、@Fun 注解模型的模型编码（也表示命名空间），先取
@Model.Model 注解值，若为空则取@Fun 注解值，若皆为空则取全限定类名。
使用@Model.Model 注解配置模型编码，模型编码唯一标识一个模型。 请勿使用
Query 和 Mutation 作为模型编码和技术名称的结尾。 上方示例使用 Model
注解和 Field 注解来定义一个实体模型。displayName 属性最终会 作为 label
展现在前端界面上。 更多 Model 的详细元数据描述介绍参见【模型元数据详解】
1. 模型命名规范

name

默认取值规范

杰

模型属性

命名规则规范

1.  仅支持数字、字母
2.  必须以字母开头

默认取 Model.Model 的点分割最后一位

3.  长度必须小于等于 128 个字符
4.  仅支持数字、大写或小写字母、下划线

module

无默认值

2.  必须以字母开头

开发人员定义规范示例：

3.  不能以下划线结尾

{项目名称}\_{模块功能示意名称}

4.  长度必须小于等于 128 个字符

默认使用全类名，取 lname 的值 Model

开发人员定义规范示例： {项目名称}.{模块功能示意名称}.{简单 类名}

display\_name

空字符串

1.  仅支持数字、字母、点
2.  必须以字母开头
3.  不能以点结尾
4.  长度必须小于等于 128 个字符

长度必须小于等于 128 个字符

80

Oinone7 天从入门到精通 符合 java 命名规范，真实的 java 全类名，lname
是不能定义的，为全类名：包名+类 lname

无法指定，要符合 Model 的约束，即为包 名，和 Model
一样的校验规则：包名和类名 名+类名

的校验 1. 不能使用分号

summary

默认使用 displayName 属性

descripition

NULL，注解无法定义

2.  长度必须小于等于 128 个字符

长度必须小于等于 65535 个字符

默认使用 name 字段生成表名时，table 字 table

段的命名规则约束同样生效（大小驼峰命 名转为下划线分割的表名称）

2.  长度必须小于等于 128 个字符（此限制
    为系统存储约束，与数据库本身无关）

no ne

java 属性类型与数据库存储类型可执行

type

1.  仅支持数字、字母、下划线

转换即可

ModelTypeEnum 枚举值

表 3-6 模型命名规范 2. 字段命名规范

默认取值规范

默认使用 java 属性名

field

默认使用 java 属性名

默认使用 name 属性

杰

display\_name

克

name

lname

命名规则规范

-O i

字段属性

2.  必须以小写字母开头
3.  长度必须小于等于 128 个字符

与 name 使用相同命名规则约束

长度必须小于等于 128 个字符

使用 java 属性名，符合 java 命名规范， 真实的属性名称，无法指定

1.  仅支持数字、字母

与 name 使用相同命名规则约束 1. 仅支持数字、字母、下划线

column

列名为属性名的小驼峰转下划线格式

2.  长度必须小于等于 128 个字符（此限制为
    系统存储约束，与数据库本身无关）
3.  不能使用分号

summary

默认使用 displayName 属性

2.  长度必须小于等于 500 个字符

表 3-7 字段命名规范 我们重启 Demo 应用以后，打开 Insomnia 刷新 GraphQL
的 schema，就可以看到 PetShop 默认对应的读写服务了：

81

-O i

no ne

Oinone7 天从入门到精通

杰

克

图 3-91 PetShopQuery 默认读写服务

图 3-92 PetShopMutatiom 默认读写服务

三、配置模块的主页为宠物商店的列表页
为了方便大家对模型有个更加直观的了解，接下来我们通过前端交互来感受下。
在【启动前端工程】一节，在模块下拉列表中“OinoneDemo
工程”还是不能点击的。
是因为该模块没有配置主页，我们现在把主页设置为宠物商店的列表页，只需要在
82

Oinone7 天从入门到精通

no ne

DemoModule
这个类上增加一个注解@UxHomepage(@UxRoute(PetShop.Model\_Model))，关于
改注解的更多说明查看【UxHomepage 注解详解】。

图 3-93 “OinoneDemo 工程”主页配置

杰

克

-O i

重启 demo 应用，打开前端页面登陆后并通过 App Finder 切换至“OinoneDemo
工程”， 我们跟着下面操作一步一步来体验下： 1. 在 App Finder
的应用列表选中 OinoneDemo 工程，我们会看到系统进入了宠物商店 列表:

图 3-94 进入了宠物商店列表

2.  点击宠物商店列表页面中新增按钮进入宠物商店的新增页面：

图 3-95 进入宠物商店的新增页面

83

Oinone7 天从入门到精通 3.
点击宠物商店的新增页面的确定按钮，回到宠物商店列表，并能看到刚刚新增的记
录：

图 3-96 新增记录产生

-O i

no ne

4.  对宠物商店列表的数据记录可以进行编辑、详情操作。如点击编辑则进入数据记录
    的宠物商店数据记录的编辑页:

图 3-97 宠物商店数据记录的编辑页

杰

克

四、查看数据库 大家可能会问我们的数据存储哪里去了？ 我们这个 demo
应用一共生成了两个库包括 demo 和 demo\_base,分别对应 yml 文件两个 数据源
pamirs 和 base，base 库存放系统元数据，pamirs 库存放了 demo
模块以及其他安装 模块的数据：

图 3-98 pamirs 库存放了 demo 模块以及其他安装模块的数据 那我们来找到
demo 库， 就可以看到有一个 demo\_core\_pet\_shop 表以及我们新增的数据。
库、表的规则是 boot 工程里的 yml 文件配置的，如何配置可以参考【yml
文件结构详 解】一节。 定义模型，并配上相应的菜单或配置模块的 homepage
为该模型，模块就具备了可访问
的该模型对应的列表页、新增页、修改页、删除记录和导入导出功能。是不是上手还是比较
容易的，本节学习就先到这里。
注：本节中的所有页面都是系统默认的，更多有关前端交互包括菜单、页面、行为知识
可以在【Oinone 以交互为外在】一章中详细学习。

84

Oinone7 天从入门到精通

n

3.3.2 模型的类型

本文会介绍不同类型模型以及其简单的应用场景，方便大家理解不同类型模型的用途。
模型分为元模型和业务模型。元数据是指描述应用程序运行所必需的数据、规则和逻辑
的数据集；元模型是指用于描述内核元数据的一套模式集合；业务模型是指用于描述业务应
用元数据的一套模式集合。
元模型分为模块域、模型域和函数域三个域。域的划分规则是根据元模型定义数据关联
关系的离散性来判断，离散程度越小越聚集到一个域。前文【模块元数据详解】中
ModuleDefinition 就是元模型。而我们在开发中涉及的就是业务模型。

一、模型类型 抽象模型 传输模型 存储模型 代理模型

no ne

l l l l

二、模型定义种类 l

三、安装与更新

克

-O i

静态模型定义：模型元数据不持久化、不进行模型定义的计算（默认值、主键、继
承、关联关系） l
静态计算模型定义：模型元数据不持久化但初始化时进行模型定义计算获得最终的
模型定义 l
动态模型定义：模型元数据持久化且初始化时进行模型定义计算获得最终的模型定
义 静态模型定义需要使用@Model.Static 进行注解；静态计算模型定义使用
@Model.Static(compute=true)进行注解;动态模型定义不注解@Model.Static
注解。

杰

使用@Model.Model
来配置模型的不可变更编码。模型一旦安装，无法在对该模型编码
值进行修改，之后的模型配置更新会依据该编码进行查找并更新；如果仍然修改该注解的配
置值，则系统会将该模型识别为新模型，存储模型会创建新的数据库表，而原表将会
rename 为废弃表。 如果模型配置了@Base 注解，表明在【Oinone
的设计器】中该模型配置不可变更；如果 字段配置了@Base
注解，表明在【Oinone 的设计器】中该字段配置不可变更。

四、基础配置 （一）模型基类

所有的模型都需要继承以下模型中的一种，来表明模型的类型，同时继承以下模型的默
认数据管理器（详见【模型的数据管理器】一节）。 l 继承
BaseModel，构建存储模型，默认无 id 属性。 l 继承
BaseRelation，构建多对多关系模型，默认无 id 属性。 l 继承
TransientModel，构建临时模型（传输模型），临时模型没有数据管理器，
也没有 id 属性。 l 继承 EnhanceModel，构建数据源为 ElasticSearch
的增强模型。 （二）快捷继承 l 继承 IdModel，构建主键为 id 的模型。继承
IdModel 的模型会数据管理器会增加 queryById 方法（根据 id
查询单条记录）。 85

Oinone7 天从入门到精通

杰

克

-O i

no ne

l 继承 CodeModel，构建带有唯一编码 code 的主键为 id 的模型。可以使用
@Model.Code 注解配置编码生成规则。也可以直接覆盖 CodeModel 的
generateCode 方 法或者自定义新增的前置扩展点自定义编码生成逻辑。继承
CodeModel 的模型会数据管 理器会增加 queryByCode
方法（根据唯一编码查询单条记录）。 l 继承
VersionModel，构建带有乐观锁，唯一编码 code 且主键为 id 的模型。 l 继承
IdRelation，构建主键为 id 的多对多关系模型。 （三）模型继承关系图

图 3-99 模型继承关系图

l AbstractModel 抽象基类是包含 createDate 创建时间、writeDate 更新时间、
createUid 创建用户 ID、writeUid 更新用户 ID、aggs 聚合结果和 activePks
批量主键 列表等基础字段的抽象模型。 l TransientModel
传输模型抽象基类是所有传输模型的基类，传输模型不存储，没 有数据管理器。
l TransientRelation
传输关系模型是所有传输关系模型的基类，传输关系模型不存
储，用于承载多对多关系，没有数据管理器。 l BaseModel
存储模型基类提供数据管理器功能，数据模型主键可以不是 ID。 l IdModel 带
id 模型抽象基类， 在 BaseModel 数据管理器基础之上提供根据 ID 查询、
更新、删除数据的功能。 l BaseRelation
关系模型抽象基类用于承载多对多关系，是多对多关系的中间模型，
数据模型主键可以不是 ID。

86

Oinone7 天从入门到精通 l IdRelation 带 id 关系模型抽象基类，在
BaseRelation 数据管理器基础之上提供 根据 ID 查询、更新、删除数据的功能。
l CodeModel 带 code 模型抽象基类，提供按配置生成业务唯一编码功能，根据
code 查询、更新、删除数据的功能。 l EnhanceModel
增强模型，提供全文检索能力。此模型会在【框架之搜索引擎】一 文中展开介绍

五、抽象模型（举例）

-O i

no ne

抽象模型本身不会直接用于构建协议和基础设施（如表结构等），而是通过继承的机制
供子模型复用其字段和函数。子模型可以是所有类型的模型。 比如 demo
模块要管理的一些公共模型字段，我们可以建一个 AbstractDemoIdModel 和
AbstractDemoCodeModel，demo 模块中的实体模型就可以继承它们。我们来为
demo 模块的
模型统一增加一个数据状态这么一个字段，用做数据的生效与失效管理。
（一）Step1 引入 DataStatusEnum 类 pamirs-demo-api 的 pom.xml
包增加依赖，便于引入 DataStatusEnum 类，当然也可以 自己建，这里只是
Oinone 提供了统一的数据记录状态的枚举，以及相应的通用方法，这边
就直接引入：

图 3-100 引入 DataStatusEnum 类

克

（二）Step2 修改 DemoModule

杰

DataStatusEnum
枚举类本身也会做为数据字典，以元数据的方式被管理起来，当一个
模块依赖另一个模块的元数据相关对象，则需要改模块的模块依赖定义。为
DemoModule 增 加 CommonModule 的依赖注解：

87

no ne

Oinone7 天从入门到精通

图 3-101 修改 DemoModule

（三）Step3 新建 AbstractDemoCodeModel 和 AbstractDemoIdModel

杰

克

-O i

并新增 AbstractDemoIdModel 和 AbstractDemoCodeModel 分别继承 IdModel 和
CodeModel，实现 IDataStatus 接口不是必须的，刚好 DataStatus
有配套的通用逻辑，暂时 也先加进去，具体使用会在【代理模型】这段介绍：

图 3-102 新建 AbstractDemoCodeModel

88

Oinone7 天从入门到精通

（四）Step4 修改 PetShop 的父类

no ne

图 3-103 新建 AbstractDemoIdModel

杰

克

-O i

修改 PetShop 父类从 IdMode 变更为 AbstractDemoIdModel

图 3-104 修改 PetShop 的父类

（五）Step5 重启看效果

宠物商店的列表页面和修改页面都增加数据状态字段，如下图 3-105 及 3-106
所示：

图 3-105 宠物商店列表页增加数据状态字段

89

Oinone7 天从入门到精通

图 3-106 宠物商店修改页增加数据状态字段

六、存储模型

no ne

存储模型用于定义数据表结构和数据的增删改查（数据管理器）功能，是直接与连接器
进行交互的数据容器。 PetShop 就是一个存储模型，这里就不过多举例子介绍了.

七、代理模型（举例）

克

-O i

代理模型是用于代理存储模型的数据管理器能力，同时又可以扩展出非存储数据信息的
交互功能的模型。 如果我们 PetShop 模型要展示创建人昵称？那么就可以建一个
PetShopProxy 类来完成，
代理模型增加的字段都是非存储字段，只用于交互包括展示或提交 （一）Step1
引入 PamirsUser 类 pamirs-demo-api 的 pom.xml 包增加依赖，便于引入
PamirsUser 类：

图 3-107 引入 PamirsUser 类

杰

（二）Step2 新建 PetShopProxy 模型

新建一个 PetShopProxy 类继承 PetShop，并声明类型为 PROXY。同时增加一个
creater 字段：

图 3-108 新建 PetShopProxy 模型 （三）Step3 修改 DemoModule 90

Oinone7 天从入门到精通

no ne

PamirsUser 模型隶属于 UserModule。为 DemoModule 增加 UserModule
的依赖注解，同 时修改 DemoModule 的 homepage 注解，默认进入 PetShopProxy
的管理页面：

-O i

图 3-109 修改 DemoModule

（四）Step4 新增 PetShopProxyAction 类

杰

克

为了展示效果覆盖 PetShopProxy 默认从 PetShop
继承的数据管理器方法，但对于 Action 和 Function
这些这里不展开介绍，具体会【Oinone 以函数为内在】和【Oinone 以
交互为外在】两章中介绍。 1. function 都挂在 PetShopProxy
这个模型载体上； 2. PetShopProxyAction 继承 DataStatusBehavior 类配套
dataStatus 使用，定义一个 【启用】serverAction，而启用逻辑则复用父类
DataStatusBehavior 的 dataStatusEnable 方法； 3.
覆盖【queryPage】Function，该方法名为前后约定协议中列表查询的默认方法。

91

-O i

no ne

Oinone7 天从入门到精通

图 3-110 新增 PetShopProxyAction 类 （五）Step5 重启看效果

杰

克

宠物商店的列表页面和修改页面都增加数据状态字段，如下图 3-111 所示：

图 3-111 宠物商店的列表页面和修改页面都已增加数据状态字段
多次点击启用会报对应的错误。当然如果场景不需要，则没有必要复用
DataStatusBehavior 逻辑，也就不需要实现 IDataStatus
接口了，启动按钮只在禁用状态 展示在后续的教程中会学到：

92

Oinone7 天从入门到精通

图 3-112 多次点击启用会报对应的错误

八、传输模型（举例）

杰

克

-O i

no ne

由于传输模型没有默认的数据管理器，只有数据构造器，所以在不自定义动作的情况下，
传输模型可以打开详情页、新增表单和修改表单和列表页，但是所有的动作全部为窗口动作。
传输模型本身不会存储，如果是关联关系字段关联传输模型，可以将传输模型序列化存储在
模型的关联关系字段上。因为没有数据管理器，所以传输模型的列表页没有分页能力。
场景举例：如果我们想批量修改 PetShop
的数据状态，那么我们需要在列表页选中数据
记录点击【批量修改】跳转到一个批量修改页面，选择要修改的数据状态，并点确认提交。
那么传输模型就可以承载批量修改页面、数据以及操作的载体模型。 （一）Step1
新建 PetShopBatchUpdate 模型 新建一个 PetShopBatchUpdate 类继承
TransientModel，同时增加 petShopList 和 dataStatus
字段用于接收页面传值。

图 3-113 新建 PetShopBatchUpdate 模型 （二）Step2 新增
PetShopBatchUpdateAction 类

传输模型没有默认的数据管理器，只有数据构造器（construct）。 1. 新建一个
PetShopBatchUpdateAction 类， Model.Model 设置为 PetShopBatchUpdate，
也就是把所有 Aciton 和 Function 都挂在 PetShopBatchUpdateAction
这个模型载体上； 2.
覆盖数据构造器（construct），接收从宠物商店列表多选带过来的数据参数，非
PetShopBatchUpdate 本模型参数不能放第一个，用 List<PetShopProxy>
petShopList 来接 收，进行数据组装逻辑处理，对应数据也是由
PetShopBatchUpdate 来承载返回给 PetShopBatchUpdate 的 Form 编辑页；

93

Oinone7 天从入门到精通

-O i

no ne

3.  定义一个【确定】serverAction，绑定 PetShopBatchUpdate 的 Form
    编辑页。点击 确定则批量修改 Form
    页面中的宠物商店列表为指定的数据状态。

图 3-114 新增 PetShopBatchUpdateAction 类 （三）Step3 初始化 ViewAction
窗口动作

杰

克

配置从宠物商店列表到 PetShopBatchUpdate 的窗口动作。 1. 新建
DemoModuleMetaDataEditor，MetaDataEditor 是 Oinone 在计算元数据时提供
给我们主动动态生成元数据的方式，它在自动扫描元数据注解之后进行。我们只要实现
MetaDataEditor
接口就可以做一些元数据初始化事情，常用场景就是初始化一些交互相关
的元数据如：窗口动作。更多有关模块生命周期扩展的详情参见【模块之生命周期】一节；
2.
通过指定工具（InitializationUtil），生成一个窗口动作：动作名为【批量更新
数据状态】，指定在宠物商店列表页，并且是单条或多条记录被选择中时出现。点击该窗口
动作跳转到 PetShopBatchUpdate 的默认 Form 页，跳转方式为 DIALOG 弹出框。

94

no ne

Oinone7 天从入门到精通

图 3-115 初始化 ViewAction 窗口动作 （四）Step4 重启看效果

杰

克

-O i

重启 demo
应用看效果，宠物商店的列表页面在选中记录时就多出了按钮【批量更新数
据状态】，点击进入批量修改数据状态页面： 1.
宠物商店的列表页面勾选数据记录出现批量更新数据状态,因为我们初始化的
ViewAction 的时候配置
ActionContextTypeEnum.SINGLE\_AND\_BATCH，详细见【ViewAction
的类型】一文：

图 3-116 批量更新数据状态 2.
点击批量更新数据状态，进入批量修改数据状态页面：

95

Oinone7 天从入门到精通

no ne

图 3-117 进入批量修改数据状态页面

克

-O i

3.  数据状态选择未启用

杰

图 3-118 数据状态选择未启用

4.  点击【添加】按钮，可以继续追加宠物商店记录

图 3-119 继续追加宠物商店记录

96

Oinone7 天从入门到精通 5.
在批量修改数据状态页面点击确认，回到宠物商店页面查看数据状态已经变更为未
启用：

no ne

图 3-120 宠物商店页面数据状态已变更为未启用 （五）Step5 注解式初始化
ViewAction 窗口动作

克

-O i

在 PetShopProxyAction 增加类注解,并注释掉 DemoModuleMetaDataEditor 的
viewActionInit 方法体代码。用 UxRouteButton 注解来申明一个 ViewAction。
1. @Model.Model(PetShopProxy.Model\_Model)，代表 UxRouteButton 申明
viewAction 所在模型； 2. @UxRoute.Model 代表 viewAction 的
resModel，路由的目标模型。

杰

图 3-121 在 PetShopProxyAction 增加类注解

图 3-122 注解式初始化 ViewAction 窗口动作
重启系统看到的效果跟前面是一致的，更多 Ux 系列注解见【Ux 注解详解】一文

n

3.2.3 模型的数据管理器

97

Oinone7 天从入门到精通 数据管理器和数据构造器是 Oinone 为模型自动赋予的
Function 是内在数据管理能力，
数据管理器针对存储模型是方便在大家编程模式下可以利用数据管理器 Function
快速达到
相关数据操作的目的。数据构造器则主要用于模型进行初始化时字段默认值计算和页面交互。

一、数据管理器 只有存储模型才有数据管理器。如果@Model.Advanced
注解设置了 dataManager 属性为 false，则表示在 UI
层不开放默认数据管理器。开放级别为 API 则表示 UI 层可以通过 HTTP
请求利用【Pamirs 标准网关协议】进行数据交互。

二、模型默认数据读管理器 描述

开放级别

queryByPk

根据主键查询单条记录，会进行主键值检查

Local、Remote

queryByEntity

根据实体查询单条记录

Local、Remote、Api

queryByWrapper

根据查询类查询单条记录

Local、Remote

queryListByEntity

根据实体查询返回记录列表

Local、Remote

queryListByWrapper

根据查询类查询记录列表

Local、Remote

根据实体分页查询返回记录列表

Local、Remote

根据查询类分页查询记录列表

Local、Remote

分页查询返回分页对象，分页对象中包含记录列表 Local、Remote、Api

杰

queryPage

克

queryListByPageAndWrapper

-O i

queryListByPage

no ne

函数编码

countByEntity

按实体条件获取记录数量

Local、Remote

countByWrapper

按查询类条件获取记录数量

Local、Remote

表 3-8 模型默认数据读管理器

三、模型默认数据写管理器 函数编码

描述

开放级别

createOne

提交新增单条记录

Local、Remote

新增或更新，需要为模型设置唯一索引，如果数据 createOrUpdate

库检测到索引冲突，会更新数据，若未冲突则新增

Local、Remote

数据

98

根据主键更新单条记录，会进行主键值检查

Local、Remote

updateByUniqueField

条件更新，条件中必须包含唯一索引字段

Local、Remote

updateByEntity

按实体条件更新记录

Local、Remote、Api

updateByWrapper

按查询类条件更新记录

Local、Remote

createBatch

批量新增记录

Local、Remote

createOrUpdateBatch

批量新增或更新记录

Local、Remote

updateBatch

根据主键批量更新记录，会进行主键值检查

Local、Remote

deleteByPk

根据主键删除单条记录，会进行主键值检查

Local、Remote

deleteByPks

根据主键批量删除，会进行主键值检查

Local、Remote

deleteByUniqueField

按条件删除记录，条件中必须包含唯一索引字段

Local、Remote

deleteByEntity

根据实体条件删除

Local、Remote、Api

根据查询类条件删除

Local、Remote

新增实体记录并更新实体字段记录

Local、Remote、Api

updateWithField

更新实体记录并更新实体字段记录

Local、Remote、Api

deleteWithFieldBatch

批量删除实体记录并删除关联关系

Local、Remote、Api

杰

createWithField

克

deleteByWrapper

-O i

updateByPk

no ne

Oinone7 天从入门到精通

表 3-9 模型默认数据写管理器 如果模型继承
IdModel，模型会自动设置主键设置为 id，则会继承 queryById、 updateById 和
deleteById 函数。 l queryById（详情，根据 ID 查询单条记录，开放级别为
Remote） l updateById（提交更新单条记录，根据 ID
更新单条记录，开放级别为 Remote） l deleteById（提交删除单条记录，根据
ID 删除单条记录，开放级别为 Remote） 如果模型继承
CodeModel，模型也会继承 IdModel 的数据管理器，编码字段 code 为唯
一索引字段。在新增数据时会根据编码生成规则自动设置编码字段 code
的值，继承 queryByCode、updateByCode 和 deleteByCode 函数。

99

Oinone7 天从入门到精通 l queryByCode（详情，根据 code
查询单条记录，开放级别为 Remote） l updateByCode（提交更新单条记录，根据
code 更新单条记录，开放级别为 Remote） l
deleteByCode（提交删除单条记录，根据 code 删除单条记录，开放级别为
Remote） 没有主键或唯一索引的模型，在 UI 层不会开放默认数据写管理器。

杰

克

-O i

no ne

四、使用场景

图 3-123 数据管理器使用场景

五、数据构造器 模型数据构造器
construct：供前端新开页面构造默认数据使用。所有模型都拥有 construct
构造器，默认会将字段上配置的默认值返回给前端，另外可以在子类中覆盖
construct 方法。数据构造器 construct 函数的开放级别为 API，函数类型为
QUERY 查询函 数，系统将识别模型中的以 construct 命名的函数强制设置为 API
开放级别和 QUERY 查询类 型。 可以使用@Field 的 defaultValue
属性配置字段的默认值。注意，枚举的默认值为枚举 的 name。

n

3.2.4 模型的继承 100

Oinone7 天从入门到精通
在我们的很多项目中，客户都是有个性化需求的，就像我们不能找到两件一模一样的东
西，何况是企业的经营与管理思路，多少都会有差异。常规的方式只能去修改标准产品的逻
辑来适配客户的需求。导致后续标品维护非常困难。而在介绍完这节以后是不是让你更加清
晰认知到我们所说的【Oinone
独特性之每一个需求都可以是一个模块】带来的好处呢？

一、继承方式

二、继承约束 1.

通用约束

-O i

no ne

继承方式可以分为五种： l 抽象基类
ABSTRACT，只保存不希望为每个子模型重复键入的信息的模型，抽象基
类模型不生成数据表存储数据，只供其他模型继承模型可继承域使用，抽象基类可
以继承抽象基类。 l 扩展继承
EXTENDS，子模型与父模型的数据表相同，子模型继承父模型的字段与函
数。存储模型之间的继承默认为扩展继承。 l 多表继承
MULTI\_TABLE，父模型不变，子模型获得父模型的可继承域生成新的模型；
父子模型不同表，子模型会建立与父模型的一对一关联关系字段（而不是交叉表），
使用主键关联，同时子模型会通过一对一关联关系引用父模型的所有字段。多表继
承 父 模 型 需 要 使 用 @Model.MultiTable 来 标 识 ， 子 模 型 需 要 使
用 @Model.MultiTableInherited 来标识。 l 代理继承
PROXY，为原始模型创建代理，可以增删改查代理模型的实体数据，就像
使用原始（非代理）模型一样。不同之处在于代理继承并不关注更改字段，可以更
改代理中的元信息、函数和动作，而无需更改原始内容。一个代理模型必须仅能继
承一个非抽象模型类。一个代理模型可以继承任意数量的没有定义任何模型字段的
抽象模型类。一个代理模型也可以继承任意数量继承相同父类的代理模型。 l
临时继承 TRANSIENT，将父模型作为传输模型使用，并可以添加传输字段。

杰

克

对于扩展继承，查询的时候，父模型只能查询到父模型字段的数据，子模型可以查询出
父模型及子模型的字段数据（因为派生关系所以子模型复刻了一份父模型的字段到子模型
中）。
系统不会为抽象基类创建实际的数据库表，它们也没有默认的数据管理器，不能被实例
化也无法直接保存，它们就是用来被继承的。抽象基类完全就是用来保存子模型们共有的内
容部分，达到重用的目的。当它们被继承时，它们的字段会全部复制到子模型中。
系统不支持非 jar 包依赖模型的继承。
多表继承具有阻断效应，子模型无法继承多表继承父模型的存储父模型的字段，需要使
用@Model.Advanced 注解的 inherited
属性显示声明继承父模型的父模型。但是可以继承多
表继承父模型的抽象父模型的字段。 可以使用@Model.Advanced 的
unInheritedFields 和 unInheritedFunctions 属性设置
不从父类继承的字段和函数。 2. 跨模块继承约束
如果模型间的继承是跨模块继承，应该与模型所属模块建立依赖关系；如果模块间有互
斥关系，则不允许建立模块依赖关系，同理模型间也不允许存在继承关系。
跨模块代理继承，对代理模型的非 inJvm
函数调用将使用远程调用方式；跨模块扩展（同
表）继承将使用本地调用方式，如果是数据管理器函数，将直连数据源。 3.
模型类型与继承约束 l 抽象模型可继承：抽象模型（Abstract）； l
临时模型可继承：抽象模型（Abstract）、传输模型（Transient）； 101

Oinone7 天从入门到精通

no ne

l
存储模型可继承：抽象模型（Abstract）、存储模型（Store）、存储模型（多表，
Multi-table Store），不可继承多个 Store 或 Multi-table Store； l
多表存储模型（父）可继承：同扩展继承； l 多表存储模型 （子） 在继承单个
Multi-table Store 后可继承： 抽象模型 （Abstract） 、
存储模型（Store），不可继承多个 Store； l 代理模型可继承： •
抽象模型（Abstract），须搭配继承 Store、Multi-table Store 或 Proxy； •
存储模型（Store），不可继承多个 Store 或 Multi-table Store； •
存储模型（多表，Multi-table Store），不可继承多个 Store 或 Multi-table
Store； • 代理模型（Proxy），可继承多个 Proxy，但多个父 Proxy
须继承自同一个 Store； 或 Multi-table Store，且不能再继承其他 Store 或
Multi-table Store。
同名字段以模型自身字段为有效配置，若模型自身不存在该字段，继承字段以第一个加
载的字段为有效配置，所以在多重继承的情况下，未避免继承同名父模型字段的不确定性，
在自身模型配置同名字段来确定生效配置。

三、继承的使用场景

杰

克

-O i

模型的继承可以继承父模型的元信息、字段、数据管理器和函数： l
抽象基类：解决公用字段问题； l
扩展继承：解决开放封闭原则、跨模块扩展等问题； l
多表继承：解决多型派生类字段差异问题和前端多存储模型组合外观问题； l
代理继承：解决同一模型在不同场景下的多态问题（一表多态）； l
临时继承：解决使用现有模型进行数据传输问题。
举例，前端多存储模型组合外观问题可通过多表继承的子模型再一对一关联到关联模型，
同时使用排除继承字段去掉不需要继承的字段。子模型通过默认模型管理器提供查询功能给
前端，默认查询会查询子模型数据列表并在列表行内根据一对一关系查出关联模型数据合并，
关联模型数据展现形态在行内是平铺还是折叠，在详情是分组还是选项卡可以自定义
view 进行配置。
扩展继承父子同表，模型在所有场景都有一致化的表现，意味着原模型被扩展成了新模
型，父子模型的表名一致，模型编码不同，可覆盖父模型的模型管理器、数据排序规则、函
数。
多表继承父子多表，父子间有隐式一对一关系，即父子模型都增加了一对一关联关系字
段，同时父模型的字段被引用到子模型，且引用字段为只读字段，意味着子模型不可以直接
更改父模型的字段值，子模型不继承父模型的模型管理器、数据排序规则、函数，子模型拥
有自己的默认模型管理器、数据排序规则、函数。多表继承具有阻断效应，子模型无法自动
多表继承父模型的存储父模型，需要显式声明多表继承父模型的存储父模型。
代理继承，代理模型继承并可覆盖父模型的模型管理器、数据排序规则、函数，同时可
以使用排除继承字段和函数来达到不同场景不同视觉交互的效果。

102

杰

克

-O i

no ne

Oinone7 天从入门到精通

图 3-124 继承的使用场景

四、抽象基类（举例）

参考前文中【抽象模型】的介绍

五、多表继承（举例） 场景设计如下（图 3-125 所示）：

103

no ne

Oinone7 天从入门到精通

图 3-125 多表继承设计场景

杰

克

-O i

（一）Step1 新建宠物品种、宠狗品种和萌猫品种模 1.
新建宠物品种模型，用@Model.MultiTable(typeField =
"kind")，申明为可多表继 承父类，typeField 指定为 kind 字段：

图 3-126 @Model.MultiTable(typeField = "kind")

2.  新建宠狗品种模型，用@Model.MultiTableInherited(type =
    PetDogType.KIND\_DOG)， 申明以多表继承模式继承 PetType，覆盖 kind
    字段(用 defaultValue 设置默认值，用 invisible = true
    设置为前端不展示)，更多模块元数据以及模型字段元数据配置请见【模
    型之元数据详解】一节：

104

Oinone7 天从入门到精通

图 3-127 @Model.MultiTableInherited(type = PetDogType.KIND\_DOG)

-O i

no ne

3.  新建萌猫品种模型，用@Model.MultiTableInherited(type =
    PetCatType.KIND\_CAT)， 申明以多表继承模式继承 PetType，覆盖 kind
    字段(用 defaultValue 设置默认值，用 invisible = true
    设置为前端不展示)，并新增一个 CatShapeEnum 枚举类型的字段 shape：

杰

克

图 3-128 @Model.MultiTableInherited(type = PetCatType.KIND\_CAT)

图 3-129 新增 CatShapeEnum 枚举类型的字段 shape

（二）Step2 配置菜单后，重启查看效果

1.  为了更好帮助大家更好地理解，这里先把对应的菜单配置上，从页面来看看效果。
    下面以注解方式进行菜单配置，更多详情请见【构建第一个 Menu】一节：
    105

Oinone7 天从入门到精通

图 3-130 对应菜单配置

no ne

2.  在宠狗品种中新增、修改、列表都隐藏了品种类型字段，并附上了默认值
    DOG：

克

-O i

图 3-131 宠狗品种新增页

杰

图 3-132 宠狗品种列表页

图 3-133 宠狗品种数据表 3.
在萌猫品种中新增、修改、列表都增加宠物体型枚举字段，并且隐藏了品种类型字
段，并附上了默认值 CAT：

图 3-134 萌猫品种新增页 106

Oinone7 天从入门到精通

no ne

图 3-135 萌猫品种列表页

图 3-136 萌猫品种数据表

（三）Step3 为宠狗和萌猫品种模型实现默认读写扩展点，保证父子表数据同步

杰

克

-O i

多表继承默认父子表是不同步的，不过 Oinone
为每一个模型的【默认数据管理器】都
提供的默认读写扩展点，我们可以主动利用这个特性来进行手动同步，更多扩展点知识请见
Oinone
以函数为内在一章中函数相关特性部分的【扩展点】一节，会介绍除了利用系统默
认提供的扩展点，还有如何自定义扩展。 1. PetCatType 和 PetDogType
都需要实现扩展点来完成与父模型的同步，所以这里把相 同逻辑做了提取
AbstractPetTypeExtPoint：

107

-O i

no ne

Oinone7 天从入门到精通

克

图 3-137 相同逻辑提取 AbstractPetTypeExtPoint

杰

2.  PetCatTypeExtPoint 继承
    AbstractPetTypeExtPoint<PetCatType>类，并通过
    @Ext(PetCatType.class)申明扩展点所扩展函数所在类为 PetCatType，并
    @ExtPoint.Implement 申明对应扩展点的实现方法实例：

108

-O i

no ne

Oinone7 天从入门到精通

图 3-138 PetCatTypeExtPoint 继承 AbstractPetTypeExtPoint<PetCatType>类

杰

克

3.  PetDogTypeExtPoint 继承
    AbstractPetTypeExtPoint<PetDogType>类，并通过
    @Ext(PetDogType.class)申明扩展点所扩展函数所在类为 PetDogType，并
    @ExtPoint.Implement 申明对应扩展点的实现方法实例：

109

-O i

no ne

Oinone7 天从入门到精通

图 3-139 PetDogTypeExtPoint 继承 AbstractPetTypeExtPoint<PetDogType>类

克

（四）Step4
重启查看效果：在萌猫品种和宠狗品种下新增、修改、删除，则会在宠物品

杰

种下看到对应记录变化

图 3-140 父模型宠物品种列表页

图 3-141 父模型宠物品种数据表

110

Oinone7 天从入门到精通 六、扩展继承（举例）

no ne

场景设计如下（图 3-142 所示）：

图 3-142 扩展继承场景设计

-O i

（一）Step1 新建宠物商品、宠狗商品和萌猫商品模型，并配置菜单

杰

克

1.  新建宠物商品模型为普通存储模型，用扩展继承父类设置公共字段如：店铺，品种
    等，注意 type 字段类型为 PetType：

图 3-143 新建宠物商品模型为普通存储模型 2.
新建宠狗商品模型继承宠物商品模型，注意这里把 type 字段类型覆盖为 PetType
的 子类 PetDogType，并新增原产地字段 provenance；

111

Oinone7 天从入门到精通

图 3-144 新建宠狗商品模型继承宠物商品模型

-O i

no ne

3.  新建萌猫商品模型继承宠物商品模型，注意这里把 type 字段类型覆盖为
    PetType 的 子类 PetCatType；

克

图 3-145 新建萌猫商品模型继承宠物商品模型

杰

4.  为了更好帮助大家更好地理解，这里先把对应的菜单配置上，从页面来看看效果。
    下面以注解方式进行菜单配置，更多详情请见【构建第一个 Menu】一节。

图 3-146 以注解方式进行菜单配置 至此模型就建完了，还是很简单的吧。
（二）Step2 分别新建三条宠物商品、宠狗商品和萌猫商品记录，查看效果

1.  父模型宠物商品的商品管理可以看到品类中可选柴犬、加菲猫，数据来源是品种的
    父模型 PetType，店铺下拉框展示为"-"，因为店铺模型没有配置 label
    字段，可以在店铺

112

Oinone7 天从入门到精通 模型的注解上增加“@Model(displayName =
"宠物店铺",summary="宠物店铺",labelFields =
{"shopName"})”，即可解决。这里先选择第一个往下执行：

no ne

图 3-147 宠物商品管理

克

-O i

2.  父模型宠狗商品的商品管理可以看到品类中可选柴犬，数据来源是品种的子模型
    PetDogType，而且心增源产地字段；

杰

图 3-148 父模型宠狗商品管理

3.  父模型萌猫商品的商品管理可以看到品类中可选加菲猫，数据来源是品种的子模型
    PetCatType；

图 3-149 父模型萌猫商品管理 （三）Step3
分别观察宠物商品、宠狗商品和萌猫商品的列表页，我们会发现数据记录都
是三条，但是展示字段会随着模型不同而有差异

113

Oinone7 天从入门到精通 1. 父页面在品种一列中可以显示所有品种名称：

图 3-150 父页面在品种一列中可以显示所有品种名称

-O i

no ne

2.  宠狗页面在品种一列中只能显示 PetDogType
    的品种名称、但多了原产地字段：

克

图 3-151 宠狗页面品种列展示

杰

3.  萌猫页面在品种一列中只能显示 PetCatType 的品种名称：

图 3-152 萌猫页面品种列中只展示 PetCatType 的品种名称 4.
对应的数据库表：数据都在一张记录表中，新增了原产地字段

114

Oinone7 天从入门到精通

图 3-153 对应数据库表 （四）Step4 顺带优化下宠物店铺的展示 Labels

克

-O i

no ne

1.  给 PetShop 增加@Model(labelFields ={"shopName"} )注解，labelFields
    是为模型 的“数据标题, 用于前端展示”，其默认值为 name，但 PetShop
    没有 name 字段，所以我们
    列表上展示不出来。更多元数据见【模型之元数据详解】一节；

图 3-154 给 PetShop 增加@Model(labelFields ={"shopName"} )注解

杰

2.  重启查看效果，店铺字段可以展示出来：

图 3-155 店铺字段可展示 （五）Step5 思考在扩展继承模式下数据隔离问题

多表继承需要自己搞定父、子模型的数据同步问题，同表继承则需要自己搞定数据隔离
问题。我们可以重写 queryPage 这个
Function，如我们在模型类型一节中介绍【代理模型 115

Oinone7 天从入门到精通

克

-O i

no ne

类型】时的 PetShopProxyAction 就覆盖了 queryPage。这里举例 PetCatItem 的
queryPage 覆盖，PetDogItem 留给大家自行练习。 1. 给 PetItem 显示增加一个
typeId 字段，方便在 PetCatItemAction 中用于过滤条件
使用。为什么说显示增加呢？因为 type 字段是一个 many2one 的字段在没有配置
@Field.Relation 的情况下，Oinone 会为 PetItem 模型自动推断出一个 typeId
字段去关联 PetType 模型的 Id。@Field.Relation 的 relationFields
为本模型的关联字段， referenceFields
为目标模型关联字段。如符合推断规范可以不配置@Field.Relation，就
如这个场景配不配效果是一样的。还是那句话“更多元数据见【模型之元数据详解】一节”；

杰

图 3-156 给 PetItem 显示增加一个 typeId 字段

2.  覆盖 PetCatItem 的 Function【queryPage】，增加 typeId 的过滤条件为
    PetCatType 表对应的 Id 列表：

116

-O i

no ne

Oinone7 天从入门到精通

克

图 3-157 覆盖 PetCatItem 的 Function【queryPage】

杰

3.  重启查看效果，萌猫商品只能看到 PetCatType
    对应的数据记录了，赶紧自己动手试 试 PetDogItem 的改造吧；

图 3-158 重启查看效果

七、代理继承（举例）
【代理模型】我们在模型的类型一文中有介绍过，代理模型看名字就知道其本身是通过
继承方式代理另一个存储模型，这里不过多介绍。我们来尝试一下它继承的特殊性“一个代
理模型也可以继承任意数量继承相同父类的代理模型”。 场景设计如下（图 3-159
所示）：

117

no ne

Oinone7 天从入门到精通

-O i

图 3-159 代理继承设计场景

杰

克

（一）Step1 新建宠物店铺代理模型 A 和宠物店铺代理模型 B，同时修改
PetItem 1. 新建宠物店铺代理模型 A 申明为代理模型，新增一个 one2many 字段
items，用 @Field.Relation 申明关联字段；

图 3-160 新建宠物店铺代理模型 A 申明为代理模型 2. 新建宠物店铺代理模型 B
申明为代理模型，用 @Model.Advanced(inherited
={PetShopProxy.Model\_Model,PetShopProxyA.Model\_Model})声明继承多个同源代理模型,
并且新增一个 one2many 字段 catItems 用@Field.Relation 申明关联字段；

118

Oinone7 天从入门到精通

图 3-161 新建宠物店铺代理模型 B 申明为代理模型

杰

克

-O i

no ne

3.  修改 PetItem 增加一个 labelFields={"itemName"}注解，给 PetItem
    显示增加一个 shopId 字段方便，在 Service 中用于过滤条件使用：

图 3-162 修改 PetItem 增加一个 labelFields={"itemName"}注解

（二）Step2 覆盖 PetShopProxyB 的 Function「queryPage」和「queryOne」

PetShopProxyB 的 queryPage 和 queryOne 都查
catItems\creater\items 三个字段。

119

杰

克

-O i

no ne

Oinone7 天从入门到精通

图 3-163 覆盖 PetShopProxyB 的 Function「queryPage」和「queryOne」
（三）Step3 配置菜单，并重启看效果

1.  配置菜单：请参考本节前面介绍自行增加三个菜单商店管理、商店管理
    A、商店管理 B 分别对应宠物店铺代理模型、宠物店铺代理模型
    A、宠物店铺代理模型 B 的管理入口；
2.  宠物店铺代理模型覆盖了 queryPage 方法但没有覆盖 queryOne
    方法，所以列表页有
    显示新增字段创建者，但详情页没有。具体参见模型类型一节中的【代理模型】介绍部分；

120

Oinone7 天从入门到精通

no ne

图 3-164【宠物店铺代理模型】列表页

-O i

图 3-165【宠物店铺代理模型】详情页

杰

克

3.  宠物店铺代理模型 A 只增加了一个商品列表字段，没有覆盖对应 query
    相关方法， 所以列表页有这个字段但没有值；

图 3-166 宠物店铺代理模型 A 列表页 4. 宠物店铺代理模型 B
因为同源多表继承了宠物店铺代理模型和宠物店铺代理模型 A
所以它拥有商品列表、 萌猫商品列表、 创建者三个字段， 并且同时覆盖
queryPage 和 queryOne 对的 Function，所以列表和详情都有值。

121

Oinone7 天从入门到精通

克

-O i

no ne

图 3-167 宠物店铺代理模型 B 列表页

图 3-168 宠物店铺代理模型 B 详情页

杰

（四）Step4 思考 PetShopProxyB 中的 PetCatItem
数据没有过滤？是不是前面说到的扩展 继承 PetCatItem 过滤是一回事。

提取 PetCatItem 的过滤逻辑维护到独立的 Service 中去，并把 Service
的方法注解为 Function，Function 的 namespace
有非常重要的意思，如跟模型的编码一致则代表挂载在
模型上。当前例子是独立存在，于用提供内部服务。Function
的更多介绍请参见【构建第 一个 Function】； 1. 新建
PetCatItemQueryService 接口类，申明三个方便并加上@Fun 注解，并在接口方
法上增加@Function
注解，这样依赖了接口但没有依赖实现类的工程可以自动识别走远程调 用：

122

Oinone7 天从入门到精通

图 3-169 新建 PetCatItemQueryService 接口类

杰

克

-O i

no ne

2.  新建 PetCatItemQueryServiceImpl 实现 PetCatItemQueryService
    接口，加上@Fun 注解，并在方法上加@Function 注解，默认开放级别是
    Remote：

123

-O i

no ne

Oinone7 天从入门到精通

图 3-170 新建 PetCatItemQueryServiceImpl 实现 PetCatItemQueryService
接口

杰

克

3.  修改 PetShopProxyBAction 和 PetCatItemAction 的相关代码，把填充
    PetCatItem 的逻辑做替换;

124

no ne

Oinone7 天从入门到精通

杰

克

-O i

图 3-171 修改 PetShopProxyBAction 相关代码

125

杰

克

-O i

no ne

Oinone7 天从入门到精通

图 3-172 修改 PetCatItemAction 的相关代码

4.  重启看效果，我们发现商店管理 B
    下面的列表页和详解页的萌猫商品列表已经过滤 了相关数据：

126

Oinone7 天从入门到精通

克

-O i

no ne

图 3-173 商店管理 B 列表页萌猫商品列表已过滤相关数据

杰

图 3-174 商店管理 B 详解页萌猫商品列表已过滤相关数据

八、临时继承（举例）

参考前文中【传输模型】的介绍，差别在于一个继承抽象基类，一个继承其他模型类型，
不管什么类型都只是复用父类的字段，自己还是传输模型.

九、总结
在我们的很多项目中，客户都是有个性化需求的，就像我们不能找到两件一模一样的东
西，何况是企业的经营与管理思路，多少都会有差异。常规的方式只能去修改标准产品的逻
辑来适配客户的需求。导致后续标品维护非常困难。而在介绍完这节以后是不是让你更加清
晰认知到我们所说的【Oinone
独特性之每一个需求都可以是一个模块】带来的好处呢？

n 3.2.5 模型编码生成器
在我们日常开发中经常要一些单据生成指定格式的编码，而且现在分布式环境下要考虑
的事情会特别多。Oinone 提供了简易的编码生成能力。

127

Oinone7 天从入门到精通 一、编码生成器

克

-O i

no ne

可以在模型或者字段上配置编码自动生成规则。在进行数据存储时，如果配置了编码自
动生成规则的字段值为空，则系统将根据规则自动生成编码。编码自动生成功能是通过序列
生成器来支持的。可以在序列生成器生成的序列编码基础上再进行组合配置的功能编码生成
最终的编码。序列生成器可以配置初始序列，步长，日期格式，长度。
（一）模型序列生成器（举例） 模型编码生成器，继承 CodeModel，并使用
Model.Code 注解即可。 ① Step1 为 PetShop 增加一个@Model.Code
注解，并增加一个店铺编码(Code)字段

②

杰

图 3-175 为 PetShop 增加一个@Model.Code 注解

Step2 重启查看效果

1.  进入店铺新增页面新增一个 Oinone 宠物店铺 003；

图 3-176 进入店铺新增页面新增一个 Oinone 宠物店铺 003 2.
查看店铺列表页面，新增的记录中店铺编码一列，已经按 Model.Code
注解要求生成 了：

128

Oinone7 天从入门到精通

图 3-177 店铺列表页面已按 Model.Code 注解要求生成 ③

Step3 小结

no ne

在我们日常开发中经常要一些单据生成指定格式的编码，而且现在分布式环境下要考虑
的事情会特别多。Oinone
提供了简易的编码生成能力，大家可以根据编码注解说明，自行 对 PetShop
模型进行不同配置，来学习编码生成器的知识。

杰

克

-O i

（二）字段序列生成器 字段编码生成器，在对应的字段上增加，并使用
Field.Sequence 注解即可。 ① Step1 为 PetShop 增加一个字段 codeTwo
并增加@Field.Sequence 注解；

图 3-178 为 PetShop 增加一个字段 codeTwo ②

Step2 重启查看效果

1.  进入店铺新增页面新增一个 Oinone 宠物店铺 004； 129

Oinone7 天从入门到精通

图 3-179 新增 Oinone 宠物店铺 004

-O i

no ne

2.  查看店铺列表页面，新增的记录中店铺编码 2 一列，已经按 Field.Sequence
    注解要 求生成了；

克

图 3-180 店铺列表页已按 Field.Sequence 注解生成

二、编码注解说明，模型更多其他注解请见【模型元数据】 1. 2.

3.  4.  5.  6.  7.  8.  9.  

杰

（一）模型编码注解说明

模型编码生成器规定仅针对 code 属性生效
Model.Code\#sequence：序列生成函数 l SEQ——自增流水号（不连续） l
ORDERLY\_SEQ——自增强有序流水号（连续） l
DATE\_SEQ——日期+自增流水号（不连续） l
DATE\_ORDERLY\_SEQ——日期+强有序流水号（连续） l DATE——日期 l UUID——随机
32 位字符串，包含数字和小写英文字母 Model.Code\#prefix：前缀
Model.Code\#suffix：后缀 Model.Code\#size：长度
Model.Code\#step：步长（包含流水号有效）
Model.Code\#initial：起始值（包含流水号有效）
Model.Code\#format：格式化（包含日期有效） Model.Code\#separator：分隔符
130

Oinone7 天从入门到精通 （二）字段编码注解说明

3.  4.  5.  6.  7.  8.  9.  

字段编码生成器规定在字段上增加 Field.Sequence 注解即可
Field.Sequence\#sequence：序列生成函数 l SEQ——自增流水号（不连续） l
ORDERLY——自增强有序流水号（连续） l DATE\_SEQ——日期+自增流水号（不连续）
l DATE\_ORDERLY\_SEQ——日期+强有序流水号（连续） l DATE——日期 l
UUID——随机 32 位字符串，包含数字和小写英文字母
Field.Sequence\#prefix：前缀 Field.Sequence\#suffix：后缀
Field.Sequence\#size：长度 Field.Sequence\#step：步长（包含流水号有效）
Field.Sequence\#initial：起始值（包含流水号有效）
Field.Sequence\#format：格式化（包含日期有效）
Field.Sequence\#separator：分隔符

n 3.2.6 枚举与数据字典

no ne

1.  2.  

-O i

枚举是大家在系统开发中经常用的一种类型，在 Oinone
中也对枚举类型进行了支持，
同时也做了相应的加强。希望通过本文能让大家对枚举的使用，有更全面的认知。

一、枚举系统与数据字典

杰

克

枚举是列举出一个有穷序列集的所有成员的程序。在元数据中，我们使用数据字典进行
描述。 （一）协议约定 枚举需要实现 IEnum 接口和使用@Dict
注解进行配置，通过配置@Dict 注解的 dictionary
属性来设置数据字典的唯一编码。前端使用枚举的 displayName 来展示，枚举 的
name 来进行交互；后端使用枚举的 value
来进行交互（包括默认值设置也使用枚举的 value）。
枚举会存储在元数据的数据字典表中。枚举分为两类：1.异常类；2.业务类。异常类枚
举用于定义程序中的错误提示，业务类枚举用于定义业务中某个字段值的有穷有序集。
（二）编程式用法

131

-O i

no ne

Oinone7 天从入门到精通

克

图 3-181 编程式用法

杰

如果一个字段的类型被定义为枚举，则该字段就可以使用该枚举来进行可选项约束
（options）。该字段的可选项为枚举所对应数据字典的子集。 （三）可继承枚举
继承 BaseEnum 可以实现 java
不支持的继承枚举。同时可继承枚举也可以用编程式动态 创建枚举项。
可继承枚举也可以兼容无代码枚举。

图 3-182 可继承枚举 （四）二进制枚举

132

Oinone7 天从入门到精通 可以通过@Dict 注解设置数据字典的 bit
属性或者实现 BitEnum 接口来标识该枚举值为 2 的次幂。

二、enum 不可继承枚举（举例）

杰

克

-O i

no ne

我们在介绍【抽象基类】中 AbstractDemoCodeModel 和 AbstractDemoIdModel
就引入了 数据状态(DataStatusEnum)字段，并设置了必填和默认值为
DISABLED。DataStatusEnum 实 现了 IEnum<String>接口,并用@Dict(dictionary
= DataStatusEnum.dictionary, displayName =
"数据状态")进行了注解。为什么不能继承呢？因为 JAVA 语言的限制导致 enum
是不可继承的。

图 3-183 不可继承枚举

三、BaseEnum 可继承枚举（举例） （一）Step1 新增 CatShapeExEnum 继承
CatShapeEnum 枚举；

133

Oinone7 天从入门到精通

图 3-184 新增 CatShapeExEnum 继承 CatShapeEnum 枚举

克

-O i

no ne

（二）Step2 修改 PetCatType 的 shape 字段类型为 CatShapeExEnum；

杰

图 3-185 修改 PetCatType 的 shape 字段类型为 CatShapeExEnum （三）Step3
重启系统，查看效果

图 3-186 重启系统查看效果 （四）另：可继承枚举的 Switch API

继承 BaseEnum 可以实现 Java 不支持的可变枚举，可变枚举可以在运行时增加非
Java 代码定义的枚举项，同时可变枚举支持枚举继承。由于可变枚举不是 Java
规范中的枚举，

134

Oinone7 天从入门到精通 所以无法使用 switch...case...语句，但是 K2
提供稍作变化的 switches（无需返回值）与
switchGet（需要返回值）方式实现相同功能与逻辑。

no ne

图 3-187 枚举的 switches 用法

-O i

图 3-187 枚举的 switchGet 用法

杰

克

caseName()使用枚举项的 name
与比较变量进行匹配比较；caseValue()使用枚举项的 value
值与比较变量进行匹配比较。 例如以下逻辑表示当 ttype 的值为 O2O、O2M、M2O
或 M2M 枚举值时返回 true，否则返 回 false。

图 3-189 枚举的 switchGet 用法举例

四、二进制枚举（举例） 可以通过@Dict 注解设置数据字典的 bit 属性或者实现
BitEnum 接口来标识该枚举值为 2
的次幂。二进制枚举最大的区别在于值的序列化和反序列化方式是不一样的。更多有关序
列化知识请见【模型编码生成器】一节。 （一）Step1
新建店铺选项枚举、并添加为 PetShop 的一个字段 1. PetShopOptionEnum 继承
BaseEnum<PetShopOptionEnum,Long>并实现 BitEnum 接口，
增加三个枚举，值分别是 2 的 0 次幂，2 的 1 次幂，2 的 2 次幂。多选枚举 3
位枚举都选中， 字段值为 7；

135

no ne

Oinone7 天从入门到精通

图 3-190 新建店铺选项枚举

杰

克

-O i

2.  修改 PetShop，增加一个多选枚举字段 options，枚举类型为
    PetShopOptionEnum。

图 3-191 修改 PetShop 增加一个多选枚举字段 options （二）Step2
重启查看效果

136

Oinone7 天从入门到精通

no ne

1.  模型宠狗商店的编辑页面可以看到店铺标志字段可多选十年老店、七天无理由退货、
    正品认证；

图 3-192 模型宠狗商店编辑页

杰

克

-O i

2.  模型宠狗商店的列表页面可以看到店铺标志字段为十年老店、七天无理由退货、正
    品认证；

图 3-193 模型宠狗商店列表页

3.  查看数据库对应的 options 字段值为 7。

图 3-194 查看数据库对应的 options 字段值为 7

五、异常枚举（举例） 作为 Oinone 管理异常的规范，一般枚举都是用@Dict
申明为数据字典，但是异常枚举 会用@Error
来注解，因为异常跟业务枚举有很大区别，异常往往数量非常多，如果用@Dict
数据字典方式来管理，那么数据字典的量会非常大。

137

Oinone7 天从入门到精通 （一）Step1 新建一个异常枚举类
DemoExpEnumerate，实现 ExpBaseEnum 接口并加上

no ne

@Errors(displayName = "demo 模块错误枚举")注解，增加对应错误枚举；

图 3-195 新建一个异常枚举类 DemoExpEnumerate （二）Step2
修改宠物商店批量更新数据状态逻辑

杰

克

-O i

增加一个 PetShopList 必选判断，如果没选则抛出异常并制定异常枚举为
PET\_SHOP\_BATCH\_UPDATE\_SHOPLIST\_IS\_NULL：

138

Oinone7 天从入门到精通 图 3-196 增加一个 PetShopList 必选判断

no ne

（三）Step3 重启系统看效果

图 3-197 重启系统看效果 （四）平台的异常枚举如下： 1. pamirs-framework
异常枚举

定义位置

编码起始值

MetaExpEnumerate

10010000

pamirs-meta-dsl

DslExpEnumerate

10020000

pamirs-framework-common

FwExpEnumerate

10050000

pamirs-framework-configure-annotation

AnnotationExpEnumerate

10060000

pamirs-framework-configure-db

MetadExpEnumerate

10070000

pamirs-framework-compute

ComputeExpEnumerate

10080000

pamirs-framework-compare

CompareExpEnumerate

10090000

pamirs-framework-faas

FaasExpEnumerate

10100000

克

工程名

-O i

每一个模块都可以包含一个或多个异常枚举类，枚举项定义了应用中异常的错误编码与
描述。在应用需要抛出异常的位置附带对应的错误枚举抛出异常。我们使用@Errors
注解来 定义错误枚举类。

杰

pamirs-meta-Model

139

pamirs-framework-orm

OrmExpEnumerate

10110000

pamirs-connectors-data

DataExpEnumerate

10150000

pamirs-connectors-data-dialect

DialectExpEnumerate

10160000

pamirs-connectors-data-sql

SqlExpEnumerate

10170000

pamirs-connectors-data-ddl

DdlExpEnumerate

10180000

pamirs-connectors-data-infrastructure

InfExpEnumerate

10190000

no ne

Oinone7 天从入门到精通

TxExpEnumerate

10200000

RsqlExpEnumerate

10500000

GqlExpEnumerate

10510000

pamirs-boot-api

BootExpEnumerate

11000000

pamirs-boot-uxd

BootUxdExpEnumerate

11040000

pamirs-boot-standard

BootStandardExpEnumerate

11050000

pamirs-base-api

BaseExpEnumerate

11500000

pamirs-sid

SidExpEnumerate

11510000

pamirs-connectors-data-tx

pamirs-gateways-rsql

杰

克

-O i

pamirs-gateways-graph-java

表 3-10 pamirs-framework 异常枚举 2. 通用异常码 错误

错误描述

定义位置

编码

BASE\_USER\_NOT\_LOGIN\_ERROR

用户未登录

BaseExpEnumerate

11500001

BASE\_CHECK\_DATA\_ERROR

校验失败，数据错误

FwExpEnumerate

10050009

表 3-11 通用异常码 3. pamirs-core 异常枚举(20010000-20290000) 140

Oinone7 天从入门到精通 编码起始值

数据字典名

pamirs-core-common

20010000

error.core.common.exceptions

pamirs-sequence（原 pamirs-bid）

20020000

error.core.sequence.exceptions

pamirs-data-audit

20030000

error.core.data.audit.exceptions

pamirs-channel

20040000

error.core.channel.exceptions

pamirs-resource

20050000

error.core.resource.exceptions

pamirs-user

20060000

error.core.user.exceptions

pamirs-auth

20070000

error.core.auth.exceptions

pamirs-message

20080000

error.core.message.exceptions

pamirs-translate

20090000

20100000

克

pamirs-scheduler（已作废）

-O i

pamirs-international

no ne

工程名

pamirs-data-audit

20110000

error.core.international.exceptions（未正确定 义）

error.core.translate.exceptions（未正确定义）
error.core.schedule.exceptions（已作废）
error.core.data.audit.exceptions

20120000

error.core.trigger.exceptions（未正确定义）

pamirs-file2（原 pamirs-file）

20130000

error.core.file.exceptions（未正确定义）

pamirs-eip2（原 pamirs-eip2）

20140000

error.core.eip.exceptions（未正确定义）

杰

pamirs-trigger

pamirs-third-party-communicatio n

20150000

error.core.third-party-communication.exceptio ns（未定义）

pamirs-third-party-map

20160000

error.core.third-party-map.exceptions（未定义）

pamirs-business

20170000

error.core.business.exceptions（未定义）

pamirs-web

20180000

error.core.web.exceptions

141

Oinone7 天从入门到精通 pamirs-studio（已作废）

20190000

error.core.studio.exceptions（未正确定义）

pamirs-workflow

20200000

error.core.workflow.exceptions

pamirs-apps

20210000

AppsExpEnumerate

pamirs-paas

20220000

PaasExpEnumerate

表 3-12 pamirs-core 异常枚举 4. pamirs-Model-designer 异常枚举(20300000)
20300000

ModelDesignerExp

no ne

pamirs-Model-designer

表 3-13 pamirs-Model-designer 异常枚举 5. pamirs-workflow
异常枚举(20310000-20320000) 20310000

-O i

pamirs-workflow

pamirs-workflow-designer

20320000

WorkflowExpEnumerate

WorkflowDesignerExpEnumerate

表 3-14 pamirs-workflow 异常枚举

克

n 3.3.7 字段之序列化方式

杰

本文核心是带大家全面了解 0inone
的序列方式，包括支持的序列化类型、注意点、如
果新增客户化序列化方式以及字段默认值的反序列化。 一、数据存储的序列化
(举例) 使用@Field 注解的 serialize
属性来配置非字符串类型属性的序列化与反序列化方式，
最终会以序列化后的字符串持久化到存储中。 （一）Step1 新建 PetItemDetail
模型、并为 PetItem 添加两个字段 1. PetItemDetail 继承
TransientModel，增加两个字段，分别为备注和备注人;

142

Oinone7 天从入门到精通

图 3-198 PetItemDetail 继承 TransientModel

杰

克

-O i

no ne

2.  修改 PetItem，增加两个字段 petItemDetails 类型为
    List<PetItemDetail>和 tags 类型为 List<String>，
    并设置为不同的序列化方式， petItemDetails 为 JSON （缺省就是 JSON，
    可 不 配 ） ， tags 为 COMMA 。 同 时 设 置
    @Field.Advanced(columnDefinition =
    "varchar(1024)")，防止序列化后存储过长：

143

克

-O i

no ne

Oinone7 天从入门到精通

杰

图 3-199 增加两个字段 petItemDetails 类型为 List<PetItemDetail>和 tags
类型为 List<String> （二）Step2 重启系统看效果 1.
模型宠狗商品的编辑页面可以看到详情字段和商品标签字段，用新增按钮添加详情
记录，直接在商品标签的 input 框输入，回车可以输入多值；

144

no ne

Oinone7 天从入门到精通

图 3-200 模型宠狗商品编辑页

杰

克

-O i

2.  模型宠狗商品的列表页面可以看到详情字段和商品标签字段：

图 3-201 模型宠狗商品列表页面可看到详情和商品标签字段

3.  查看商品数据表，我们可以看到详情字段和商品标签字段，按指定序列化方式进行
    存储：

图 3-202 商品数据表可看到详情和商品标签字段 （三）Step3 字段序列化注意点

1.  必须使用 Field\#store 属性将字段存储设置为 NullableBoolEnum.TRUE。
2.  使用 Field\#serialize 属性指定序列化方式，默认为 JSON。 145

Oinone7 天从入门到精通 3. 如把 PetItemDetail 设置为存储模型，须在
PetItem 的 petItemDetails 字段上使 用 Field.Relation\#store 属 性 将 关
联 关 系 存 储 设 置 为 false 。 不 然 会 同 时 存 储 petItemDetails
字段和对应的 PetItemDetail 表记录。 （四）Step4 字段序列化方式说明 说明

JSON

JSON 序列化

DOT

点拼接集合元素

COMMA

逗号拼接集合元素

备注

主要用于模型相关类型字段的序列 化，是@Field.serialize 默认选项

no ne

序列化方式

非@Field.serialize 可选项列表，

BIT

按位与，2 次幂数求和

用于二进制枚举序列化不需要配 置，由 Oinone 自动推断

-O i

表 3-15 字段序列化方式说明

二、注册自己的序列化器（举例）

杰

克

注册自己的序列化器（实现
pro.shushi.pamirs.meta.api.core.orm.serialize.Serializer 接口）， 如
Oinone 的 DOT 的序列化方式，用 type()方法返回值做匹配，serialize 和
deserialize 分别对应序列化和 反序列化方法。

146

杰

克

-O i

no ne

Oinone7 天从入门到精通

图 3-203 实现 pro.shushi.pamirs.meta.api.core.orm.serialize.Serializer
接口

三、字段默认值的反序列化 用@Field.defaultValue 注解在字段上配置
defaultValue 属性时，将根据字段的 Ttype 类型及字段的 Ltype
等类型属性，自动进行反序列化。包括但不限于以下几种情况： l
OBJ、STRING、TEXT、HTML——保持不变 l BINARY、INTEGER——转换为整数 l
FLOAT、MONEY——转换为浮点数 l DATETIME、DATE、TIME、YEAR——根据
Field.Date\#format 属性决定反序列化 日期格式 l BOOLEAN——仅允许
null、true、false l ENUM——使用 value 进行匹配 147

Oinone7 天从入门到精通 n 3.3.8 字段类型之基础与复合
模型字段是描述实体的特征属性，本文介绍重点介绍字段的基础类型与复合类型。
使用@Field 注解来描述模型的字段。如果未配置字段类型，系统会根据 Java
代码的字 段声明类型来自动获取业务类型。建议配置 displayName
属性来描述字段在前端的显示名称。 可以使用 defaultValue
配置字段的默认值。

一、安装与更新 使用@Field.field
来配置字段的不可变更编码。字段一旦安装，无法在对该字段编码
值进行修改，之后的字段配置更新会依据该编码进行查找并更新；如果仍然修改该注解的配
置值，则系统会将该字段识别为新字段，存储模型会创建新的数据库表字段，而原字段将会
rename 为废弃字段。

二、基础配置 三、字段类型

BINARY

Java 类型

数据库类型

规则说明

-O i

业务类型

no ne

类型系统由基本类型、复合（组件）类型、引用类型和关系类型四种类型系统构成。通
过类型系统描述应用程序、数据库和前端视觉视图如何进行交互，数据及数据间关系如何处
理的协议。其中引用类型和关系类型介绍详见【字段类型之关系与引用】，字段命名规范参
见【构建第一个 Model】一文，这里不再赘述。 （一）基本类型

Byte

TINYINT

Byte\[\]

BLOB

二进制类型，不推荐使用 整数, 包括整数（10-11 位有效数字）、长整数（19-20

Short Integer Long

smallint

BigInteger

【数据库规则】：默认使用 int；如果 size 小于 6 则使用 smallint；如果
size 超过 6 则使用 int；如

int

果 size 超过 10 位数字，即大于 11（包含符号位），

bigint

则使用长整数 bigint；如果 size 超过 19 位数字，即

decimal(size,0)

大于 20（包含符号位），则使用大数 decimal。若未

杰

INTEGER

克

位有效数字）和大整数（超过 19 位）。

配置 size，则按 Java 类型推测。 【前端交互规则】：整数使用 Number
类型，长整数 和大整数前后端协议使用字符串类型。 浮点数,
包括单精度浮点数（7-8 位有效数字）、双 精度浮点数（15-16
位有效数字）和大数（超过 15 位）。 【数据库规则】：默认使用单精度浮点数
float；

FLOAT

Float

float(M,D)

如果 size 超过 7 位数字，即大于等于 8，则使用双精

Double

double(M,D)

度浮点数 double；如果 size 超过 15 位数字，即大于

BigDecimal

decimal(M,D)

等于 16，则使用大数 decimal。若未配置 size，则按 Java 类型推测。
【前端交互规则】：单精度浮点数 float 和双精度浮 点数 double 使用 Number
类型（因为都使用 IEEE754 协议 64 位进行存储），大数前后端协议使用字符串

148

Oinone7 天从入门到精通 类型。

BOOLEAN

Boolean

tinyint(1)

布尔类型，值为 1,true(真)或 0,false(假) 【前端交互规则】：可选项从
ModelField 的 options 字段获取，options 字段值为字段指定数据字典子集

ENUM

与数据字典指定基本 的 JSON 序列化字符串。前后端传递的是可选项的

Enum

类型一致

name，数据库存储使用可选项的 value。multi 属性 为
true，则使用多选控件；multi 属性为 false，则 使用单元控件

STRING

String

varchar(size)

TEXT

String

text

HTML

String

text

字符串，size 为长度限制默认值参考，前端可以 view 中覆盖该配置

no ne

多行文本，编辑态组件为多行文本框，长度限制为配 置项 size 值

富文本编辑器 日期时间类型

【数据库规则】：日期和时间的组合，

DATETIME

java.util.Date

-O i

时间格式为 YYYY-MM-DD HH:MM:SS\[.fraction\]，默

datetime(fraction)

java.sql.Timestamp timestamp(fraction)

认精确到秒，在默认的秒精确度上，可以带小数，最 多带 6
位小数，即可以精确到 microseconds (6 digits) precision。可以通过设置
fraction 来设置

YEAR

杰

克

精确小数位数，最终存储在字段的 decimal 属性上。

java.util.Date

year

【前端交互规则】：前端默认使用日期时间控件，根
据日期类型格式化的格式（format）来格式化日期 年份类型 日期类型
【数据库规则】：默认“YYYY”格式表示的日期值
【前端交互规则】：前端默认使用年份控件，根据日
期类型格式化的格式（format）来格式化日期 日期类型

DATE

java.util.Date

date

java.sql.Date

date

【数据库规则】：默认“YYYY-MM-DD”格式表示的日 期值
【前端交互规则】：前端默认使用日期控件，根据日
期类型格式化的格式（format）来格式化日期 时间类型

TIME

java.util.Date

time(fraction)

java.sql.Time

time(fraction)

【数据库规则】：默认“HH:MM:SS”格式表示的时间 值
【前端交互规则】：前端默认使用时间控件，根据日
期类型格式化的格式（format）来格式化日期

表 3-16 字段基本类型

149

Oinone7 天从入门到精通 （二）复合类型 业务类型

Java 类型

数据库类型

MONEY

BigDecimal

decimal(M,D)

规则说明

金额，前端使用金额控件，可以使用 currency 设置币种 字段

表 3-17 字段复合类型 （三）不可变更字段

杰

克

-O i

no ne

使用 immutable
属性来描述该字段前后端都无法进行更新操作，系统会忽略不可变更字
段的更新操作。 （四）自动生成编码的字段 详见【模型编码生成器】
（五）字段的序列化与反序列化 使用@Field 注解的 serialize
属性来配置非字符串类型属性的序列化与反序列化方式，
最终会以序列化后的字符串持久化到存储中。 详见【字段之序列化方式】
（六）前端默认配置 可以使用@Field
注解中的以下属性来配置前端的默认视觉与交互规则，也可以在前端
设置覆盖以下配置： l @Field(required)，是否必填； l
@Field(invisible)，是否不可见； l
@Field(priority)，字段优先级，列表的列使用该属性进行排序； l
更多前端默认视图配置请见【Ux 注解详解】，如：readonly 是否只读等。
（七）举例 1. 回顾我们前面学习例子，现有 PetShop 代码如下：

150

-O i

no ne

Oinone7 天从入门到精通

图 3-204 PetShop 代码

2.  字段默认推断

杰

克

我们从 PetShop 代码中会发现： ① 很多字段类型是由 Oinone 根据模型中的
java 类型自动推断， 详见 【类型默认推断】 ； ②
大部分字段我只是简单加了@Field(displayName)注解，详见【字段元数据详解】。
3. 新增未涉及基础字段以及其他注解配置 ① 为 PetShop 新增
FLOAT、BOOLEAN、TEXT、HTML、YEAR、DATE、MONEY 等字段 ② 设置 shopName
字段为 immutable=true ③ 给 MONEY 类型字段，income 配置@Field(priority =
1)

151

杰

克

-O i

no ne

Oinone7 天从入门到精通

152

克

-O i

no ne

Oinone7 天从入门到精通

图 3-205 基础字段以及其他注解配置

杰

④ 重启应用看效果 a.
在商店管理页面，点击数据记录的【修改】操作进入编辑页面，发现以下几点：
1）【收入】字段排序靠前，但不是第一这是因为默认 FORM 视图其他信息 GROUP
在前 的原因； 2）开店时间变为只读；
3）其他新增基础类型字段，前端提供默认组件展示； 4）html
描述控件的图片上传会报错，需要引入 File 模块，请参见【文件与导入导
出】一文。 b.
返回列表页查看数据，发现只有店铺名称的修改被忽略了，其他字段都赋值成功

153

no ne

Oinone7 天从入门到精通

克

-O i

图 3-206 商店管理-编辑页

图 3-207 商店管理-列表页

3.2.9 字段类型之关系与引用

杰

n

有关系与引用类型才让 Oinone 具备完整的描述模型与模型间关系的能力。 在
PetShop 以及其代理模型中已经上用到了 one2many、many2one 字段，分别如
petItems(PetItem)和
create(PamrisUser)字段，但是没有过多的讲解。本文重点举例
RELATED、many2many、one2many，至于 many2one 留给大家自行尝试。
一、引用类型(举例) 业务类型

Java 类型

数据库类型

规则说明

引用字段 【数据库规则】：点表达式最后一级对应的字段类型； RELATED

基本类型或关 不存储或 varchar、 数据库字段值默认为 Java
字段的序列化值，默认使用 系类型

text

JSON 序列化 【前端交互规则】：点表达式最后一级对应的字段控件 类型

表 3-18 字段引用类型

154

Oinone7 天从入门到精通 （一）Step1 修改 PetShopProxy 类

-O i

no ne

1.  为 PetShopProxy 类新增一个引用字段 relatedShopName，并加上
    @Field.Related("shopName")注解；
2.  为 PetShopProxy 类新增一个引用字段 createrId，并加上
    @Field.Related({"creater","id"})注解。

图 3-208 修改 PetShopProxy 类

（二）Step2 重启系统查看效果

杰

克

我们发现商店管理-列表页面多出了两个有值字段：引用字段 shopName
和引用创建者 Id。

图 3-209 商店管理-列表页面新增两个有值字段 二、关系类型 业务类型

Java 类型

数据库类型

规则说明

O2O

模型/DataMap

不存储或 varchar、text

一对一关系

155

Oinone7 天从入门到精通 M2O

模型/DataMap

不存储或 varchar、text

多对一关系

O2M

List<模型/DataMap>

不存储或 varchar、text

一对多关系

M2M

List<模型/DataMap>

不存储或 varchar、text

多对多关系

表 3-19 字段关系类型

杰

克

-O i

no ne

多值字段或者关系字段需要存储，默认使用 JSON
格式序列化。多值字段数据库字段类 型默认为
varchar(1024)；关系字段数据库字段类型默认为 text。 1. 关系字段
关联关系用于描述模型间的关联方式： l 多对一关系，主要用于明确从属关系 l
一对多关系，主要用于明确从属关系 l
多对多关系，主要用于弱依赖关系的处理，提供中间模型进行关联关系的操作 l
一对一关系，主要用于多表继承和行内合并数据

图 3-210 字段关联关系 2.

名词解释

关联关系比较重要的名词解释如下： l 关联关系：使用 relation
表示，模型间的关联方式的一种描述，包括关联关系类
型、关联关系双边的模型和关联关系的读写 l 关联关系字段：业务类型 ttype 为
O2O、O2M、M2O 或 M2M 的字段 l 关联模型：使用 references
表示，自身模型关联的模型

156

Oinone7 天从入门到精通

杰

克

-O i

no ne

l 关联字段：使用 referenceFields
表示，关联模型的字段，表示关联模型的哪些字
段与自身模型的哪些字段建立关系 l 关系模型：自身模型 l 关系字段：使用
relationFields 表示，自身模型的字段，表示自身模型的哪些字
段与关联模型的哪些字段建立关系 l 中 间 模 型 ， 使 用 through 表 示 ，
只 有 多 对 多 存 在 中 间 模 型 ， 模 型 的 relationship=true 3. 举例
many2many 关系类型
多对多关系，主要用于弱依赖关系的处理，提供中间模型进行关联关系的操作。这也是
在业务开发中很常见用于描述单据间关系，该例子会举例两种方式描述多对多关系中间表，
一是中间表没有在系统显示定义模型，二种是中间表显示定义模型。第一种往往仅是维护多
对多关系，第二种往往用于多对多关系中间表自身也需要管理有业务含义，中间表模型还经
常额外增加其他字段。
一是中间表没有在系统显示定义模型：如果出现跨模块的场景，在分布式环境下两个模
块独立启动，有可能会导致系统关系表被删除的情况发生，因为没有显示定义中间表模型，
中间表的模型所属模块会根据两边模型的名称计算，如果刚好被计算到非关系字段所属模型
的模块。那么单独启动非关系字段所属模型的模块，则会导致删除关系表。
为什么不直接把中间表的模型所属模块设置为关系字段所属模型的模块？因为如果这
样做，当模型两边都定义了多对多关系字段则会导致 M2M
关系表的所属模块出现混乱。
所以这里建议大家都选用：第二种中间表显示定义模型，不论扩展性还是适应性都会好
很多。请用：through=XXXRelationModel.Model\_Model 或者
throughClass=XXXRelationModel.class。 （一）Step1
新建宠物达人模型，并分别为宠物商品和宠物商店增加 many2many 到宠物达
人模型的字段 ① 新建宠物达人模型 PetTalent；

图 3-211 新建宠物达人模型 PetTalent ② 修改宠物商品模型，新增 many2many
字段 petTalents，类型为 List<PetTalent> ，
并加上注解@Field.many2many(relationFields =
{"petItemId"},referenceFields = {"petTalentId"},through =
"PetItemRelPetTalent")，through 为指定关联中间表；

157

杰

克

-O i

no ne

Oinone7 天从入门到精通

图 3-212 修改宠物商品模型

③ 修改宠物商店模型。 a.新增 many2many 关联模型 PetShopRelPetTalent
并继承 BaseRelation， BaseRelation
为关系模型抽象基类用于承载多对多关系，是多对多关系的中间模型，数据模型主键可以不
是 ID。更多类似抽象基类请见【模型快捷继承】。

158

Oinone7 天从入门到精通

图 3-213 新增 many2many 关联模型 PetShopRelPetTalent

杰

克

-O i

no ne

b.修改宠物商店模型，新增 many2many 字段 petTalents，类型为
List<PetTalent> ， 并加上注解@Field.many2many(relationFields =
{"petShopId"},referenceFields = {"petTalentId"},throughClass
=PetShopRelPetTalent.class) ，throughClass 为指定关 联模型类。

159

克

-O i

no ne

Oinone7 天从入门到精通

杰

图 3-214 新增 many2many 字段 petTalents

（二）Step2 重启看效果

①
进入宠物商品-编辑页面，可以看到多了推荐达人字段，点击添加选择达人记录。
至于达人数据管理这里就不赘述了，只要为达人模型配一个菜单入口进去新增就好了；

160

no ne

Oinone7 天从入门到精通

图 3-215 进入宠物商品-编辑页面

克

-O i

② 进入宠物商品-列表页面，就可以看到达人字段所选的记录；

杰

图 3-216 进入宠物商品-列表页面

③ 宠物商店的效果参考宠狗商品的编辑路径； ④
查看数据库表，对应的表和字段都已经生成了。

图 3-217 数据库表对应的表和字段都已生成 4.

举例 one2many

one2many 跟 many2one 和 many2many 不一样，one2many
的交互方式新建关联模型记录并 一把提交，而 many2one 和 many2many
而是通过添加方式选择已有关联模型记录。 （一）Step1 把 PetShopProxyA 的
items 字段提取到父类 PetShop 中去 161

Oinone7 天从入门到精通

no ne

为什么要把 PetShopProxyA 的 items 提取到 PetShop
中去呢？因为代理模型新增的字段
都是非存储字段，如果需要保存需要自己覆盖模型的 create 和 update
方法手工保存关联对
象。这个在【模型类型一文介绍代理模型】时介绍过，大家忘了可以去温习下。 ①
去除 PetShopProxyA 的 items 字段；

图 3-218 去除 PetShopProxyA 的 items 字段

杰

克

-O i

② 在 PetShop 中增加 items 字段

162

杰

克

-O i

no ne

Oinone7 天从入门到精通

图 3-219 在 PetShop 中增加 items 字段

（二）Step2 重启应用查看效果

前文中 PetShopProxyB 代理模型扩展了 catItems
萌猫商品列表字段，因为该字段是代 理模型的非存储字段。但上一步操作中原本
PetShopProxyB 从 PetShopProxyA 继承的非存储 字段 items，转而变成了从
PetShop 继承的存储字段。那么我们试下 catItems 和 items 都
添加记录的效果吧。 ① 点击菜单商店管理 B 进入 PetShopProxyB
代理模型的管理页，选择商店记录点编辑 进入商店管理 B-编辑页，
商品列表字段处新增两个商品分别是萌猫商品 1005， 宠狗商品 1006；

163

Oinone7 天从入门到精通

克

-O i

no ne

图 3-220 点击菜单商店管理 B 进入 PetShopProxyB 代理模型的管理页

杰

图 3-221 新增商品信息填写

② 萌猫商品列表处字段新增两个商品分别是代理模型萌猫商品；

图 3-222 萌猫商品列表 164

Oinone7 天从入门到精通

no ne

图 3-223 新增代理模型萌猫商品

克

-O i

③ 保存查看商品管理页面发现商品只是创建了萌猫商品 1005 和宠狗商品
1006，而没 有代理模型萌猫商品。

杰

图 3-224 保存查看商品管理页

5.  one2one

one2one 与 many2one，从前端体验也跟 many2one
一样下拉单选，但有一个区别在于目 标对象只能被一个操作对象绑定。 6.
o2m,o2o 字段的提交策略（该版本还未支持） 注解的 onUpdate 和 onDelete
属性指定在删除模型或更新模型关系字段值时，对关联模 型进行的相应操作。
操作包括 RESTRICT、 NO ACTION、 SET NULL 和 CASCADE， 默认值为 SET
NULL。 l RESTRICT
是指模型与关联模型有关联记录的情况下，引擎会阻止模型关系字段的
更新或删除模型记录； l NO ACTION
是指不作约束（这里与数据库约束的定义不相同）； l CASCADE
表示在更新模型关系字段或者删除模型时，级联更新关联模型对应记录的
关联字段值或者级联删除关联模型对应记录； l SET NULL
则是表示在更新模型关系字段或者删除模型的时候，关联模型的对应关
联字段将被 SET NULL（该字段值允许为 null 的情况下，若不允许为
null，则引擎阻止 对模型的操作）。

165

Oinone7 天从入门到精通 3.4 Oinone 以函数为内在 函数（Function）：是
Oinone 可管理的执行逻辑单元，跟模型绑定则对应模型的方法： 1.
描述满足数学领域函数定义，含有三个要素：定义域 A、值域 C{f（x），x 属于
A} 和对应法则 f。其中核心是对应法则 f，它是函数关系的本质特征; 2.
满足面向对象原则，可设置不同开放级别，本地与远程智能切换。
本章会带大家更加详细地了解 Function 的方方面面，主要以几下几个维度： 1.
构建第一个 Function 2. 函数的开放级别与类型 3. 函数的相关特性 4.
函数元数据详解

no ne

n 3.4.1 构建第一个 Function Function 做为 Oinone
的可管理的执行逻辑单元，是无处不在的。
在前面几章中不管是在模型的【数据管理器】、介绍【模型类型一文中的代理模型】时
涉及到包括在 Action 中自定义(action 背后都对应一个 Fucation)和 queryPage
进行 Function 覆盖， 还是独立抽取的公共逻辑， Function 做为 Oinone
的可管理的执行逻辑单元， 是无处不在的。这也是为什么说 Oinone
以函数为内在的原因。

一、构建第一个 Function

杰

克

-O i

因为数据管理器和数据构造器是 Oinone 为模型自动赋予的
Function，是内在数据管理 能力。模型其他 Function
都需要用以下四种方式主动定义。 （一）伴随模型新增函数(举例) 它是跟模型的
java 类定义在一起，复用模型的命名空间。 ① Step1 为 PetShop 增加一个名为
sayHello 的 Function

图 3-225 为 PetShop 增加一个名为 sayHello 的 Function ②

Step2 重启看效果

用 graphQL 工具 Insomnia 查看效果 166

Oinone7 天从入门到精通 a.

用 Insomnia 模拟登陆：

1)  创建一个 login 请求，用于保存 login
    请求，为后续模拟登陆保留快捷方式；

图 3-226 创建一个 login 请求

-O i

no ne

2)  下面为登陆请求的 GraphQL，请在 post
    输入框中输入。如果请求输入框提示错误可以， 可以点击 schema 的
    Refresh Schema 来刷新文档；

图 3-227 登陆请求的 GraphQL

杰

克

3）点击 Send 按钮，我们可以看到登陆成功的反馈信息。

图 3-228 登陆成功的反馈信息

167

Oinone7 天从入门到精通 b.

用 Insomnia 模拟访问 PetShop 的 sayHello 方法，gql
的返回中，我们可以看到两个核 心返回：

1)  一是方法正常返回的 shopName；
2)  二是“PamirsSession.getMessageHub().info("Hello:"+shop.getShopName())”代码
    执行的结果，在 messages
    中有一个消息返回，更多消息机制请见【框架之消息传递】。

杰

克

-O i

no ne

图 3-229 用 Insomnia 模拟访问 PetShop 的 sayHello

图 3-230 代码执行结果 c.

用 Insomnia 模拟访问 PetShopProxy 的 sayHello 方法：

效果同用 Insomnia 模拟访问 PetShop 的 sayHello 方法，体现 Function
的继承特性。 （二）独立新增函数绑定到模型(举例) 独立方法定义类，并采用
Model.Model 或 Fun 注解,但是 value 都必须是模型的编码，
如@Model.Model(PetShop.Model\_Model)或@Fun(PetShop.Model\_Model)。 ①
Step1 提取 PetShop 的 sayHello 方法独立到 PetShopService 中 1) 注释掉
PetShop 的 sayHello 方法

168

no ne

Oinone7 天从入门到精通

图 3-231 注释掉 PetShop 的 sayHello

克

-O i

2)  新增 PetShopService 接口类 接口的方法上要加上@Function
    注解，这样另模块依赖 api 包的时候，会自动注册远程 服务的消费者

图 3-232 新增 PetShopService 接口类

杰

3)  新增 PetShopServiceImpl 实现类

图 3-233 新增 PetShopServiceImpl 实现 ②

Step2 重启看效果

同【伴随模型新增函数的效果】，通样具备继承特性。
（三）独立新增函数只作公共逻辑单元(举例) 169

Oinone7 天从入门到精通 只能 java 后端访问，不生成 GraphQL 的
schema，即使配置 @Function(openLevel = FunctionOpenEnum.API)，也相当于
FunctionOpenEnum.REMOTE。如同模型的继承一文中的 PetCatItemQueryService
的作用，提取公共的逻辑，并且可管理。 ① Step1 修改 PetShopService 和
PetShopServiceImpl 的命名空间

克

-O i

no ne

图 3-234 修改 PetShopService 命名空间

图 3-235 修改 PetShopServiceImpl 的命名空间

Step2 重启看效果

杰

②

刷新 GraphQL schema，原先的 post 请求输入框会报错，点击提交结果也会报
GraphQL 未定义。

图 3-236 刷新 GraphQL schema 看效果 （四）伴随 ServerAction 新增函数
ServerAction
我们前面也多此提到过，比如在介绍模型类型中的代理模型和传输模型
中都定义过 ServerAction，其背后都默认定义了一个 Function。如
PetShopBatchUpdate 模型在 PetShopBatchUpdateAction
类中定义了一个【conform】的 ServerAction，背后就

170

Oinone7 天从入门到精通 定义了一个 namespace 为
demo.PetShopBatchUpdate，fun 为 conform 的 Function，而且开 放级别为
API。

二、java 同名不同参数方法（不建议）

克

-O i

no ne

java 的同名不同参数，在很多远程调用框架如 dubbo 也是不支持的，在 Oinone
中也需 要特殊处理，要以不同的 name 和 fun 来区别。 （一）Step1 为
PetShop 定义两个同名方法，并加上 Function 注解 我们把 PetShop 模型下的
sayHello 函数恢复下，并增加一个同名方法 sayHello，但注
解上@Function(name =
"sayHello2")和@Function.fun("sayHello2")。修改完以后 sayHello 和
sayHello2 都能在 Insomnia 通过 GQL 来访问。

杰

图 3-237 为 PetShop 定义两个同名方法并加上 Function 注解

（二）Step2 重启看效果

171

Oinone7 天从入门到精通 图 3-238 重启看效果

三、配置

（二）函数命名规范

默认取值规范

杰

模型属性

克

-O i

no ne

非模型但带有函数的类必需使用@Fun
注解来标识当前类为非模型带函数的类。如果需 要提供远程服务，需要在 API
包中声明注解了@Fun 注解的函数接口，并在接口的方法上加 上@Function 注解。
（一）函数配置
函数定义可以无返回值，也允许定义无参函数。如果入参为原始类型请使用对应封装类
型声明。命名空间和函数编码相同的覆盖函数有且仅有一个生效，在模型类中定义优先级高
于在模型类外定义，在模型类中靠后优先级越高。 可以使用@Model.Model、@Fun
注解函数的命名空间。先取@Model.Model 注解值，先在
本类查找注解，如果本类未配置或注解值为空则在父类或接口上查找；若为空则取@Fun
注
解值，先在本类查找注解，如果本类未配置或注解值为空则在父类或接口上查找；若皆为空
则取全限定类名。 可以使用@Function.fun
注解配置函数编码。取函数编码先在本类方法查找注解，如果
本类方法未配置或注解值为空则在父类或接口方法上查找，若皆为空则取方法名。
如果接口或者父类配置了命名空间和函数编码并且有多个实现类或继承类，如果实现方
法使用缺省的方法名作为函数编码，则会导致多个实现方法函数编码冲突，需要使用
@Function.fun
为每个实现类的对应方法配置唯一的函数编码。但大多数场景一个接口只有
一个实现类。 推荐为函数声明接口，并在接口上进行注解（@Fun
或@Model.Model，@Function），函
数实现接口即可；如果需要为函数开启远程服务，必须为函数声明接口并注解，接口须放在
api 工程中。系统会根据函数开放级别是否是 REMOTE
来自动注册服务提供者和消费者。
命名空间和函数编码的注解方式适用于所有函数。

命名规则规范

先取@Model.Model 注解值，先在本类查找

注解，如果本类未配置或注解值为空则在父

namespace

类或接口上查找；若为空则取@Fun 注解值，
先在本类查找注解，如果本类未配置或注解

长度必须小于等于 128 个字符

值为空则在父类或接口上查找；若皆为空则 取全限定类名 仅支持数字、字母
name

默认使用 java 方法名

必须以字母开头 长度必须小于等于 128 个字符 不能以 get、set
为开头作为函数名称

fun

默认使用 name 属性

summary

默认使用 displayName 属性

长度必须小于等于 128 个字符 不能使用分号 长度必须小于等于 500 个字符

172

Oinone7 天从入门到精通 descripition

NULL，注解无法定义

长度必须小于等于 65535 个字符 FunctionOpenEnum 枚举值

函数的开放等级默认值： openLevel

LOCAL(2L, "本地调用", "本地调用"),

{FunctionOpenEnum.LOCAL,

REMOTE(4L, "远程调用", "远程调用"),

FunctionOpenEnum.REMOTE}

API(8L, "开放接口", "开放接口");

Advanced.displayName

默认使用 name 属性

长度必须小于等于 128 个字符

Advanced.timeout

超时时间默认：5 秒，远程调用时配置生效

表 3-20 函数命名规范

3.4.2 函数的开放级别与类型

no ne

n

一、函数开放级别

-O i

我们在日常开发中通常会因为安全性，为方法定义不同的开放层级，或者通过应用分层
把需要对 web 开放的接口统一定义在一个独立的应用中。Oinone
也提供类似的策略，所有 逻辑都通过 Function 来归口统一管理，所以在
Function 是可以定义其开放级别有 API、 REMOTE、LOCAL
三种类型，配置可多选。 （一）四种自定义新增方式与开放级别的对应关系
本地调用(LOCAL)

远程调用(REMOTE)

开放(API)

伴随模型新增函数

支持

支持【默认】

支持

支持【默认】

支持

支持

支持【默认】

-   -   -   

必选

独立新增函数绑定到模 型

逻辑单元

伴随 ServerAction 新 增函数

支持

杰

独立新增函数只作公共

克

函数

表 3-21 四种自定义新增方式与开放级别的对应关系 （二）远程调用（REMOTE）

如果函数的开放级别为本地调用，则不会发布远程服务和注册远程服务消费者 1.
非数据管理器函数
提供者：如果函数定义在当前部署包的启动应用中，则主动发布远程服务提供者。
消费者：如果函数定义在部署依赖包中但未在当前部署包的启动应用中，则系统会默认
注册远程消费者。发布注册的远程服务使用命名空间和函数编码进行路由。
所以非数据管理器函数的消费者并不需要感知该服务是否是本地提供还是远程提供。而
服务提供者也不需要手动注册远程服务。 2. 数据管理器类函数

173

Oinone7 天从入门到精通
提供者：如果数据管理器函数所在模型定义在当前部署包的启动应用中，则系统会主动
发布数据管理器的远程服务作为数据管理器的远程服务提供者；
消费者：如果模型定义在部署依赖包中但未在当前部署包的启动应用中，则系统会主动
注册数据管理器的远程服务消费者。
所以数据管理器类函数的消费者与服务提供者并不需要感知函数的远程调用。

二、函数类型 函数的类型语义分为：增、删、改、查，在编程模式下目前用于
Function 为 API 级别， 生成 GraphQL 的 Schema 时放在 query 还是
mutation。查放在 query，其余放 mutation。在
无代码编辑器里还用页面分类管理。

n

3.4.3 函数的相关特性

一、面向对象-继承与多态

no ne

本小章会从 Oinone 的函数拥有三方面特性，展开介绍：
一是：面向对象，继承与多态； 二是：面向切面编程，拦截器； 三是：SPI
机制，扩展点。

本节为小伙伴们介绍，Function 的面向对象的特性：继承与多态； （一）继承

杰

克

-O i

我们在构建第一个 Function
一文中的伴随模型新增函数和独立类新增函数绑定到模型 都是为父模型 PetShop
新增了 sayHello 的 Function。同样其子模型都具备 sayHello 的
Function。所以我们是通过 Function 的 namespace
来做依据的，子模型会继承以母模型的 编码为 namespace 的 Function。
（二）多态（举例） Oinone 的多态，我们只提供覆盖功能，不提供重载，因为
Oinone 相同 name 和 fun 的 情况下不会去识别参数个数和类型。 ① Step1 为
PetShop 新增 hello 函数

174

-O i

no ne

Oinone7 天从入门到精通

②

克

图 3-239 为 PetShop 新增 hello 函数

Step2 为 PetShopProxyB 新增对应的三个函数

杰

其中 PetShopProxyB 新增的 hello 函数，在 java 中是重载了 hello，在代码中
new PetShopProxyB()是可以调用父类的 sayHello
单参方法，也可以调用本类的双参方法。但在 Oinone 的体系中对于
PetShopProxyB 只有一个可识别的 Fucation 就是双参的 sayHello。

175

克

-O i

no ne

Oinone7 天从入门到精通

③

杰

图 3-240 为 PetShopProxyB 新增对应的三个函数 Step3 重启看效果

1.  查看 petShopQuery 的 sayHello、sayHello2、hello 三个函数，结果正常；
2.  查看 petShopProxyBQuery 的 sayHello、sayHello2、hello
    三个函数结果都被重载 了，而且 hello 函数传不传参数
    hello，都是调用的本类的双参函数。

176

no ne

Oinone7 天从入门到精通

杰

克

-O i

图 3-241 查看 petShopQuery 的三个函数显示正常

图 3-242 查看 petShopProxyBQuery 的三个函数都已被重载
（三）模型的默认函数重写

对默认函数的重写，教程很多处都有涉及，大家可以自行测试。

177

Oinone7 天从入门到精通 名称

重写示例

说明

@Action.Advanced(name = FunctionConstants.create, managed = true)
@Action(displayName = "确定", summary = "创建", 创建

bindingType = ViewTypeEnum.FORM) @Function(name =
FunctionConstants.create) @Function.fun(FunctionConstants.create) public
PetType create(PetType data) @Function.Advanced(type =
FunctionTypeEnum.UPDATE) @Action.Advanced(name =
FunctionConstants.update, managed = true) @Action(displayName = "确定",
summary = "修改", bindingType = ViewTypeEnum.FORM)

no ne

修改

@Function(name = FunctionConstants.update)

这里以宠物品种为例罗列出来，

@Function.fun(FunctionConstants.update)

在方法上以注解的方式增加【重

public PetType update(PetType data)

写示例】列的内容

@Function.Advanced(type = FunctionTypeEnum.QUERY)
@Function.fun(FunctionConstants.queryPage)

@Function(openLevel = {FunctionOpenEnum.API})

-O i

查询

public Pagination<PetType>

queryPage(Pagination<PetType> page, IWrapper<PetType> queryWrapper)

@Function.Advanced(type = FunctionTypeEnum.DELETE)

删除

克

@Function.fun(FunctionConstants.deleteWithFieldBatch) @Function(name =
FunctionConstants.delete) @Action(displayName = "删除", contextType =

杰

ActionContextTypeEnum.SINGLE\_AND\_BATCH) public PetType delete(PetType
data) 在模型的类型一文中【新增 PetShopBatchUpdateAction 类】
章节中提到覆盖数据构造器 （construct）,接收从宠物商店
列表多选带过来的数据参数，非 构造

@Function(openLevel = FunctionOpenEnum.API)

PetShopBatchUpdate 本模型参数

@Function.Advanced(type= FunctionTypeEnum.QUERY)

不能放第一个，用 List<PetShopProxy> petShopList 来接收，进行数据组
装逻辑处理，对应数据也是由 PetShopBatchUpdate 来承载返回 给
PetShopBatchUpdate 的 Form 编辑页

表 3-22 模型的默认函数重写 178

Oinone7 天从入门到精通 二、面向切面-拦截器 （一）拦截器

杰

克

-O i

no ne

拦截器为平台满足条件的函数以非侵入方式根据优先级扩展函数执行前和执行后的逻
辑。 使用方法上的@Hook 注解可以标识方法为拦截器。前置扩展点需要实现
HookBefore 接 口；后置扩展点需要实现 HookAfter
接口。入参包含当前拦截函数定义与拦截函数的入参。
拦截器可以根据函数定义与入参处理执行逻辑。
拦截器分为前置拦截器和后置拦截器，前者的出入参为所拦截函数的入参，后者的出入
参为所拦截函数的出参。 可以使用@Hook 注解或 Hook 模型的非必填字段
module、 Model、 fun、 函数类型、active
来筛选出对当前拦截方法所需要生效的拦截器。若未配置任何过滤属性，
拦截器将对所有函数生效。 根据拦截器的优先级 priority
属性可以对拦截器的执行顺序进行调整。priority 数字 越小，越先执行。
（二）前置拦截(举例) 增加一个前置拦截，对 PetShop 的 sayHello
函数进行前置拦截，修改函数的入参的 shopName
属性，在其前面增加"hookbefore:"字符串。并查看效果 ① Step1 新增
PetShopSayHelloHookBefore 实现 HookBefore 接口 为 run 方法增加@Hook 注解
1. 配置 module={DemoModule.MODULE\_MODULE},这里 module
代表的是执行模块，该 Hook 只匹配由 DemoModule 模块为发起入口的请求 2.
配置 Model={PetShop.Model\_Model}，该 Hook 只匹配 PetShop 模型 3. 配置
fun={"sayHello"}，该 Hook 只匹配函数编码为 sayHello 的函数

图 3-243 新增 PetShopSayHelloHookBefore 实现 HookBefore 接口 ②

Step2 重启查看效果

用 graphQL 工具 Insomnia
查看效果，如果访问提示未登陆，则请先登陆。参考【构建 第一个
Function】一文。 1. 用 http://127.0.0.1:8090/pamirs/base
访问，结果我们会发现 PetShopSayHelloHookBefore
不起作用。是因为本次请求是以 base 模块作为发起模块，而 我们用
module={DemoModule.MODULE\_MODULE}声明了该 Hook 只匹配由 DemoModule
模块为发 起入口的请求；

179

Oinone7 天从入门到精通

图 3-244 用 http://127.0.0.1:8090/pamirs/base 访问

克

-O i

no ne

2.  用 http://127.0.0.1:8090/pamirs/demoCore
    访问，前端是以模块名作为访问入口 不是模块编码这里大家要注意下；

图 3-245 用 http://127.0.0.1:8090/pamirs/demoCore 访问

杰

3.  用 http://127.0.0.1:8090/pamirs/demoCore 访问，更换到 petShop
    的子模型 petShopProxy 来访问 sayHello
    函数，结果我们发现是没有效果的。因为配置
    Model={PetShop.Model\_Model}，该 Hook 只匹配 PetShop 模型。
    （三）后置拦截(举例) 增加一个后置拦截，对 PetShop 的 sayHello
    函数进行后置拦截，修改函数的返回结果 的 shopName
    属性，在其后面增加"hookAfter:"字符串。并查看效果 ① Step1 新增
    PetShopSayHelloHookAfter 实现 HookAfter 接口 为 run 方法增加@Hook
    注解
4.  配置 Model={PetShop.Model\_Model}，该 Hook 只匹配 PetShop 模型
5.  配置 fun={"sayHello"}，该 Hook 只匹配函数编码为 sayHello 的函数

180

no ne

Oinone7 天从入门到精通

图

3-246 新增 PetShopSayHelloHookAfter 实现 HookAfter 接口 ②

Step2 重启查看效果

杰

克

-O i

1.  用 http://127.0.0.1:8090/pamirs/base 访 问 ， 结 果 我 们 会 发 现
    PetShopSayHelloHookAfter 是起作用。PetShopSayHelloHookBefore
    没有配置模块过滤；

图 3-247 用 http://127.0.0.1:8090/pamirs/base 访问

2.  用 http://127.0.0.1:8090/pamirs/demoCore 访问，结果我们会发现
    PetShopSayHelloHookAfte 和 PetShopSayHelloHookBefore 同时起作用；

图 3-248 http://127.0.0.1:8090/pamirs/demoCore 访问 181

Oinone7 天从入门到精通 3. 我们会发现 HookAfter 只对结果做了修改，所以
message 中可以看到 hookbefore， 但看不到 hookAfter。 （四）注意点 1.
不管前置拦截器，还是后置拦截器都可以配置多，根据拦截器的优先级 priority
属 性可以对拦截器的执行顺序进行调整。priority
数字越小，越先执行。小伙伴们可以自行 尝试； 2. 拦截器必须是 jar
依赖，不然执行会报错。特别是有的小伙伴配置了一个没有过滤
条件的拦截器，就要非常小心； 3. 模块启动 yml 文件可以过滤不需要执行的
hook，具体配置见【模块之 yml 文件结构 详解】； 4.
不是由前端发起而是后端编程调用，默认不会生效，如果要生效请参考【框架之元
位指令】的一文。

no ne

三、SPI 机制-扩展点

杰

克

-O i

扩展点结合拦截器的设计，Oinone 可以点、线、面一体化管理 Function。
扩展点用于扩展函数逻辑。扩展点类似于 SPI 机制（Service Provider
Interface）， 是一种服务发现机制。这一机制为函数逻辑的扩展提供了可能。
（一）构建第一个扩展点 (1) 自定义扩展点（举例） 在我们日常开发中，随
http://127.0.0.1:8090/pamirs/demoCore 访问着对业务理解的
深入，往往还在一些逻辑中会预留扩展点，以便日后应对不同需求时可以灵活替换某一小块
逻辑。 在【模型的继承】一文中的
PetCatItemQueryService,是独立新增函数只作公共逻辑单
元。现在我们给它的实现类增加一个扩展点。在 PetCatItemQueryServiceImpl 的
queryPage 方法中原本会先查询 PetCatType
列表，我们这里假设这个逻辑随着业务发展未来会发生变
化，我们可以预先预留【查询萌猫类型扩展点】。 ① Step1 新增扩展点定义
PetCatItemQueryCatTypeExtpoint 1. 扩展点命名空间：在接口上用@Ext
声明扩展点命名空间。会本类查找@Ext，若为空
则往接口向上左遍历查找，返回第一个查找到的@Ext.value
注解值，使用该值再获取函数
的命名空间；如果未找到，则返回扩展点全限定类名。所以我们这里扩展点命名空间为：
pro.shushi.pamirs.demo.api.extpoint.PetCatItemQueryCatTypeExtpoint； 2.
扩展点技术名称：先取@ExtPoint.name，若为空则取扩展点接口方法名。所以我们
这里技术名为 queryCatType。

图 3-249 新增扩展点定义 PetCatItemQueryCatTypeExtpoint ②

Step2 修改 PetCatItemQueryServiceImpl（需要显示调用）

修改 queryPage，增加扩展点的使用代码。扩展点的使用有两种方式： 182

Oinone7 天从入门到精通

杰

克

-O i

no ne

方法一，使用命名空间和扩展点名称调用 Ext.run(namespace, fun, 参数);
方法二，使用函数式接口调用 Ext.run(函数式接口, 参数)。
我们这里用了第二种方式： 1. 根 据 PetCatItemQueryCatTypeExtpoint 的 全
限 定 类 名 为 扩 展 点 的 命 名 空 间 (namespace)； 2. 根据
queryCatType 的方法名为扩展点的技术名称(name)； 3. 根据 namespace+name
去找到匹配扩展点实现，并根据规则是否匹配，以及优先级唯
一确定一个扩展点实现去执行逻辑。

图 3-250 修改 PetCatItemQueryServiceImpl

③

Step3 新增扩展点实现 PetCatItemQueryCatTypeExtpointOne

1.  扩展点命名空间要与扩展点定义一致，用
    @Ext(PetCatItemQueryCatTypeExtpoint.class)；
2.  @ExtPoint.Implement 声明这是在@Ext 声明的命名空间下，且技术名为
    queryCatType 的扩展点实现。

183

Oinone7 天从入门到精通

图 3-251 新增扩展点实现 PetCatItemQueryCatTypeExtpointOne ④

Step4 重启看效果

-O i

no ne

1.  萌猫商品-列表页面的逻辑没有变化正常，说明 typeList
    从扩展点中是取到了；

图 3-252 萌猫商品-列表页面的逻无变化

杰

克

2.  用 Insomnia 直接发起 GraphQL
    请求，返回结果里可以明确知道这是扩展点实现
    PetCatItemQueryCatTypeExtpointOne 执行的结果。

图 3-253 用 Insomnia 直接发起 GraphQL 请求 ⑤

Step5 自行测试扩展点的优先级

附上第二个扩展点实现的代码，快去试试吧

184

Oinone7 天从入门到精通

图 3-254 测试扩展点的优先级（第二个扩展点实现代码） (2)
默认扩展点（举例）

杰

克

-O i

no ne

由前端直接发起调用 Oinone 后端 Function（能被前端直接发起的 Function
前提是 namespace 挂在模型上），当前端通过 GraphQL
发起对函数的请求是，Oinone 都会默认执行
三个内置扩展点分别是前置扩展点、覆盖扩展点和后置扩展点。 1.
默认扩展点与函数的关联关系
扩展点扩展的函数与扩展点通过扩展点的命名空间和技术名称关联。扩展点与所扩展函
数的命名空间一致。前置扩展点、重载扩展点和后置扩展点的技术名称的规则是所扩展函数
的函数编码 fun
加上“Before”、“Override”和“After”后缀；方法体内调用扩展点直
接使用接口调用，所以技术名称可以任意定义，只需要在同一命名空间下唯一即可。
我们在【模型继承的多表继承】中有提到过通过实现扩展点来保证子模型与父模型数据
同步。此次列子中我们来替换下 PetShop 的 sayHello 函数： ① Step1
新增扩展点定义 PetShopSayhelloOverrideExtpoint

图 3-255 新增扩展点定义 PetShopSayhelloOverrideExtpoint

②

Step2 新增扩展点实现 PetShopSayhelloOverrideExtpointImpl

图 3-256 新增扩展点实现 PetShopSayhelloOverrideExtpointImp

185

Oinone7 天从入门到精通 ③

Step3 确保 PetShop 的 sayHello 函数存在

no ne

请查看【构建第一个 Function】一文 ④ Step4 重启查看效果

图 3-257 重启查看效果 （二）总结

-O i

Oinone 用默认扩展点为 Function 提供三种默认扩展点，并通过自定义扩展点在
Function 逻辑内部任意插入扩展点,让 Function 作为 Oinone
的逻辑管理单元的可管理性大 大提升。同时结合拦截器的设计，Oinone
可以点、线、面一体化管理 Function。
注：默认扩展点，不是由前端发起而是后端编程调用，默认不会生效，如果要生效请参
考【函数之元位指令】的一文。

克

3.5 Oinone 以交互为外在

杰

交互组件（UI Componment）： 1. 用组件化的方式统一管理：菜单、布局、视图
2. 用 Action 做衔接，来勾绘出模块的前端交互拓扑，描述所有可操作行为
Oinone 的页面路由串联规则是以菜单为导航，用 Action 做衔接，用 View
做展示。查
看模块的前端交互的简易逻辑图，方便大家理解如用菜单、视图、Action
来勾绘出模块的 前端交互拓扑。本章节会重点介绍： 1.
如何定义菜单、视图、行为以及其初始化 2. xml
配置：视图配置（包括字段联动）、字段配置、布局配置、动作配置 3.
前端组件自定义

n 3.5.1 构建第一个 Menu
在前面章节中我们也涉及到菜单，因为菜单我们模块就是地图、导航，没有地图、导航
就无法畅游模块并进行相关业务操作。在模块的继承一文中介绍【多表继承】的时候就有菜
单的初始化，本文将展开介绍初始化 Menu
的两种方式分别是：注解式、数据初始化式。

一、注解式(举例) （一）Step1 分析现有菜单注解

用@UxMenus 声明 DemoMenus 为菜单初始化入口，同时该类在 DemoModule
配置扫描路径 中，那么通过 DemoMenus 初始化的菜单都挂在 demo\_core
这个模块上。 186

Oinone7 天从入门到精通
如果采用这种模式，建议同一个模块的菜单都只配置在一处：

图 3-258 分析现有菜单注解 （二）Step2 改造现有菜单注解

杰

克

-O i

no ne

1.  菜单的层级关系通过@UxMenu 的嵌套进行描述;
2.  菜单点击效果有三种分别对应不同的【Action 类型】：

<!-- -->

(1) 通过@UxRoute 定义一个与菜单绑定的 viewAction，@UxMenu("创建商店
    ")@UxRoute(value = PetShop.Model\_Model,viewName =
    "redirectCreatePage",viewType = ViewTypeEnum.FORM)，其中 viewName
    代表视图的 name(其默认值为 redirectListPage，也
    就是跳转到列表也)，value 代码视图所属模型的编码，viewType 代表 view
    类型（其默认值 为 ViewTypeEnum.TABLE）；
(2) @UxServer 定义一个与菜单绑定的 serverAction，
    @UxMenu("UxServer")@UxServer(Model = PetCatItem.Model\_Model,name =
    "uxServer") ， 其中 name 代表 serverAction 的 name， Model 或 value
    代码 serverAction 所属模型的编码；
(3) @UxLink 定义一个与菜单绑定的 UrlAction，@UxMenu("Oinone 官网
    ")@UxLink(value = "http://www.oinone.top",openType=
    ActionTargetEnum.OPEN\_WINDOW) ，其中 value 为跳转 url，openType
    为打开方式默认为 ActionTargetEnum.ROUTER，打开方式有以下几种： ①
    ROUTER("router", "页面路由", "页面路由")； ② DIALOG("dialog",
    "页面弹窗", "页面弹窗")； ③ DRAWER("drawer", "打开抽屉",
    "打开抽屉")； ④ OPEN\_WINDOW("openWindow", "打开新窗口",
    "打开新窗口")。

<!-- -->

1)  配合菜单演示，PetCatItemAction 增加一个 uxServer 的 ServerAction；

187

Oinone7 天从入门到精通

杰

克

-O i

no ne

图 3-259 PetCatItemAction 增加一个 uxServer 的 ServerActio 2)
新的菜单初始化代码如下：

图 3-260 新的菜单初始化代码

（三）Step3 重启看效果

我们会发现菜单按照我们预先设定的效果进行组织和展示：

188

Oinone7 天从入门到精通

二、数据初始化式（不推荐）

no ne

图 3-261 菜单已按照我们预先设定的效果进行组织和展示

-O i

在模块启动生命周期中，调用 InitializationUtil 工具中的
createViewActionMenu。 在前面的学习中我们用在 DemoModuleMetaDataEditor
这个类中用 InitializationUtil 工具 初始化过 viewAction 和
View。大家可以自行回忆，温故知新。

n 3.5.2 构建第一个 View

一、整体介绍

克

虽然我们有小眼睛（表格视图中的眼睛符号）可以让用户自定义展示字段和排序喜好，
以及通过权限控制行、列展示，但在我们日常业务开发中还是会对页面进行调整，以满足业
务方的对交互友好和便捷性的要求。本节我们会在如何自定义之前先介绍页面结构与逻辑，
再带小伙伴一起完成自定义 view 的 Template 和 Layout， 以及整个母版的
Template 和 Layout。

杰

（一）页面的构成讲解

189

no ne

Oinone7 天从入门到精通

杰

克

-O i

图 3-262 页面交互拓扑图 注：页面逻辑交互拓扑图说明 1. 模块作为主切换入口
2. 模块决定菜单列表 3. 菜单切换触发点击 action 4. 前端根据 Mask、View
进行渲染： a. Mask
是母版是确定了主题、非主内容分发区域所使用组件和主内容分发区域
联动方式的页面模板。全局、应用、视图动作、视图都可以通过 mask 属性指
定母版 b. Mask 和 View 都是有 layout 定义和 template
定义合并而成，系统会提供默认 母版，以及为每种视图提供默认 layout c.
layout 与 template 通过插槽进行匹配 5. Action
根据不同类型做出不同访问后端服务、url 跳转、页面路由、发起客户端动 作等
6. Aciton 路由可以指定 Mask、视图组件的 layout、template a. 当 layout
没有指定的时候则用系统默认的 b. 当 template
没有指定的时候，且视图组件相同类型有多条记录时，根据优先 级选取 7. Mask
和视图组件的 layout 优先级（视图组件&gt;视图动作 &gt; 应用 &gt; 全局）

（二）默认母版以及各类视图组件 1.

母版布局

(1) 默认母版基础布局 base-layout

190

Oinone7 天从入门到精通

图 3-263 默认母版基础布局 base-layout

杰

克

-O i

no ne

(2) 母版 template

图 3-264 母版 template

注： 上例中因为名称为 main 的插槽不需要设置更多的属性， 所以在 template
中缺省了 main 插槽的 template 标签。 (3) 最终可执行视图

191

no ne

Oinone7 天从入门到精通

2.  

-O i

图 3-265 最终可执行视图 表格视图布局

杰

克

(1) 默认表格视图基础布局 base-layout

图 3-266 默认表格视图基础布局 base-layout

注：table 标签的子标签为 column 组件，如果 field 填充到元数据插槽 fields
没有 column 组件将自动包裹 column 组件。 (2) 表格视图 template

192

no ne

Oinone7 天从入门到精通

图 3-267 表格视图 template

杰

克

-O i

(3) 最终可执行视图

图 3-268 最终可执行视图 3.

表单视图布局

(1) 默认表单视图基础布局 base-layout

193

Oinone7 天从入门到精通

图 3-269 默认表单视图基础布局 base-layout

克

-O i

no ne

(2) 表单视图 template

杰

图 3-270 表单视图 template

注：tabs 标签的子标签为 tab，如果 dsl 填充到 layout 没有 tab
标签将自动包裹 tab 标签。 (3) 最终可执行视图

194

no ne

Oinone7 天从入门到精通

图 3-271 最终可执行视图 4. 详情视图布局

克

-O i

(1) 默认详情视图基础布局 base-layout

杰

图 3-272 默认详情视图基础布局 base-layout

(2) 详情视图 template

195

no ne

Oinone7 天从入门到精通

图 3-273 详情视图 template

杰

克

-O i

(3) 最终可执行视图

图 3-274 最终可执行视图

二、构建 View 的 Template
我们在很多时候需要自定义模型的管理页面，而不是直接使用默认页面，比如字段的展
示与隐藏，Action
是否在这个页面上出现，搜索条件自定义等等，那么本章节带您一起学
习如何自定义 View 的 Template。 (1) 自定义 View 的 Template

196

Oinone7 天从入门到精通

no ne

在使用默认 layout 的情况下，我们来做几个自定义视图
Template,并把文件放到指定 目录下。

图 3-275 自定义 View 的 Template (2) 第一个 Tabel （一）Step1 自定义
PetTalent 的列表

杰

克

-O i

1.  我们先通过数据库查看默认页面定义，找到 base\_view 表，过滤条件设置为
    Model ='demo.PetTalent'，我们就看到该模型下对应的所有
    view，这些是系统根据该模型的 ViewAction
    对应生成的默认视图，找到类型为【表格（type = TABLE）】的记录，查看
    template 字段：

图 3-276 找到 base\_view 表

197

no ne

Oinone7 天从入门到精通

-O i

图 3-277 查看 template 字段

杰

克

2.  对比 view 的 template 定义与页面差异，从页面上看跟 view
    的定义少了，创建人 id 和更新人 id。因为这两个字段元数据定义里
    invisible 属性。 ① 当 XML 里面没有配置，则用元数据覆盖了。 ② 当 XML
    里面配置了，则不会用元数据覆盖了。 在下一步中我们只要 view 的 DSL
    中给这两个字段加上 invisible="false"就可以展示 出来了：

图 3-278 查看列表展示

198

-O i

no ne

Oinone7 天从入门到精通

图 3-279 invisible 属性

杰

克

3.  新建 pet\_talent\_table.xml 文件放到对应的
    pamirs/views/demo\_core/template 目 录下，内容如下： ①
    对比默认视图，在自定义视图时需要额外增加属性
    Model="demo.PetTalent"； ② name 设 置 为 "tableView" ， 系 统 重 启
    后 会 替 换 掉 base\_view 表 中 Model 为 "demo.PetTalent"，name
    为"tableView"，type 为"TABLE"的数据记录：

<!-- -->

a.  name 不同的但 type 相同，且 viewAction 没有指定时，根据优先级
    priority 进行选择。小伙伴可以尝试修改 name="tableView1"，并设置
    priority 为 1，默认生成 的优先级为 10，越小越优先。 ③ createUid 和
    writeUid 字段，增加 invisible="false"的属性定义。

199

no ne

Oinone7 天从入门到精通

-O i

图 3-280 增加 invisible="false"的属性定义

杰

克

（二）Step2 重启应用看效果

图 3-281 重启应用看效果 (3) 第一个 Form

（一）Step1 自定义 PetTalent 的编辑页 1.
我们先通过数据库查看默认页面定义，找到 base\_view 表，过滤条件设置为
Model ='demo.PetTalent'，我们就看到该模型下对应的所有
view，这些是系统根据该模型的 ViewAction
对应生成的默认视图，找到类型为【表单（type = FORM）】的记录，查看
template 字段。 2. 新 建 一 个 pet\_talent\_form.xml 文 件 放 在 对 应
的 pamirs/views/demo\_core/template
目录下，把数据状态下拉选项去除一个【草稿】选项： ①
对比默认视图，在自定义视图时需要额外增加属性 Model="demo.PetTalent"；
200

Oinone7 天从入门到精通

克

-O i

no ne

② name 设置为"formView1"，系统重启后会在 base\_view 表中新增一个 Model
为 "demo.PetTalent"，name 为"formView1"，type 为"FORM"，并设置 priority
为 1 的数据记 录： a. name 不同的但 type 相同，且 viewAction
没有指定时，根据优先级 priority 进行选择，默认生成的优先级为
10，越小越优先。所以在此打开新增或编辑页面默认 会路由到我们新配置的 view
上。

图 3-282 自定义 PetTalent 的编辑页

杰

（二）Step2 重启看效果

图 3-283 重启看效果 (4) 第一个 Detail （一）Step1 自定义 PetTalent
的详情页

1.  我们先通过数据库查看默认页面定义，找到 base\_view 表，过滤条件设置为
    Model ='demo.PetTalent'，我们就看到该模型下对应的所有
    view，这些是系统根据该模型的 ViewAction
    对应生成的默认视图，找到类型为表单（type = DETAIL）的记录，查看
    template 字段。 201

Oinone7 天从入门到精通

-O i

no ne

2.  新建一个 pet\_talent\_detail.xml 文件放在 pamirs-demo-core 的
    pamirs/views/demo\_core/template 目录下： ①
    对比默认视图，在自定义视图时需要额外增加属性
    Model="demo.PetTalent"； ② 把分组的 title 从基础信息改成基础信息 1。

图 3-284 自定义 PetTalent 的详情页

杰

克

（二）Step2 重启看效果

图 3-285 重启看效果 (5) 第一个 Search （一）Step1 自定义 PetTalent
的列表页的搜索项

修改 pet\_talent\_table.xml 文件，默认情况下<template slot="search"
autoFill="true" cols="4"/>代表着跟表格的字段自动填充搜索字段，我们搜索条件只保留
数据状态和创建时间：

202

杰

克

-O i

no ne

Oinone7 天从入门到精通

图 3-286 自定义 PetTalent 的列表页的搜索项

（二）Step2 重启看效果

图 3-287 重启看效果 (6) 其他 203

Oinone7 天从入门到精通 search 默认查询的是模型的 queryPage
函数，但我们有时候需要替换调用的函数，下
个版本支持。其核心场景为当搜索条件中有非存储字段，如果直接用 queryPage
函数的 rsql 拼接就会报错。本版本临时替代方案见【Search
之非存储字段条件】。

三、构建 View 的 Layout

杰

克

-O i

no ne

在日常需求中也经常需要调整 Layout
的情况，如出现树表结构（左树右表、级联）， 我们则需要通过修改 View 的
Layout 来完成。今天就带您学习下 Layout 的自定义。 (1) 第一个表格 Layout
如果我们想去除表格视图区域的搜索区、ActionBar（操作区），就可以为视图自定义
一个简单的 Layout 就行啦 （一）Step1 新建一个表格的 Layout 在
views/demo\_core/layout 路径下增加一个名为 sample\_table\_layout.xml
文件， name 设置为 sampleTableLayout。

图 3-288 新建一个表格的 Layout （二）Step2 修改宠物达人自定义表格
Template

在 view 标签上增加 layout 属性值为"sampleTableLayout"。

图 3-289 修改宠物达人自定义表格 Template

204

Oinone7 天从入门到精通 （三）Step3 重启看效果

图 3-290 重启看效果 （四）Step4 修改宠物达人自定义表格 Template

no ne

去除在 view 标签上的 layout 属性配置，让其回复正常。 (2) 第一个树表
Layout

本节以“给商品管理页面以树表的方式增加商品类目过滤”为例： （一）Step1
增加商品类目模型

杰

克

-O i

增加 PetItemCategory 模型集成 CodeModel，新增两个字段定义 name 和
parent，其中 parent 为关联自身模型可为空（空即一级类目）：

图 3-291 增加商品类目模型

（二）Step2 修改自定义商品模型

为商品模型 PetItem 增加一个 category 字段 m2o 关联 PetItemCategory：

图 3-292 修改自定义商品模型 （三）Step3 新增名为 treeTableLayout 的
Layout

在 views/demo\_core/layout 路径下增加一个名为 tree\_table\_layout.xml
文件，name 设置为 treeTableLayout： 205

Oinone7 天从入门到精通

杰

克

-O i

no ne

图 3-293 新增名为 treeTableLayout 的 Layout

图 3-294 代码说明 （四）Step4 自定义商品管理的 Template

1.  在 views/demo\_core/template 路径下增加一个名为 pet\_item\_table.xml
    文件；
2.  跟普通自定义 template 的区别在于： ① 配置 layout
    属性为【treeTableLayout】跟前面 layout 定义一致； ② 配置了 widget 为
    tree 的 template 节点，node 可以配置多个，node 配置说明 如下：

<!-- -->

a.  Model，模型编码，必填。
b.  label，数据标题，支持表达式，必填。 206

Oinone7 天从入门到精通 c. labelFields，数据标题中使用的字段列表，必填。
d. references，层级关联字段，第一层无效，其他层必填。模型编码\#字段。 e.
selfReferences，自关联字段，模型编码\#字段。 f.
search，点击搜索字段，必须使用主表格字段。模型编码\#字段。 g.
filter，层级过滤条件。模型编码\#字段。 以上所有使用\#拼接的属性配置，与
Model 一致的情况下，均可以省略模型编码。

杰

克

-O i

no ne

图 3-295 在 views/demo\_core/template 路径下增加一个名为
pet\_item\_table.xml 文件

207

no ne

Oinone7 天从入门到精通

图 3-296 代码说明

-O i

（五）Step5 为商品类目增加管理入口

杰

克

修改 DemoMenus 类，增加类目管理菜单

图 3-297 增加类目管理菜单

图 3-298 增加类目管理菜单 （六）Step6 重启看效果

1.  进入类目管理页面，新增商品类目数据；

208

Oinone7 天从入门到精通

图 3-299 进入类目管理页面

-O i

no ne

2.  进入商品管理页面，找一行数据修改其类目字段，然后再点击左边树看过滤效果。

图 3-300 进入商品管理页面

克

(3) 第一个级联 Layout

杰

本节以“给商品管理页面以级联的方式增加商品类目过滤”为例，该例子中左边级联项
由多个模型组成。 （一）Step1 增加商品类目类型模型 增加
PetItemCategoryType 模型集成 CodeModel，新增两个字段定义 name：

图 3-301 增加 PetItemCategoryType 模型集成 CodeModel （二）Step2
修改商品类目

为商品类目模型 PetItemCategory 增加一个 type 字段 m2o 关联
PetItemCategoryType：

209

Oinone7 天从入门到精通

图 3-302 为商品类目模型 PetItemCategory 增加一个 type 字段 （三）Step3
新增名为 cascaderTableLayout 的 Layout

no ne

在 views/demo\_core/layout 路径下增加一个名为
cascader\_table\_layout.xml 文件：

杰

克

-O i

图 3-303 新增名为 cascaderTableLayout 的 Layout

图 3-304 代码说明 210

Oinone7 天从入门到精通 （四）Step4 修改商品管理的 Template

杰

克

-O i

no ne

1.  修改在 views/demo\_core/template 路径下名为 pet\_item\_table.xml
    的文件：

<!-- -->

a.  配置 layout 属性为【cascaderTableLayout】跟前面 layout 定义一致；
b.  配置了 widget 为 card-cascader 的 template 节点，node
    可以配置多个，node 配置跟树表的配置一致。

图 3-305 修改商品管理的 Template 211

Oinone7 天从入门到精通 （五）Step5 为商品类目类型增加管理入口

no ne

图 3-306 为商品类目类型增加管理入口

图 3-307 代码说明 （六）Step6 重启看效果

杰

克

-O i

1.  进入类目类型管理页面，新增商品类目类型数据；

图 3-308 进入类目类型管理页面

2.  进入类目管理页面，修改一级类目的类型

图 3-309 修改一级类目的类型

212

Oinone7 天从入门到精通 3.
进入商品管理页面，找一行数据修改其类目字段，然后再点击左边级联项看过滤效
果

图 3-310 进入商品管理页面

n 3.5.3 Action 的类型

no ne

(4) 树表与级联的更多配置

一、动作类型

-O i

各类动作我们都碰到过，但都没有展开讲过。这篇文章我们来系统介绍下 Oinone
涉及 到的所有 Action 类型。

杰

克

① 服务器动作 ServerAction：类似于 Spring MVC 的控制器
Controller，通过模型编
码和动作名称路由，定义存储模型或代理模型将为该模型自动生成动作名称为
consturct，
queryOne，queryPage，create，update，delete，deleteWithFieldBatch
的服务器动作。 定义传输模型将为该模型自动生成动作名称为 consturct
的服务器动作； ② 窗口动作
ViewAction：站内跳转，通过模型编码和动作名称路由。系统将为存储
模型和代理模型自动生成动作名称为 redirectDetailPage
的跳转详情页窗口动作，动作名 称为 redirectListPage
的跳转列表页窗口动作，动作名称为 redirectCreatePage 的跳转新
增页窗口动作，动作名称为 redirectUpdatePage 的跳转更新页窗口动作； ③
跳转动作 UrlAction：外链跳转； ④ 客户端动作
ClientAction：调用客户端函数。

二、默认动作

① 如果在 UI 层级， 有开放新增语义函数， 则会默认生成新增的窗口动作
ViewAction， 跳转到新增页面； ② 如果在 UI 层级， 有开放更新语义函数，
则会默认生成修改的窗口动作 ViewAction， 跳转到更新页面； ③ 如 果 在 UI
层 级 ， 有 开 放 删 除 语 义 函 数 ， 则 会 默 认 生 成 删 除 的 客 户
端 动 作 ClientAction，弹出删除确认对话框。

三、第一个服务器动作 ServerAction 1.

回顾第一个 ServerAction

第一个 ServerAction
是在【模型的类型\#代理模型】一节出现的，再来看下当时的定义 代码：

213

no ne

Oinone7 天从入门到精通

图 3-311 回顾第一个 ServerAction

2.  

-O i

① @Action 注解将创建服务器动作，并@Model.Model 绑定； ② 自定义
ServerAction 请勿使用 get、set、unset 开头命名方法或 toString 命名方
法。 ServerAction 之校验(举例)

（一）Step1 为动作配置校验表达式

杰

克

使用@Validation 注解为 PetShopProxyAction 的 dataStatusEnable
服务端动作进行校 验表达式配置：

214

Oinone7 天从入门到精通 图 3-312 为动作配置校验表达式 注： ①
ruleWithTips 可以声明多个校验规则及错误提示； ② IS\_BLANK 和 LEN
为内置文本函数，更多内置函数见【函数之内置函数与表达式】； ③
当内置函数不满足时参考【Action 之校验】。 （二）Step2 重启看效果

no ne

在商店管理页面点击启用得到了预期返回错误信息，显示"编码为必填项"

图 3-313 在商店管理页面点击启用得到了预期返回错误信息 3.

ServerAction 之前端展示规则(举例)

杰

克

-O i

既然后端对 ServerAction
发起提交做了校验，那能不能在前端就不展示呢？当然可以，
我们现在就来试下。 （一）Step1 配置 PetShopProxyAction 的
dataStatusEnable 的前端出现规则
用注解@Action.Advanced(invisible="!(activeRecord.code !== undefined &&
!IS\_BLANK(activeRecord.code))")来表示，注意这里配对 invisible
是给前端识别的， 所以写法上跟后端的校验有些不一样，但如内置函数
IS\_BLANK 这些是前后端一致实现的， activeRecord 在前端用于表示当前记录。

215

Oinone7 天从入门到精通 图 3-314 配置 PetShopProxyAction 的
dataStatusEnable 的前端出现规则 （二）Step2 重启看效果

我们发现店铺编码为空的记录，没有了启用的操作按钮：

4.  

no ne

图 3-315 店铺编码为空的记录没有启用操作按钮 ServerAction 配置说明

(1) 常用配合

杰

克

-O i

① contextType 设置动作上下文类型 a.
SINGLE(默认)——单行，常用于列表页（展示在每行末尾的操作栏中）和表单页（展
示在页面上方） b. BATCH——多行，常用于列表页（展示在表格上方按钮区） c.
SINGLE\_AND\_BATCH——单行或多行，常用于列表页（展示在表格上方按钮区） d.
CONTEXT\_FREE——上下文无关，常用于列表页（展示在表格上方按钮区） ②
bindingType 设置按钮所在页面类型（以下仅说明常用类型，详见
ViewTypeEnum） a. TABLE——列表页 b. GALLERY——画廊 c. FORM——表单页 d.
DETAIL——详情页 e. CUSTOM——自定义页 (2) 注解大全 @Action ├── displayName
显示名称 ├── summary 摘要摘要 ├── contextType 动作上下文，可选项详见
ActionContextTypeEnum ├── bindingType 所在页面类型，可选项详见
ViewTypeEnum ├── Advanced 更多配置 │ ├── name 技术名称，默认 Java 方法名
│ ├── args 参数，默认 java 参数 │ ├── type 方法类型，默认
UPDATE，可选项详见 FunctionTypeEnum │ ├── language 方法实现语言，默认
JAVA，可选项详见 FunctionLanguageEnum │ └── invisible 隐藏规则 │ └──
bindingView 绑定特定视图 │ └── priority 展示顺序

216

Oinone7 天从入门到精通 四、第一个窗口动作 ViewAction (1) 回顾第一个
ViewAction

克

-O i

no ne

第一个 ViewAction
是在【模型的类型-传输模型】一节出现的，再来看下当时的定义代 码。

图 3-316 回顾第一个 ViewAction

杰

(2) createViewAction 参数详解（建议更换为注解方式） 参数名

类型

说明

name

String

技术名称，唯一建要求

displayName

String

展示名称

originModel

String

ViewAction 的绑定模型

originViewTypes

List<ViewTypeEnum>

targetModel

String

targetViewType

ViewTypeEnum

ViewAction 在绑定模型的哪些视图 类型上展示 ViewAction 跳转到的目标模型
ViewAction 跳转到的目标模型的什 么类型视图

217

Oinone7 天从入门到精通 ViewAction 在绑定模型视图上设置
展示的动作上下文类型 SINGLE(默认)——单行，常用于列
表页（展示在每行末尾的操作栏中） 和表单页（展示在页面上方）
BATCH——多行，常用于列表页（展 contextType

ActionContextTypeEnum

示在表格上方按钮区） SINGLE\_AND\_BATCH——单行或多
行，常用于列表页（展示在表格上 方按钮区） CONTEXT\_FREE——上下文无关，常
用于列表页（展示在表格上方按钮 区）

no ne

页面打开方式 pageTarget

ActionTargetEnum

DIALOG：页面弹窗 DRAWER：打开抽屉 ViewAction 跳转到的目标模型的指

resViewName

String

定视图的名称，该视图的类型需要 跟 targetViewType 一致

String

-O i

title

页面标题

置

priority

克

非 createViewAction 参数，但是 ViewAction 有的参数，createViewAction
以后可以通过 setXX 方法来设

Intget

展示顺序

String

绑定特定视图

invisible

String

隐藏规则

laod

String

filter

String

domain

String

杰

bindingView

对于特殊模型的窗口动作进行定制 化的加载方式
代表后端过滤，是一定会加上的过 滤条件，用户无感知
代表前端过滤，是默认会加上的过 滤条件，用户可以去除该搜索条件

表 3-23 createViewAction 参数详解 注解见：@UxRouteButton(action =
@UxAction(),value = @UxRoute()) (3) ViewAction
高级参数-Load(下个版本支持) 218

Oinone7 天从入门到精通 一般用于以下场景：
1、对于特殊模型的窗口动作进行定制化的加载方式。
2、不同模型间跳转时，可根据上一个模型的数据内容加载另一个模型的数据内容。
使用初始化工具类设置 Load 函数：

图 3-317 使用初始化工具类设置 Load 函数

no ne

注： 所示修改窗口动作方法将 TestModel 模型的默认创建页的加载函数从
construct 函数改 为了 createPageLoad 函数。
替代方案：构建模型子类，通过子类来重写 construct 方法 (4) ViewAction
高级参数 filter 和 domain(举例)

杰

克

-O i

filter 当前版本支持，domain
下个版本支持，之所以放一起讲是因为这是过滤的两种 形态。 ① filter
代表后端过滤，是一定会加上的过滤条件，用户无感知 ② domain
代表前端过滤，是默认会加上的过滤条件，用户可以去除该搜索条件 （一）Step1
修改自定义 pet\_talent\_table.xml 查询条件增加 name 字段

图 3-318 修改自定义 pet\_talent\_table.xml 查询条件增加 name 字段
（二）Step2 为宠物达人模型的两个菜单入口分配置 filter 和 domain

把【宠物达人】菜单调整为三个菜单【宠物达人 1】、【宠物达人
2】、【宠物达人 3】 分别设置 filter 和 domain。 ① 修改以菜单【宠物达人
1】为入口的 ViewAction 的 filter： a. @UxRoute(filter = "name =like=
'老'")字符串要符合 RSQL。 219

Oinone7 天从入门到精通

no ne

② 修改以菜单【宠狗达人 2】为入口的 ViewAction 的 domain： a.
@UxRoute(domain = "name =like= '老'") 字符串要符合 RSQL。 ③
修改以菜单【宠狗达人 3】跟函数结合，设置时间默认过滤条件： a.
@UxRoute(domain = "createDate =ge=
'${ADD_DAY(NOW_STR(),-7)}' and createDate =lt= '${NOW\_STR()}'")
字符串要符合 RSQL； b. createDate =ge=
'${ADD_DAY(NOW_STR(),-7)}' and createDate =lt= '${NOW\_STR()}'： l
用到函数需要用\${}装饰； l 更多函数参见函数之内置函数与表达式。 ④ domain
的操作符需要跟页面搜索字段定义的操作符一致，比如 name 字符串字段搜
索默认操作符是=like=，如果配置成其他则无效。

（三）Step3 重启看效果

-O i

图 3-319 两个菜单入口分配置 filter 和 domain

杰

克

因为【宠物达人 1】对应 ViewAction 加的是
Filter，所以只能看到达人名称带“老” 字的记录;

图 3-320 宠物达人 1 搜索记录 因为【宠物达人 2】对应 ViewAction 加的是
Domain，前端搜索栏里【达人】字段搜索
条件为“老”字，达人名称带“老”字的记录，可以手工删除再次搜索全部数据;

220

Oinone7 天从入门到精通 图 3-321 宠物达人 2 搜索记录 因为【宠物达人
3】对应 ViewAction 加的是 Domain，前端搜索栏里【创建时间】字段 带近 7
天过滤条件，可以手工删除再次搜索全部数据;

五、第一个跳转动作 UrlAction (1) 回顾第一个 UrlAction

no ne

图 3-322 宠物达人 3 搜索记录

-O i

在【构建第一个 Menu】一文中用@UxMenu.url
定义了一个百度的菜单，该菜单背后就是 一个普通的 UrlAction。

图 3-323 回顾第一个 UrlAction

克

(2) URL 计算表达式（暂不支持）

杰

图 3-324 URL 计算表达式

(3) Compute 函数（暂不支持）

图 3-325 Compute 函数 注： 221

Oinone7 天从入门到精通 所示创建链接动作方法为打开新标签页方式跳转至指定
URL，该 URL 来自于后端 computeSearchUrl 请求的返回值内容。

六、第一个客户端动作 ClientAction (1) 基础客户端动作(举例)

no ne

给批量修改店铺状态弹出页面增加一个【自定义返回】和【自定义关闭】按钮，这里注
意 contextType 只能配置为“ActionContextTypeEnum.SINGLE”，因为 Form
默认只展示 contextType 为 SINGLE 的 Action （一）Step1 在
PetShopBatchUpdateAction 增加@UxClientButton 注解

杰

克

（二）Step2 重启看效果

-O i

图 3-326 在 PetShopBatchUpdateAction 增加@UxClientButton 注解

图 3-327 重启看效果 (2) 前端动作之组合动作(举例)

通过自定义 View 的 Template
来设置组合动作，同时学习下自定义视图时如何设置需要 展示
Action，还是以批量修改店铺状态弹出页面为例子，我们只展示一个组合动作按钮【组
合动作】，它包含表单校验、提交、关闭并刷新主视图等行为动作 （一）Step1
自定义弹出框 View 1. 在 views/demo\_core/template 路径下增加一个名为
pet\_shop\_batch\_update\_form.xml 文件；

222

Oinone7 天从入门到精通 2. 再通过数据库查看默认页面定义，找到 base\_view
表，过滤条件设置为 Model
='demo.PetShopBatchUpdate'，我们就看到该模型下对应的所有
view，这些是系统根据该 模型的 ViewAction
对应生成的默认视图，找到类型为【表单（type = FORM）】的记录，查 看
template 字段，复制给 pet\_shop\_batch\_update\_form.xml 文件； 3.
把【<template slot="actions" autoFill="true"/>】替换成以下内容：

no ne

图 3-328 替换<template slot="actions" autoFill="true"/>

（二）Step2 重启看效果

杰

克

-O i

这个页面只保留了【组合动作】一个按钮，其他没有配置的按钮就会隐藏掉。

图 3-329 未配置的按钮均会被隐藏

(3) 平台默认前端动作：

有元数据定义名的建议最好用元数据名，比如平台默认前端导入动作
“\$\$internal\_GotoListImportDialog”可以用“internalGotoListImportDialog”来替代，
这样的好处是管理一致，比如权限等功能设置。

图 3-330
“\$\$internal\_GotoListImportDialog”可用“internalGotoListImportDialog”
替代

name

适用场景

功能描述

元数据定义名

223

Oinone7 天从入门到精通 \$\$internal\_GotoListTab

通用

leRouter

关系字段表格

\$\$internal\_DialogCance

弹窗

刷新当前主视图组件

通用

打开一个创建弹窗

多对多关系 表格

打开 M2M 表格的创建弹窗

$$internal_ListInsertO
neAndCloseDialog
$$internal\_GotoM2MList Dialog $$internal_GotoO2MCrea
teDialog
$$internal\_GotoO2MEdit Dialog

一对多关系 表格

一对多关系 表格

\$\$internal\_ListInsertO

表单

$$internal_ListUpdateO
neAndBackToList
$$internal\_ValidateFor

\$\$internal\_GotoListExp ortDialog

表单

表单

克

m

ortDialog

打开 O2M 表格的编辑弹窗 校验表单数据，提交到后 端，返回表格(新建)

校验表单数据，提交到后 端，返回表格(更新) 校验当前表单

一般用于表格

数据导出的 action

一般用于表格

数据导入的 action

杰

\$\$internal\_GotoListImp

打开 O2M 表格的创建弹窗

-O i

neAndBackToList

internalDeleteOne

据 关闭当前弹窗

\$\$internal\_ReloadData

ter

删除绑定的表格的选中数

弹窗

l

internalGotoListTableRou

no ne

\$\$internal\_DeleteOne

返回上一个页面

internal\_GotoListImportD ialog internalGotoListImportDi alog

表 3-24 平台默认前端动作

n 3.5.4 Ux 注解详解
我们默认视图已经基本可以用了，但实际业务中还是会有一些不大不小的自定义需求，
写自定义视图又太麻烦，今天我们来学习一种更加轻量的模式即：后端研发可以通过注解来
配置视觉交互。该系列注解以 Ux
开头，例如@UxHomepage、@UxMenu、@UxAction、@UxView、 @UxWidget 等等。
视图 XML
的配置优先级大于在代码上的注解，也就是代码上的注解影响的是默认展示逻
辑。

一、Ux 家族图谱
我们先简单通过家族图谱做个简单了解，脑海里有一个影响当有需要的时候知道能不能
做，深入了解还需要大家多多动手去尝试。

224

杰

克

-O i

no ne

Oinone7 天从入门到精通

图 3-331 Ux 家族图谱 225

Oinone7 天从入门到精通 二、默认视图后端配置举例

杰

克

-O i

no ne

在下面的代码片段中 UxTable、UxForm、UxDetail、UxTableSearch
都有涉及，几个特 殊点做些解释其他的留大家自行测试： l Group
分组的配置逻辑：为了不让一个分组内的字段不断的写 Group，所以采取了
第一个字段写了 Group，到下一个出现的 group 之间的字段都自动归为一个
Group。 l 搜素整体不展示可以用“@UxTable(enableSearch =
false)”配置在模型的类上。 l
字段搜索用“UxTableSearch”配置在模型的字段上，其特殊逻辑是只要你配了一
个字段，系统就不自动补充了，例子中表格页的搜索栏只会留下店铺名称和店铺编码。

图 3-332 默认视图后端配置举例

n 3.5.5 设计器的结合 在页面开发的时候，直接通过前端组件和视图 xml
进行开发虽然开放性是很大的、但我 们经常会忘记视图的配置属性，同时用 xml
配置的页面因为缺少设计数据，导致无法直接在
设计器中复制，自定义页面得从头设计。今天就带大家一起来学习如何结合无代码设计器来
完成页面开发，并把设计后的页面元数据装载为标准产品的一部分。 一、Step1
安装 Docker（详情可参见文末【附件一】） 如果没有 Docker
的话，请自行到官网下载：https://www.docker.com/get-started/ 226

Oinone7 天从入门到精通 二、Step2 下载 Docker 镜像，并导入镜像

l 镜像下载 1. 镜像下载用户与密码 需要商业版镜像需要加入 Oinone
商业版本伙伴专属群，向 Oinone 技术支持获取临时用
户名与密码，镜像会定时更新并通知大家。

图 3-333 像下载用户与密码 前端镜像

no ne

2.  

图 3-334 前端镜像 后端镜像

-O i

3.  

图 3-335 后端镜像

l

本地结构说明

杰

克

下载结构包并解压（下载详情可见文末【附件一】）

图 3-336 下载结构包 Oinone-op-ds 并解压

① config 是放 application.yml 的目录，可以在 application.yml
配置需要启动的 自有模块同时修改对应其他中间件配置项 ② lib 是放自有模块的
jar 包以及其对应的依赖包比如： pamirs-demo-api-1.0.0-SNAPSHOT.jar 和
pamirs-demo-core-1.0.0-SNAPSHOT.jar ③ logs 是运行时系统日志目录
三、Step3 application.yml 配置示例

application.yml 文件用我们 demo 工程的 application.yml
来替换同时增加对应配置 （主要是合并 bootstrap.yml
和增加启动模块），注意点有： l 要把 192.168.1.173 换成非 127.0.0.1
的机器分配 IP：通过 ifconfig(mac)或 ipconfig(windows)命令查询； 227

Oinone7 天从入门到精通

克

-O i

no ne

数据库换成自己 demo 工程的数据库，demo6\_v3 --&gt; demo； 增加
demo\_core 模块。

杰

l l

图 3-337 application.yml 配置示例

228

Oinone7 天从入门到精通 四、Step4 检查中间件

我们前面中间件所绑定的 IP 都是 127.0.0.1，因为我们这里使用了 docker
来访问，需 要让中间件支持真正机器分配 IP 访问。 （一）Step4.1 检查 mysql
1. 确保 yml 文件中配置的用户可以通过机器 IP 来访问，例子中我们是用的是
root 用 户，按以下步骤检查：

no ne

图 3-338 第一步

克

-O i

图 3-339 第二步

杰

图 3-340 第三步

图 3-341 第四步

图 3-342 第五步 （二）Step4.2 检查 redis

找到 redis 安装目录，编辑 redis.conf，bind 从 127.0.0.1 改成 0.0.0.0
或对应本机 IP，重启 redis：

229

Oinone7 天从入门到精通

图 3-343 检查 redis 如果 redis
访问有问题，可以尝试在启动命令中增加“--protected-mode no”参数：

图 3-344 在启动命令中增加“--protected-mode no”参数

no ne

（三）Step4.3 检查 RocketMq

检查 broker 节点配置 IP，如果有配置不能用 127.0.0.1。 （四）Step4.4 检查
Zookeeper

杰

克

-O i

如果本地搭集群方式需要检查 IP，如果有配置不能用 127.0.0.1。 五、Step5
启动 Docker 启动 docker： ① 打开 Oinone.sh 文件，修改脚本变量 configDir
和 Ip；

图 3-345 修改脚本变量 configDir 和 Ip

② 执行脚本。

图 3-346 执行脚本 六、Step6 体验并设计页面

输入 http://localhost/访问，通过 App Finder 切换时多了设计器一项

230

Oinone7 天从入门到精通

图 3-347 通过 App Finder 切换时多了设计器一项

-O i

no ne

七、Step7 导出元数据，并固化元数据到产品中 （一）Step7.1
通过接口获取界面设计器设计页面的元数据 1）调用接口定义

图 3-348 调用接口定义

杰

克

2）返回结果

图 3-349 返回结果 jsonUrl 为导出结果, 点击 ULR 下载导出文件
（二）Step7.2 第三步元数据导入到项目中 1. pom 依赖：

图 3-350 pom 依赖 231

Oinone7 天从入门到精通 2.
将第二步下载后的文件放入项目中（注意文件放置的位置）。放置工程的
resources 下面。例如：

no ne

图 3-351 将下载后的文件放入项目中

杰

克

-O i

3.  项目启动过程中，将文件中的数据导入(通常放在 core 模型的 init
    包下面)。示例 代码：

图 3-352 将文件中的数据导入

n 3.5.6 DSL 配置大全
因为默认视图很难满足客户的个性化需求，所以日常开发中 view
的配置是避免不了的。 本系列篇是比较全面地介绍 View
配置的各个方面涉及：视图、字段、动作、布局等。

一、字段的配置 （一）字段组件类型

232

Oinone7 天从入门到精通

杰

克

-O i

no ne

ttype 可以配置哪些 widget？本文这里把 Oinone 平台默认支持的所有 widget
都进行了 罗列，方便大家查阅。 （二）字段组件匹配规则
字段组件没有严格的按组件名(widget)、字段类型(ttype)、视图组件类型(viewType)
限定，而是一个匹配规则 ① 按 widget 最优先匹配 ② 按最大匹配原则 a.
ttype、viewType。每个属性权重一分 ③ 按后注册优先原则 （三）通用属性

图 3-353 字段通用属性 （四）字段组件大全

widget 为"-"表明不需要指定，是该 ttype 默认 widget 对应 组件名称 widget

属性

属性描述

属性 name

默认值

类型

ttype

单行文本

-   

STRING

通用属性

233

Oinone7 天从入门到精通 密码:password; 文本: 文本类型

type

text

string

minLength

-   

number

maxLength

-   

number

pattern

-   

正则表达式

tips

校验失败

string

showCount

false

boolean

allowClear

true

true

showPrefix

false

boolean

text 输入框填写数据时最少输 最小长度 入的长度值 输入框填写数据时最多输
最大长度 入的长度值 单行文本组件特有的属 性，通过规则校验内容， 输入格式
提供一些常用的，也支持 自定义校验正则 输入格式不通 输入格式不通过提示语
过 设置输入框是否显示字数

no ne

显示计数器

计数器

设置输入框是否有一键清 显示清除按钮

除的按钮及功能

开启前缀

-O i

支持前缀

开启后缀

showSuffix

false

boolean

前缀类型

ICON: 图标; TEXT:文本

prefixType

-   

string

后缀类型

ICON: 图标; TEXT:文本

suffixType

-   

string

前缀内容

文本内容或者图标引用名

prefix

-   

string

杰

克

支持后缀

文本内容或者图标引用名

suffix

-   

string

prefixStore

-   

boolean

suffixStore

-   

boolean

minLength

-   

number

maxLength

-   

number

后缀内容

前缀存储, 仅前缀类型为 前缀存储 文本可用 后缀存储, 仅后缀类型为 后缀存储
文本可用

通用属性

输入框填写数据时最少输 多行文本

-   

TEXT

最小长度 入的长度值 输入框填写数据时最多输 最大长度 入的长度值

234

Oinone7 天从入门到精通 设置输入框是否显示字数 显示计数器

showCount

false

boolean

allowClear

true

true

计数器 设置输入框是否有一键清 显示清除按钮 除的按钮及功能

通用属性

INTEGER

max

-   

number

最小值

最小值

min

-   

number

支持前缀

开启前缀

showPrefix

false

boolean

支持后缀

开启后缀

showSuffix

false

boolean

前缀类型

ICON: 图标; TEXT:文本

prefixType

-   

string

后缀类型

ICON: 图标; TEXT:文本

suffixType

-   

string

no ne

-   

最大值

-O i

整数

最大值

文本内容或者图标引用名

prefix

-   

string

后缀内容

文本内容或者图标引用名

suffix

-   

string

showThousandth

false

boolean

allowClear

true

true

克

前缀内容

显示千分位

显示千分位

设置输入框是否有一键清

杰

显示清除按钮

除的按钮及功能

通用属性

小数

-   

最大值

最大值

max

-   

number

最小值

最小值

min

-   

number

支持前缀

开启前缀

showPrefix

false

boolean

支持后缀

开启后缀

showSuffix

false

boolean

前缀类型

ICON: 图标; TEXT:文本

prefixType

-   

string

FLOAT

235

Oinone7 天从入门到精通 后缀类型

ICON: 图标; TEXT:文本

suffixType

-   

string

前缀内容

文本内容或者图标引用名

prefix

-   

string

后缀内容

文本内容或者图标引用名

suffix

-   

string

显示千分位

显示千分位

showThousandth

false

boolean

保留小数位数

保留小数位数

precision

-   

number

allowClear

true

true

设置输入框是否有一键清 显示清除按钮

no ne

除的按钮及功能

通用属性

选项配置使用<option

name="" displayName=""
选项配置

M2M、

invisible="">节点可配

options

-   

optionLabel

模型数据标题

表达式

name

string

domain

-   

表达式

options

-   

optionLabel

模型数据标题

表达式

name

string

置多个选项,

O2O、 M2M

需要配

O2O

置

BOOLEAN

BOOLEAN

ENUM

关系型下拉不支持

-O i

ENUM 不

关系型下拉选项展示标

下拉单选

选项字段

题,例如

"activeRecord.name"

为

克

关系下拉搜索使用字段,

Select

搜索字段

例如"name, code",字段名 searchFields 逗号分割

杰

关系型下拉数据过滤, 例

过滤条件

如"activeRecord.name == '小明'"

通用属性

选项配置使用<option
name="" displayName=""
选项配置

invisible="">节点可配 置多个选项,

O2M、M2M、 下拉多选

-   

关系型下拉不支持 ENUM 关系型下拉选项展示标 选项字段

题,例如 "activeRecord.name" 关系下拉搜索使用字段,

搜索字段

例如"name, code",字段名 searchFields 逗号分割

236

Oinone7 天从入门到精通 关系型下拉数据过滤, 例 过滤条件

如"activeRecord.name ==

domain

-   

表达式

'小明'"

最多选择个数

多选最多选择的个数

maxNumber

-   

number

最少选择个数

多选最少选择的个数

minNumber

-   

number

默认值

defaultValue

false

boolean

通用属性 开关

-   

BOOLEAN 默认值

no ne

通用属性 选项配置使用<option

name="" displayName=""
BOOLEAN、
单选框

Radio

选项配置

invisible="">节点可配

ENUM

options

-   

orientation

horizontal

置多个选项,

关系型下拉不支持

单选框的排列方式

-O i

排列方式

vertical | horizontal

通用属性

克

选项配置使用<option

name="" displayName=""

Checkbo ENUM,mult
复选框

选项配置

i=true

杰

x

排列方式

富文本

-

HTML

通用属性

年份

-

Year

通用属性

invisible="">节点可配

options

-   

orientation

horizontal

置多个选项,

关系型下拉不支持 vertical | 单选框的排列方式

horizontal

通用属性

日期

-   

Date 日期格式

CHINESE: 2019 年 04 月 06

CHINESE

日

CHINESE\_YEAR\_MO

CHINESE\_YEAR\_MONTH:

NTH

2019 年 04 月

dateFormat

CHINESE

HYPHEN\_YEAR\_MON

HYPHEN\_YEAR\_MONTH:

TH

2019-04

SLASH\_YEAR\_MONT

SLASH\_YEAR\_MONTH:

H

237

Oinone7 天从入门到精通 2019/04

HYPHEN

HYPHEN: 2019-04-06

SLASH

SLASH: 2019/04/06 通用属性 COLON\_NORMAL: HH:mm:ss COLON\_NORMAL
COLON\_SHORT: HH:mm COLON\_SHORT 时间格式

AP\_COLON\_NORMAL: A

timeFormat

COLON\_NORMAL AP\_COLON\_NORMAL

hh:mm:ss AP\_COLON\_SHORT AP\_COLON\_SHORT: A hh:mm CHINESE: 2019 年 04
月 06 日期时间

-   

CHINESE

DateTime

日 CHINESE\_YEAR\_MO CHINESE\_YEAR\_MONTH: NTH

no ne

2019 年 04 月 HYPHEN\_YEAR\_MON

HYPHEN\_YEAR\_MONTH: 日期格式

dateFormat

CHINESE

TH

2019-04

SLASH\_YEAR\_MONT

SLASH\_YEAR\_MONTH:

H

2019/04

HYPHEN

HYPHEN: 2019-04-06

SLASH

时间

-O i

SLASH: 2019/04/06

Time

通用属性

COLON\_NORMAL: HH:mm:ss

-   

COLON\_NORMAL

COLON\_SHORT: HH:mm AP\_COLON\_NORMAL: A

克

时间格式

COLON\_SHORT timeFormat

COLON\_NORMAL AP\_COLON\_NORMAL

hh:mm:ss AP\_COLON\_SHORT

颜色选择 ColorPi

杰

AP\_COLON\_SHORT: A hh:mm

STRING

器

cker

通用属性

通用属性

最大上传文件 STRING Upload 文件上传

最大上传文件个数

limit

-   

number

limitSize

-   

number

limitFileType

-   

string

limit

-   

number

个数

multi=tru e

最大上传文件

最大上传文件体积,单位

体积

为 mb

限制上传文件 限制上传文件类型, 例如 类型

图片上传

UploadI

STRING

mg

multi=tru e

"jpg,mp4", 逗号分割

通用属性

最大上传文件 最大上传文件个数 个数

238

Oinone7 天从入门到精通 最大上传文件

最大上传文件体积,单位

体积

为 mb

limitSize

-   

number

limitFileType

-   

string

limit

-   

number

layout

vertical

限制上传文件 限制上传文件类型, 例如 类型

"jpg,mp4", 逗号分割

数量限制

限制输入标签的个数

STRING 标签

-   

multi=tru e

通用属性 表单

Form

M2O、O2O

标题排列方式: 水平 , vertical | 标题排列方式 横向, 控制整个表单的排

horizontal 列方式

no ne

通用属性

操作列显示数 表格操作列显示数量,1-5 inlineActiveCo 表格

Table

O2M、M2M 量

可选

3

defaultPageSiz

默认分页条数

表格分页默认分页条数

10,15, 30, 50, 30

e

Iframe

100, 200

-O i

Iframe 网

1, 2, 3, 4, 5

unt

STRING

通用属性

页

通用属性 Hyperli 超链接

STRING

克

nks

链接文字

Year、
------

杰

Date、

时间范围

超链接的展示标题

通用属性

DateTime、 Time

货币

-   

最大值

最大值

max

-   

number

最小值

最小值

min

-   

number

支持前缀

开启前缀

showPrefix

false

boolean

支持后缀

开启后缀

showSuffix

false

boolean

前缀类型

ICON: 图标; TEXT:文本

prefixType

-   

string

后缀类型

ICON: 图标; TEXT:文本

suffixType

-   

string

CURRENCY

239

Oinone7 天从入门到精通 前缀内容

文本内容或者图标引用名

prefix

-   

string

后缀内容

文本内容或者图标引用名

suffix

-   

string

显示千分位

显示千分位

showThousandth

false

boolean

保留小数位数

保留小数位数

precision

-   

number

allowClear

true

true

minLength

-   

number

maxLength

-   

number

pattern

-   

正则表达式

tips

校验失败

string

showCount

false

boolean

allowClear

true

true

设置输入框是否有一键清 显示清除按钮 除的按钮及功能
输入框填写数据时最少输 最小长度 入的长度值

no ne

输入框填写数据时最多输 最大长度

入的长度值

单行文本组件特有的属

性，通过规则校验内容， 输入格式

提供一些常用的，也支持 自定义校验正则

-O i

输入格式不通

输入格式不通过提示语

过

设置输入框是否显示字数

显示计数器

计数器

克

设置输入框是否有一键清

显示清除按钮

除的按钮及功能

-   

PHONE

支持前缀

开启前缀

showPrefix

false

boolean

杰

手机号

支持后缀

开启后缀

showSuffix

false

boolean

前缀类型

ICON: 图标; TEXT:文本

prefixType

-   

string

后缀类型

ICON: 图标; TEXT:文本

suffixType

-   

string

前缀内容

文本内容或者图标引用名

prefix

-   

string

后缀内容

文本内容或者图标引用名

suffix

-   

string

prefixStore

-   

boolean

前缀存储, 仅前缀类型为 前缀存储 文本可用

240

Oinone7 天从入门到精通 后缀存储, 仅后缀类型为 后缀存储

suffixStore

-   

boolean

minLength

-   

number

maxLength

-   

number

pattern

-   

正则表达式

tips

校验失败

string

showCount

false

boolean

allowClear

true

true

showPrefix

false

boolean

文本可用 输入框填写数据时最少输 最小长度 入的长度值
输入框填写数据时最多输 最大长度 入的长度值 单行文本组件特有的属
性，通过规则校验内容， 输入格式 提供一些常用的，也支持 自定义校验正则
输入格式不通 输入格式不通过提示语 过 设置输入框是否显示字数

no ne

显示计数器

计数器

设置输入框是否有一键清 显示清除按钮

除的按钮及功能

-   

EMAIL

支持前缀

开启前缀

-O i

邮箱

开启后缀

showSuffix

false

boolean

前缀类型

ICON: 图标; TEXT:文本

prefixType

-   

string

后缀类型

ICON: 图标; TEXT:文本

suffixType

-   

string

前缀内容

文本内容或者图标引用名

prefix

-   

string

杰

克

支持后缀

文本内容或者图标引用名

suffix

-   

string

prefixStore

-   

boolean

suffixStore

-   

boolean

后缀内容

前缀存储, 仅前缀类型为 前缀存储 文本可用 后缀存储, 仅后缀类型为 后缀存储
文本可用

表 3-25 字段组件大全 （五）字段可选系统 Widget 组件名称

支持视图类型 支持 ttype

说明

\*代表统配 widget

\*代表统配 ViewType，

Table

241

Oinone7 天从入门到精通 \* OneToMany

ViewType.Table

表格默认 O2M 组件

ManyToMany

ViewType.Table

表格默认 M2M 组件

\[TableO2MFieldWidget\]

-   

图片上传 UploadImg ManyToMany

ViewType.Table

往往用于跟 PamirsFile 对象

\[TableM2MUploadImgFieldWidget\] 关联的时候 图片上传 UploadImg ManyToOne

ViewType.Table

往往用于跟 PamirsFile 对象

TableM2OUploadImgFieldWidget 关联的时候 Image String

ViewType.Table

把字段值当 url 展示图片

Boolean

ViewType.Table

表格默认的 Boolean 组件

Enum

ViewType.Table

表格默认的 Enum 组件

ViewType.Table

表格默认的 Float 组件

\[TableStringImageFieldWidget\]

\[TableBooleanFieldWidget\] * \[TableEnumFieldWidget\] * Float

-   \[TableIntegerFieldWidget\]
-   -   

Integer

ViewType.Table

表格默认的 Integer 组件

Long

ViewType.Table

表格默认的 Long 组件

String

ViewType.Table

表格默认的 String 组件

Year

ViewType.Table

表格默认的 Year 组件

Boolean

ViewType.Search

搜索默认的 Boolean 组件

DateTime

ViewType.Search

搜索默认的 DateTime 组件

克

\[TableLongFieldWidget\]

-O i

\[TableFloatFieldWidget\]

no ne

-   

\[TableStringFieldWidget\] \*

杰

\[TableYearFieldWidget\]

Search

-   \[SearchBooleanSelectFieldWidget\]
-   \[SearchRangeDateTimeFieldWidget\]

Form

ViewType.Form, Checkbox Boolean

ViewType.Search,

\[FormBooleanCheckboxFieldWidget\] ViewType.Detail ViewType.Form, \*

Form\Search\Detail 默认的 Boolean

ViewType.Search,

\[FormBooleanFieldWidget\]

Boolean 组件，Radio 形式 ViewType.Detail

242

Oinone7 天从入门到精通 ViewType.Form, Switch

Boolean

ViewType.Search, ViewType.Detail ViewType.Form,

-   

Form\Search\Detail 默认的 Currency

ViewType.Search,

\[FormMoneyFieldWidget\]

Currency 组件 ViewType.Detail

-   

ViewType.Form,

Form\Detail 默认的

ViewType.Detail

Date 组件

ViewType.Form,

Form\Detail 默认的

ViewType.Detail

Date 组件

Date \[FormDateFieldWidget\] \* DateTime \[FormDateTimeFieldWidget\]

ViewType.Form, RangeDatePickerTime

DateTime ViewType.Detail

Enum \[FormEnumFieldWidget\]

no ne

ViewType.Form, \*

Form\Search\Detail 默认的

ViewType.Search,

Enum 组件

ViewType.Detail ViewType.Form,

-   Float \[FormFloatFieldWidget\]

Form\Search\Detail 默认的

ViewType.Search,

Float 组件

ViewType.Detail

HTML

-O i

RichText

所有 viewType 的 HTML 字段都

-   

可以配 RichText

ViewType.Form,

-   

Integer

\[FormIntegerFieldWidget\]

Form\Search\Detail 默认的

ViewType.Search, Integer\Currency 组件

Select

杰

-   

克

ViewType.Detail

ViewType.Search ViewType.Form,

Form\Detail 默认的

ViewType.Detail

ManyToMany 组件

ManyToMany

\[FormM2MTableFieldWidget\]

Upload

ViewType.Form,

ManyToMany

ViewType.Form, ManyToMany ViewType.Detail ViewType.Form,

UploadImg

ManyToMany ViewType.Detail

Form

ViewType.Form, ManyToOne

\[FormM2OFormFieldWidget\]

ViewType.Detail ViewType.Form,

Select、\*

ViewType.Search,

Form\Search\Detail\Table

ViewType.Detail,

默认的 ManyToOne 组件

ManyToOne ViewType.Table ViewType.Form,

SSConstructSelect ManyToOne

ViewType.Search,

\[FormM2OConstructSelectFieldWidget ViewType.Detail

243

Oinone7 天从入门到精通 Upload

ViewType.Form, ManyToOne

\[FormM2OUploadFieldWidget\]

ViewType.Detail ViewType.Form,

UploadImg

ManyToOne ViewType.Detail

-   ManyToOne

ViewType.Table

Table 默认的 ManyToOne 组件

\[TableM2OFieldWidget\]

-   

ViewType.Form, Map

Form\Detail 默认的 Map 组件

FormMapFieldFormFieldWidget

ViewType.Detail

Select

ViewType.Form, OneToMany

\[FormO2MFieldSelectWidget\]

ViewType.Search

Table

ViewType.Form,

no ne

OneToMany \[FormO2MFieldWidget\]

ViewType.Detail ViewType.Form,

-   

Related \[FormRelatedFieldWidget\]

Form\Search\Detail 默认的

ViewType.Search,

Related 组件

ViewType.Detail ViewType.Form,

String

ViewType.Search,

-O i

Email

ViewType.Detail ViewType.Form,

-   

String

\[FormStringFieldWidget\]

ViewType.Search,

杰

Password

克

ViewType.Detail

Phone

String

String

ViewType.Form, ViewType.Search, ViewType.Detail ViewType.Form,
ViewType.Search, ViewType.Detail

VerificationCode

String

ViewType.Form

DomainExpGenerator

Text

ViewType.Form

ViewType.Form, \*

Form\Search\Detail 默认的 Text

ViewType.Search,

\[FormTextFieldWidget\]

Text 组件 ViewType.Detail

-   

ViewType.Form, Time

\[FormTimeFieldWidget\]

ViewType.Detail

-   

ViewType.Form, Year

\[FormYearPickerControlWidget\]

ViewType.Search

244

Oinone7 天从入门到精通 Detail

-   Boolean

ViewType.Detail

Detail 默认的 Boolean 组件

Currency

ViewType.Detail

Detail 默认的 Currency 组件

DateTime

ViewType.Detail

Detail 默认的 DateTime 组件

Enum

ViewType.Detail

Detail 默认的 Enum 组件

Float

ViewType.Detail

Detail 默认的 Float 组件

\[DetailBooleanFieldWidget\] * \[DetailCurrencyFieldWidget\] *
\[DetailDateTimeFieldWidget\] * \[DetailEnumFieldWidget\] *

-   HTML \[DetailHtmlFieldWidget\]
-   ID \[DetailIdFieldWidget\]
-   

no ne

\[DetailFloatFieldWidget\]

Integer

Select \[DetailM2MSelectFieldWidget\]

Select

杰

-   

ViewType.Detail

Detail 默认的 ID 组件

ViewType.Detail

Detail 默认的 Integer 组件

ManyToMany

ViewType.Detail

ManyToMany

ViewType.Detail

克

UploadImg

Detail 默认的 HTML 组件

-O i

\[DetailIntegerFieldWidget\]

ViewType.Detail

OneToMany

ViewType.Detail

String

ViewType.Detail

Detail 默认的 String 组件

Text

ViewType.Detail

Detail 默认的 Text 组件

Time

ViewType.Detail

Detail 默认的 Time 组件

Year

ViewType.Detail

Detail 默认的 Year 组件

\[DetailStringFieldWidget\] \*

\[DetailTextFieldWidget\] * \[DetailTimeFieldWidget\] *
\[DetailYearFieldWidget\]

表 3-26 字段可选系统 Widget （六）字段属性配置

l 常规字段 field 通用属性 1) Table 字段通用属性 配置项

可选值

默认值

作用

245

Oinone7 天从入门到精通 label

string

displayName

widget

string

independentlyEditable

true、false

展示中文名称

见上方的 widget，字段组件类型

false

是否启用单字段编辑

表 3-27 Table 字段通用属性 2)

Form 字段通用属性 配置项

可选值

默认值

作用

no ne

基础校验

pattern

前端正则校验

maxValue

最大值

最小值

-O i

minValue

maxLength

false

最小长度

required

true、false、string

invisible

杰

克

minLength

最大长度

是否必填

true、false、string

false

是否隐藏

readonly

true、false、string

false

是否只读

字段状态：自读、是否可见

字段数据处理：数据源过滤、计算、默认值

defaultValue

-   

前端默认值

domain

string

rsql 表达式

compute

string

计算值

246

Oinone7 天从入门到精通 其他配置 展示中文名称

label

string

hint

string

一些字段的说明性文字

widget

string

见上方的 widget，字段组件类型

colSpan

number

1

true、

list 的默认 true

是否支持多值

false

其他为 false

针对枚举、o2m、m2m、m2o

mutil

displayName

false 为不展示 label

字段在表单一行中所占比例 具体看布局的配置

3)  

no ne

表 3-28 Form 字段通用属性 关系字段扩展配置

关系字段展示的形态更多，在通用和 form
的配置基础上，我们也增加了一些场景的配 置形态，满足更多的业务场景。
可选值

默认值

-O i

配置项

作用

Select 类组件配置

4)  

separator 连接

string

杰

separator

searchField

展示字段以

string

克

labelField

string

搜索所用的字段

表 3-29 关系字段扩展配置

搜索字段通用属性 配置项

可选值

默认值

作用

true、

list 的默认 true

是否支持多值

false

其他为 false

针对枚举、o2m、m2m、m2o

label

string

displayName

domain

string

mutil

blank

true、 false

展示中文名称 false 为不展示 label rsql 表达式

false

是否加入自选搜索字段

247

Oinone7 天从入门到精通 operator

见【rsql 操作符】

根据 ttype 默认推断

搜索 filter 特有

表 3-30 搜索字段通用属性 A.

举例 mutil 和 operator

针对 mutil 和 operator
进行举例，因为我们经常会碰到两种场景，这两个配置就非常 有用： a.
mutil：单选的枚举值要在搜索框中选择多个值进行过滤，如订单状态枚举，我们
搜索要搜索已下单未支付和已支付未发货的两种状态时就非常有必要； b.
operator：默认 ttype 为 string，搜索的时候都是以 like
为操作符，但对于一些 数据量比较大的表，我们希望走=或者单边 like
就可以派上用场了。 Step1 新增 PetTalentSexEnum 枚举类

no ne

①

Step2 新增 PetFile 模型

杰

克

②

-O i

图 3-354 新增 PetTalentSexEnum 枚举类

③

图 3-355 新增 PetFile 模型

Step3 修改 PetTalent 模型

248

no ne

Oinone7 天从入门到精通

Step4 修改宠物达人表格视图的 Template 中 search 部分

杰

克

④

-O i

图 3-356 修改 PetTalent 模型

图 3-357 修改宠物达人表格视图的 Template 中 search 部分 ⑤

Step5 重启看效果

249

Oinone7 天从入门到精通 我们看到发起的请求中 name
变成了==，而性别可以下拉多选并以 or 拼接。在 Action
的类型一文中【ViewAction 高级参数 filter 和 domain(举例)】的宠物达人 2
菜单针对 name 配置 domain = "name =like= '老'"将无效。

图 3-358 查看宠物达人 2 菜单 l

视图中字段间的联动

杰

克

-O i

no ne

字段联动需求主要在于：数据处理、展示处理和数据校验等字段间相互动态作用，其他
复杂的联动需要自定义字段的 widget，如平台提供的 SSConstructSelect。
数据处理：通过字段的数据处理相关属性配置来完成如 domain、compute；
展示处理：通过字段的数据展示相关属性配置来完成如 invisible、readonly；
数据校验：通过字段的基础校验相关属性配置来完成如 required。 A. domain
的举例 我们经常在 o2m 和 m2m 中的 filter 或 field 会设置 domain
来过滤数据，但是如何在设
置过滤条件时用上其他字段的值呢？在【框架之网关协议-后端占位符】一文中我们在过滤
条件中用上了后端占位符，这个在日常开发中也很有用。言归正传我们来看“过滤条件时用
上其他字段的值”的例子吧。 ① Step1 修改宠物达人的表格视图的 Template 中
search 部分 我们给 petShops 字段的 domain 设置成 createUid ==
\${activeRecord.creater.id}， 表示该字段的可选范围取决于 creater
字段，activeRecord 为前端内置关键字，获取当前 操作记录。

图 3-359 给 petShops 字段的 domain 设置成 createUid ==
\${activeRecord.creater.id}

250

Oinone7 天从入门到精通 ②

Step2 重启看效果

no ne

图 3-360 查看宠物达人列表页

图 3-361 查看宠物达人列表页 compute 的举例

-O i

B.

字段的值通过 compute 计算而来，这里： Step1 为 PetTalent 增加一个 nick
字段

克

①

②

杰

图 3-362 为 PetTalent 增加一个 nick 字段

Step2 修改 PetTalent 的 Form 视图增加下面代码

图 3-363 修改 PetTalent 的 Form 视图 ③

Step3 重启看效果

我们发现昵称的值会跟着达人字段变化而变化

251

Oinone7 天从入门到精通

图 3-364 昵称的值会跟着达人字段变化而变化

invisible、readonly、required 的配置方式均与 compute
类似，感兴趣的小伙伴可自

l

no ne

行体验 通过自定义组件进行联动(SSConstructSelect)

杰

克

-O i

目前对于复杂的联动需要自定义
widget，在值变化时提交数据到后端，然后拿到后端
返回值进行其他字段的赋值操作。 这里举例 SSConstructSelect
组件，它在值变化的时候会调用后端 constructMirror
的函数，并把对象返回的值进行赋值。 ① Step1 新增 PetTalentAction
类，并增加一个 constructMirror 函数

图 3-365 新增 PetTalentAction 类

②

Step2 在 PetTalent 的 form 视图指定 widget

widget【SSConstructSelect】有两个属性配置 a. submitFields
提交后端请求时会带上字段列表，默认为：当前配置字段 b. responseFields
请求返回值后会影响的字段列表，默认为：影响所有字段

图 3-366 在 PetTalent 的 form 视图指定 widget ③

Step3 重启看效果

选择创建者，后端会把达人改成了 Oinone，而昵称又通过前端 compute 计算为
Oinone 252

Oinone7 天从入门到精通

图 3-367 查看展示效果 l

前端上下文关键字 说明

举例

no ne

关键字

activeRecord

当前对象

字段间联动之 domain 的举例

在视图嵌套的情况下，子视图需要

rootRecord

根对象

用到父视图数据，则可以通过 rootRecord 来获取字段数据

在弹出框时需要用到打开者对象数

scene

打开者对象

据时，则可以用 openerRecord 来获

-O i

openerRecord

取父窗口对象数据

当前页面的 viewAction.name

二、视图的配置

克

表 3-31 前端上下文关键字

杰

视图的大致配置我们在【构建第一个
view】的时候已经介绍过，这里主要介绍视图层
的基本属性配置，这些配置会透传给视图内的组件
Widget，组件会根据配置内容做出不同 的呈现样式。 l 视图的配置 1. Table
的配置 配置项

可选值

默认值

作用

表格上方动作区默认展示操 activeCount

number

5

作的数量，超过个数的操作将 被折叠收起 表格最右侧操作列默认展示

inlineActiveCount

number

3

操作的数量，超过个数的操作 将被折叠收起

defaultPageSize

number

30

表格默认分页条数

表 3-32 Table 的配置 253

Oinone7 天从入门到精通 2.

Form/Detail 的配置 配置项

可选值

默认值

作用

direction

horizontal/vertical （大小写不明感）

vertical

表单标题排列方式

表 3-33 1.Table 的配置 l

Table 的配置项举例

（一）Step1 修改宠物达人的表格视图

no ne

我们在宠物达人的自定义表格视图的 Template 文件中增加三个属性配置
activeCount="1" 、inlineActiveCount="1"、 defaultPageSize="1"。

杰

克

（二）Step2 重启看效果

-O i

图 3-368 在宠物达人的自定义表格视图的 Template 文件中增加三个属性配置

图 3-369 重启看效果 l Form 的配置举例 （一）Step1 修改宠物达人的表单视图
我们在宠物达人的自定义表格视图的 Template 文件中增加一个属性配置
direction = "horizontal" 。
另：宠物达人在之前的教程中增加了一些字段，大家利用默认视图把新增字段也展示出
来。还是通过数据库查看默认页面定义，找到 base\_view 表，过滤条件设置为
Model

254

Oinone7 天从入门到精通 ='demo.PetTalent' and name ='formView'，查看
template 字段，把里面涉及新增字段复 制到 pet\_talent\_form.xml 文件中。

图 3-370 增加一个属性配置 direction = "horizontal"

-O i

no ne

（二）Step2 重启看效果

图 3-371 重启看效果

三、布局的配置

杰

克

布局是将页面拆分成一个一个的小单元，按照上下中左右进行排列。 （一）前沿
在前端领域中，布局可以分为三大块「Float、Flex、Grid 」，Float
可以说的上是上
古时期的布局了，如今市面还是很少见的，除了一些古老的网站。
目前，平台主要支持通过配置 XML 上面的 cols 和 span
来进行布局。平台也同样支持自 由布局，合理的使用 row、col、containers 和
container 四个布局容器相关组件，将可以
实现各种类型的布局样式，换句话说，平台实现的自由布局功能是 Flex 和 Grid
的结合体。 这里主要是讲解 Flex 和 Grid
布局，以及目前新的模板布局实现的思路。 （二）Flex 布局 Flex
布局采用的是一维布局，那么什么是一维布局呢，所谓的一维布局就是只有一个
方向、没有体积、面积，比如一条直线。它适合做局部布局，就像我们原来的顶部菜单、面
包屑导航，以及现在的主视图字段配置。

255

Oinone7 天从入门到精通

克

-O i

no ne

图 3-372 Flex 布局

杰

图 3-373 Flex 布局

图 3-374 Flex 布局 从上图可以看看出，Flex 布局只能在 X、Y
轴进行转换，它无法对上下左右四个方向同
时处理，因为它没“面积”的概念。所以它最适合做局部布局。 l 优点

256

Oinone7 天从入门到精通

图 3-375 Flex 兼容性

no ne

Flex 的兼容性，可以看得出来，目前主流的浏览器都支持该属性。所以 Flex
兼容性强， 如果你想对局部做布局处理，Flex 是最好选择。 l 缺陷
刚刚也提到了，用户想要的布局是千奇百怪的，如果他想要的布局在现有的功能中无法
实现怎么办？让用户放弃？还是说服他使用现在的布局。 （三）Grid 布局

杰

克

-O i

Grid
布局系统采用的是二维布局，二维布局有四个方向：上、下、左、右，它只有面
积没有体积，比如一张纸、网格。

图 3-376 Grid 布局概览

257

no ne

Oinone7 天从入门到精通

杰

克

-O i

图 3-377 HTML 模式布局

图 3-378 CSS 模式布局

从上图（图 3-376、图 3-377 及图
3-378）的代码可以看出（了解详情可移至浏览器参
见页面：https://codepen.io/tangqianhua/embed/ZEORpxe）：Grid
天生的支持整体布局，
它甚至可以移行换位，它的强大之处可以颠覆你对布局的认知。 l 缺陷 虽然
Grid 很强大，但是它有一个致命的缺陷，那就是兼容性。

258

Oinone7 天从入门到精通

图 3-379 Grid 的兼容性 从上图可以看出，IE10 以下、Chrome56
以下、Firefox51 以下等等都不支持该属性。 （四）平台布局 1. 名词解释

杰

克

-O i

no ne

① 布局容器相关组件：row 、col 、containers 和 container
这四个组件的统称。 ② 基础布局属性：包括 cols 、colSpan、span 和 offset。
2. 概述 一般的，我们对大多数组件提供了基本的布局属性配置，包括： ①
cols：将内容区中的每行拆分的列数；当前元素未配置该属性时，将取离当前元素
最近父元素属性。默认：1 ②
colSpan：当前元素相对于父元素在每行中所占列比例；优先于 span。默认：FULL
a. FULL：1 b. HALF：1/2 c. THIRD：1/3 d. TWO\_THIRDS：2/3 e.
QUARTER：1/4 f. THREE\_QUARTERS：3/4 ③
span：当前元素相对于父元素在每行中所占列数。默认：cols ④
offset：当前元素相对于原所在列的偏移列数。 我们规定了默认栅格数为
24，基础布局属性均是相对于默认栅格数而言的。
在使用基础布局属性时，请尽可能保证公式(24 / cols) \* span
以及以下列举的公式， 其计算结果为整数，否则可能出现不符合预期的结果。
在使用 colSpan 时，span 的计算公式为：span = cols \* colSpan 在使用
offset 时，offset 的计算公式为：offset = (24 / cols) \* offset 3.
平台内置组件 下面列举了平台内置组件在 Form 和 Detail
视图中使用时所支持的布局相关属性，包括 可能影响部分区域显隐的相关属性。
表头说明： ① tag：xml 配置标签 ② widget：组件名称；xml
属性；多个值属于别称。如：widget="form" ③ 配置项：xml 属性名称。 ④
可选值：声明支持的配置项属性类型，不可识别或不可解析时将采用默认值。 ⑤
作用：对配置项的简单描述，部分布局属性在上方进行了描述，不再赘述。 tag

widget

配置项

可选值

默认值

作用

259

Oinone7 天从入门到精通 view

cols

number

1

cols

number

1

colSpan

enum

FULL

span

number

cols

offset

number

cols

number

no ne

form

colSpan

enum

FULL

span

number

cols

offset

number

-O i

detail

element

DateTimeRangePicke

colSpan

enum

FULL

span

number

cols

杰

克

r

DateRangePicker

TimeRangePicker

1

offset

number

colSpan

enum

FULL

span

number

cols

offset

number

colSpan

enum

FULL

span

number

cols

offset

number

colSpan

enum

FULL

260

Oinone7 天从入门到精通 span

number

cols

offset

number

colSpan

enum

FULL

span

number

cols

offset

number

cols

number

YearRangePicker

任意

no ne

field

colSpan

enum

FULL

span

number

cols

offset

number

-O i

fieldset/group

title

标题；空字符 string

分组

串或不填，则 隐藏标题区；

number

1

colSpan

enum

FULL

span

number

cols

offset

number

cols

number

克

cols

tabs

杰

pack

1

1 标题；必填；

tab title

string

选项页

空字符串或不 填则显示默认 值；

cols

number

1

row align

top/middle/botto m

垂直对齐方式

261

Oinone7 天从入门到精通 start/end/center justify

/space-around/sp

水平对齐方式

ace-between number,number? gutter

示例： 24 = 24,24

24,24

水平/垂直间 距

12,12 boolean

true

cols

number

1

colSpan

enum

FULL

no ne

wrap

number

offset

number

-O i

col

span

克

mode/widthType

杰

cols

align

manual/full

是否允许换行

cols

偏移单元格数 列模式；手动/ 自动填充；使 manual

用自动填充 时，将忽略 span、offset 属性；

number

1

top/middle/botto

垂直对齐方式

m start/end/center

justify

containers

/space-around/sp

水平对齐方式

ace-between number,number? gutter

示例： 24 = 24,24

0,24

水平/垂直间 距

12,12 wrap

boolean

true

cols

number

1

colSpan

enum

FULL

是否允许换行

container

262

Oinone7 天从入门到精通 span

number

offset

number

align

cols

偏移单元格数

top/middle/botto

垂直对齐方式

m start/end/center

justify

/space-around/sp

水平对齐方式

ace-between number,number? gutter

示例： 24 = 24,24

0,24

水平/垂直间 距

no ne

12,12 wrap

manual/full

-O i

mode/widthType

boolean

true

是否允许换行 列模式；手动/ 自动填充；使

full

用自动填充 时，将忽略 span、offset 属性；

表 3-34 平台内置组件

克

4.  基础布局

杰

基础布局提供了在不使用任何布局容器相关组件的情况下，仅使用
cols、span、offset 这三个属性控制行列的布局能力。 其本质上是 flex
布局的扩展，但依旧无法脱离 flex 布局本身的限制，即元素始终是自
上而下、自左向右紧凑的。 下面将使用 fieldset 和 tabs/tab
组件来介绍各个属性在实际场景中的使用。 (1) 示例 1：默认撑满一行

图 3-380 示例 1：默认撑满一行 l

结果展示

263

Oinone7 天从入门到精通 图 3-381 结果展示 (2) 示例 2：一行两列：cols=2;
colSpan=HALF/span=1

no ne

l

图 3-382 示例 2：一行两列：cols=2; colSpan=HALF/span=1 结果展示

图 3-383 结果展示

(3) 示例 3：使用 offset 实现中间空一个字段空间的布局

图 3-384 使用 offset 实现中间空一个字段空间的布局 结果展示

杰

l

克

-O i

PS：offset 的作用有限，offset
最优实践的前提是在同一行中进行偏移，要实现特殊
布局功能，请使用自由布局相关布局能力。

图 3-385 结果展示 (4) 示例 4：属性 cols 就近取值

264

Oinone7 天从入门到精通 图 3-386 示例 4：属性 cols 就近取值 l

结果展示

图 3-387 示例 4-1 结果展示

克

-O i

no ne

图 3-388 示例 4-1 结果展示

图 3-389 实例 4：tab 属性生效

5.  自由布局

杰

自由布局提供了无法通过基础布局能力实现的其他布局能力，总的来说，自由布局是对
grid 布局和 flex 布局的结合，它既拥有 grid
布局对页面进行单元格拆/合的能力，在每个 单元格中，使用 flex
布局进行紧凑排列。 下面将使用 fieldset
组件介绍各个属性在实际场景中的使用。 (1) 组件组合
row/col：两个组件共同形成行和列，在一行中拆分成 24
个栅格，每个列的跨度不超过 24。当一行中，所有列的跨度和超过 24
时，将会自动换行。
containers/row/container：三个组件共同形成一个二维网格，以此实现 grid
布局的 基本能力。每个单元格（container）中使用 flex 布局。
PS：以下示例为了体现布局效果，可能会出现重复字段定义，业务上在使用时需要避免
这种定义。 (2) 示例 1：仅使用 1/2 左侧空间 小贴士：在使用 row 和 col
组合时，如果在一个 col 中有且仅有一个子元素，则 col 可以缺省。col
相关属性可以配置在该子元素上。

265

no ne

Oinone7 天从入门到精通

结果展示

克

l

-O i

图 3-390 示例 1

杰

图 3-391 结果展示

(3) 示例 2：使用布局容器实现中间空一个字段空间的布局

图 3-392 使用布局容器实现中间空一个字段空间的布局

266

Oinone7 天从入门到精通 l

结果展示

图 3-393 结果展示

杰

克

-O i

no ne

(4) 示例 3：一行 5 列（基础布局属性公式无法计算出整数的情况）

图 3-394 一行 5 列（基础布局属性公式无法计算出整数的情况） l

结果展示

图 3-395 结果展示 (5) 示例 4：共 2 行/1 行 3 列/1 行 2 列

该示例可以使用任何一种组件组合都可以实现，结果一致。

267

杰

克

-O i

no ne

Oinone7 天从入门到精通

图 3-396 示例 4 l

结果展示

图 3-397 结果展示

268

Oinone7 天从入门到精通 (6) 示例 5：布局容器的垂直居中

左侧容器高度被子元素撑开，右侧容器在垂直方向居中

结果展示

-O i

l

no ne

图 3-398 设置布局容器的垂直居中

6.  举例

克

图 3-399 结果展示

杰

这里拿 PetTalent
举例，仿造教程上面效果，除了例子中的效果，自己可以做更多的尝 试。 ①
Step1 修改 PetTalent 的 form 视图如下 给 creater 字段增加一个属性配置
offset="1"

图 3-400 给 creater 字段增加一个属性配置 offset="1" ②

Step2 重启看效果

269

Oinone7 天从入门到精通

图 3-401 实际展示效果 ③

Step3 修改 PetTalent 的 form 视图如下

杰

克

-O i

no ne

给基础信息增加一个属性 cols="4"，给 name 字段增加一个属性 span="2"，给
creater 和 nick 字段增加一个属性 span="1"：

图 3-402 修改 PetTalent 的 form 视图

④

Step4 重启看效果

图 3-403 查看实际效果

四、动作的配置 在【Action 的类型】一文中，我们介绍 Action
的几种类型，以及组合动作。 （一）通用配置 270

Oinone7 天从入门到精通 配置项

可选值

默认值

作用

name

动作名称

label

显示名称

icon

图标 primary

type

default

primary

按钮类型样式，支持主要样式、次要样式以及链 接样式。

link default success warning

default

danger info true invisible

按钮业务样式，支持成功（green）、警告（yellow）、

no ne

bizStyle

false

false

展示规则，有简单的 true/false 显隐，也支持复 杂的表达式

-O i

condition

危险（red）、信息（grey）四种样式。

是否禁用

自动推断规则：

当上下文类型为【单行】时，相当于使用表达式

true disabled

false

型进行自动推断

杰

克

condition

根据动作上下文类

disabledTitle

string

LIST\_COUNT(context.activeRecords) != 1

当上下文类型为【多行】时，相当于使用表达式
LIST\_COUNT(context.activeRecords) &lt;= 1

当上下文类型为【单行或多行】时，相当于使用 表达式
LIST\_COUNT(context.activeRecords) ==

根据动作上下文类 型进行自动推断

0 禁用悬浮提示

表 3-35 动作通用配置 （二）二次确认配置

二次确认框默认支持两种模式，对话框和气泡框； 1. 对话框

图 3-404 对话框提示

271

Oinone7 天从入门到精通 2.

气泡框

图 3-405 气泡框警告 配置项 配置项

可选值

confirm

string

confirmType

默认值

POPPER（气泡提示框） MODAL（对话框） TM（按钮上方） BM（按钮下方）
LM（按钮左侧）

备注

二次确认提示文字

配置后开启二次确认

POPPER

确认框类型

BM

确认框位置

确定

确定按钮文字

取消

取消按钮文字

-O i

confirmPosition

作用

no ne

3.  

气泡框该配置生效

enterText

cancelText

克

RM（按钮右侧）

杰

表 3-36 配置项

（三）弹出层动作配置（窗口动作 ViewAction）
目前平台对于弹出层支持了两种展示形式。弹窗（modal/dialog）和抽屉（drawer）
支持两种配置方式【内嵌视图配置】和【引用已有页面】，内嵌视图配置优先于引用已
有页面。 1. 内嵌视图配置 该配置对于弹窗和抽屉均适用。

272

Oinone7 天从入门到精通

图 3-406 内嵌视图配置 2.

引用已有页面配置

-O i

no ne

该配置对于弹窗和抽屉均适用。

克

图 3-407 引用已有页面示例

图 3-408 引用已有页面

3.  

弹窗

杰

当窗口动作的路由方式（target）为 dialog
时，内嵌视图/引用页面将以弹窗形式展示 在页面上。 l 配置项 配置项

可选值

默认值

作用

title

string

动作名称

标题名称

medium

宽度

string/number/enum width

small（560px） medium（890px） large（1200px）

表 3-37 弹窗配置项 l

示例：配置标题名称为自定义创建弹窗，宽度为 70%的弹窗

273

no ne

Oinone7 天从入门到精通

图 3-409 内嵌视图配置 4.

抽屉

配置项

可选值

title

string

placement

默认值

作用

动作名称

标题名称

克

top（上）

-O i

当窗口动作的路由方式（target）为 drawer
时，内嵌视图/引用页面将以弹窗形式展示 在页面上。 l 配置项

right（右）

bottom（下）

备注

right

抽屉打开位置

small

宽度

打开位置为 left 和 right 时生效

small

宽度

打开位置为 top 和 bottom 时生效

杰

left（左）

string/number/enum

width

small（20%）

medium（40%） large（80%）

string/number/enum height

small（20%） medium（40%） large（80%）

表 3-38 抽屉配置项 l

示例：配置从下方打开，高度为 large 的抽屉

274

no ne

Oinone7 天从入门到精通

5.  

组合动作配置

-O i

图 3-410 配置从下方打开，高度为 large 的抽屉

具体例子参见 Aciton 的类型一文中介绍的【前端动作之组合动作】
服务器动作串行

②

杰

克

①

图 3-411 服务器动作串行

服务器动作与跳转动作组合执行

图 3-412 服务器动作与跳转动作组合执行 ③

后端动作与前端动作组合

275

Oinone7 天从入门到精通

图 3-413 后端动作与前端动作组合 6.

展示规则

-O i

no ne

我在 Action 的类型一文中介绍 【ServerAction 之前端展示规则(举例)】 ，
用到 invisible 这个属性定义。这个在 xml
中也可以配置，而且前端的优先级高于后端 可以通过 invisible
属性配置一个表达式来使动作根据数据记录条件显示、隐藏。 如果 invisible
所引用的动作的 bindingType 是个列表型视图，则要用 context.activeRecords
获取当前选中记录，如果是个对象型视图或列表型视图的行内显示 则需用
context.activeRecord：

图 3-414 列表型视图

（四）举例 Table 视图动作配置

l

示例 1：不允许删除编码为“5”的数据

克

1.  

杰

PS：当配置 disabled
时，自动推断规则将会失效，需要按需配置。下方的配置保留了
单行或多行的自动推断规则。

图 3-415 Table 视图动作配置 l 结果展示 ① 未选中时

276

Oinone7 天从入门到精通

图 3-416 未选中时 ②

选中编码不是“5”的数据

-O i

no ne

在【Action 的类型】一文中，我们介绍 Action 的几种类型，以及组合动作。

选中编码包含“5”的数据

杰

③

克

图 3-417 选中编码不是“5”的数据

图 3-418 选中编码包含“5”的数据 2.

Form 视图动作配置

l

示例：创建和编辑使用同一个视图配置

277

杰

克

-O i

no ne

Oinone7 天从入门到精通

图 3-419 创建和编辑使用同一个视图配置

l 结果展示 ① 使用上下文无关的跳转动作进入该视图时

图 3-420 使用上下文无关的跳转动作进入该视图时 ②

使用【单行】的跳转动作进入该视图时

278

Oinone7 天从入门到精通

图 3-421 使用单行的跳转动作进入该视图时 （五）实战 ①

Step1 修改宠物商品代理表格视图的 Template

杰

克

-O i

no ne

启用和禁用服务器动作根据状态分别显示其中一个

图 3-422 修改宠物商品代理表格视图的 Template

②

Step2 重启看效果

【已启用】状态时只显示【禁用】按钮

图 3-423 已启用状态时只显示禁用按钮 279

Oinone7 天从入门到精通 【已禁用】状态时只显示【启用】按钮

图 3-424 已禁用状态时只显示启用按钮

no ne

n 3.5.7 前端组件自定义(初级篇)

Application

Token

杰

名称

克

-O i

在日常的开发过程中因为个性化的业务与交互诉求，出现原有组件无法满足的情况，在
这种情况下一般需要前端研发介入进行新组件开发，然后交由后端研发进行对应的视图配置。
在前端组件自定义系列文章中我们主要介绍如何开发组件，组件匹配规则。
在字段的配置一文中简单提到过【字段的匹配规则】，里面介绍了平台默认提供的组件
在匹配规则中用到了
viewType、ttype，widget，实际上平台匹配规则会更丰富，还是拿字
段组件来说平台支持：字段 id(id),字段名(name),视图类型(viewType),视图
Id(viewId),
视图名称(viewName),字段类型(ttype),组件名(widget),模型名(Model,前端用模型名，而
非编码)。 按 widget
最优权重匹配，其他按最大匹配原则、后注册优先原则，我们就可以灵活应
用于不同场景。下图为：平台提供的组件匹配的扩展点机制，大家先有一个简单认知，我们
马上开始。

ROOT\_TOKEN

描述

静态 token 由平台提供 Application 为应用入口 动态 Token，为当前视图组

View

ViewWidget.Token 构造

Field

FieldWidget.Token 构造 动态 Token，当前字段组件

Action

件

筛选(匹配)条件

无

id,name,type,Model,widget

id,name,viewType,viewId,viewName ,ttype,widget,Model

ActionWidget.Token 构 动态 Token，当前的动作组
id,name,viewType,actionType,Mode 造

Group

GroupWidget.Token 构造

Adapter

BaseAdapter.Token 构造

件 动态 Token，XML 节点中的 Group 节点对应的组件 动态
Token，用于转换业务 数据类型

l,target widget

from,to

表 3-39 组件匹配机制

280

Oinone7 天从入门到精通
注：在本章节例子中如果标志（后端），是需要后端同学配合。Oinone
采用特色前后
端分离的开发模式，前端只有在组件不满足需求或者特色业务组件开发的时候进行前端专业
开发工作。这样既保留前后端分离架构带来的好处，同时减少了因为业务开发过程中前后端
不必要的沟通工作，极大地提升了效率。

一、自定义主题

克

-O i

no ne

在页面交互中，样式的变化也是前端的核心工作之一，在 Oinone
平台中，内置的基础
组件该如何影响？如何借用平台的能力写出“根据主题”变化的组件？接下来介绍自定义主
题相关的功能。 （一）自定义主题 1. 在项目 src 目录下，新建 theme.ts 文件

图 3-425 在项目 src 目录下，新建 theme.ts 文件 theme.ts
内部定义主题名称和 css 变量名(替换主色为例，将主色系替换成黑色)

杰

2.  

图 3-426 theme.ts 内部定义主题名称和 css 变量名 3.

在 main.ts 注册

281

no ne

Oinone7 天从入门到精通

图 3-427 在 main.ts 注册 刷新页面看效果

杰

克

-O i

4.  

图 3-428 刷新页面看效果 5.

完整代码

282

no ne

Oinone7 天从入门到精通

图 3-429 完整代码 （二）自定义组件如何使用主题变量

杰

克

-O i

l 以自定义页面为例【自定义表单】 ① theme.ts 添加变量

②

图 3-430 theme.ts 添加变量

修改 petForm.vue

283

杰

克

-O i

no ne

Oinone7 天从入门到精通

284

no ne

Oinone7 天从入门到精通

图 3-431 修改 petForm.vue 页面效果

杰

克

-O i

③

图 3-432 页面效果

（三）平台内置变量 (1) 基础 变量名

变量

默认值

primary-color

主色

035DFF
======

描述

主要色系，直接使用或者用它的透明度 色系 主要色系，
改变主色时需要同步更改。 和 primary-color 的区别是，作用场景

primary-color-rgb

主色 RGB

3, 93, 255

是主色的透明度百分比，比如 background:
rgba(var(--oio-primary-color-rgb), 285

Oinone7 天从入门到精通 0.1)

主色悬停

3F84FF
======

主色悬停色

primary-color-focus

主焦点

3F84FF
======

主焦点色

primary-color-active

主激活

024CDE
======

主激活色

primary-color-outline

主轮廓

035DFF
======

主轮廓色

success-color

成功

6DD400
======

成功色，用于表述正向反馈

success-color-hover

成功悬停

success-color-active

成功激活

success-color-outline

成功轮廓色

waring-color

警告

F7B500
======

警告色

waring-color-hover

警告悬停

F9C73D
======

警告悬停色

警告激活

D99200
======

警告激活色

警告轮廓

F7B500
======

警告轮廓色

info-color

通知

035DFF
======

通知色

info-color-hover

通知悬停

3F84FF
======

通知悬停色

info-color-active

通知激活

024CDE
======

通知激活色

info-color-outline

通知轮廓

035DFF
======

通知轮廓色

error-color

错误

E02020
======

错误色

error-color-hover

错误悬停

E75555
======

错误悬停色

90DE3D
======

成功悬停色

6BBB00
======

成功激活色

6DD400
======

成功轮廓色

-O i

杰

waring-color-outline

克

waring-color-active

no ne

primary-color-hover

286

Oinone7 天从入门到精通 错误激活

C51C26
======

错误激活色

error-color-outline

错误轮廓

E02020
======

错误轮廓色

body-background

内容区背景

F3F7FA
======

内容区背景色

search-background

搜索区背景

ffffff
======

搜索区背景色

header-background

头部区背景

ffffff
======

头部区背景色

main-background

主内容区背景

ffffff
======

主内容区背景色

footer-background

底部区背景

menu-background

菜单区背景

no ne

error-color-active

ffffff
======

底部区背景色

ffffff
======

菜单区背景色

-apple-system,

BlinkMacSystemFont,

-O i

'Segoe UI', Roboto, 'Helvetica Neue',

font-family

Arial,'Noto Sans',

默认字体

sans-serif, 'Apple

默认字体设置

克

Color Emoji', 'Segoe UI Emoji', 'Segoe UI

杰

Symbol','Noto Color Emoji';

text-color

主文字

rgba(0,0,0,0.85)

主文字色

text-color-rgb

主文字 RGB

38, 38, 38

主文字 RGB

text-color-secondary

次要文字

rgba(0,0,0,0.65)

次要文字色

font-size

基础文字

14px

基础文字

font-size-lg

大号文字

16px

大号文字

font-size-sm

小号文字

12px

小号文字

font-weight

默认加粗

400

默认加粗

287

Oinone7 天从入门到精通 加粗

bold

加粗

font-weight-bold

加粗系数

700

加粗系数

line-height

基础行高

18px

基础行高

line-height-lg

大号行高

20px

大号行高

line-height-sm

中号行高

16px

中号行高

line-height-xs

小号行高

14px

小号行高

line-height-xxs

最小号行高

border-radius

默认圆角

border-radius-lg

大号圆角

border-radius-sm

小号圆角

2px

小号圆角

border-color

边框颜色

e3e7ee
======

边框颜色

边框宽度

1px

边框宽度

边框风格

solid

边框风格

padding-lg

大号内间距

24px

大号内间距

padding-md

中号内间距

16px

中号内间距

padding-sm

小号内间距

12px

小号内间距

padding-xs

迷你内间距

8px

迷你内间距

padding-xxs

最小号内间距

4px

最小号内间距

margin-lg

大号外间距

24px

大号外间距

12px

最小号行高

4px

默认圆角

8px

大号圆角

-O i

杰

border-style

克

border-width

no ne

font-weight-thick

288

Oinone7 天从入门到精通 中号外间距

16px

中号外间距

margin-sm

小号外间距

12px

小号外间距

margin-xs

迷你外间距

8px

迷你外间距

margin-xxs

最小号外间距

4px

最小号外间距

height

基础高度

40px

基础高度

height-lg

大号高度

54px

大号高度

height-sm

小号高度

readonly-color

只读色

readonly-bg

只读背景色

readonly-active-bg

只读激活色

fcfcfc
======

只读激活色

readonly-border-color

只读边框色

e3e7ee
======

只读边框色

禁用色

rgba(0, 0, 0, 0.25)

禁用色

禁用背景色

fcfcfc
======

禁用背景色

disabled-active-bg

禁用激活色

fcfcfc
======

禁用激活色

disabled-border-color

禁用边框色

d9d9d9
======

禁用边框色

32px

小号高度

262626
======

只读色

fcfcfc
======

只读背景色

-O i

杰

disabled-bg

克

disabled-color

no ne

margin-md

表 3-39 平台内置变量基础 (2) 按钮 变量名

变量

默认值

描述

background

按钮背景色

ffffff
======

按钮背景色

border-width

边框宽度

1px

边框宽度

289

边框风格

solid

边框风格

border-color

边框颜色

d9d9d9
======

边框颜色

border-radius

圆角

4px

圆角

outline

轮廓

none

轮廓

shadow

阴影

none

阴影

text-color

文字颜色

rgba(0,0,0,0.85)

文字颜色

background-active

背景激活

ffffff
======

背景激活

border-width-active

激活边框宽度

1px

激活边框宽度

border-style-active

边框激活风格

solid

边框激活风格

border-color-active

-O i

border-style

no ne

Oinone7 天从入门到精通

激活边框颜色

d9d9d9
======

激活边框颜色

激活圆角

4px

激活圆角

激活轮廓

none

激活轮廓

激活阴影

none

激活阴影

text-color-active

文字激活色

rgba(0,0,0,0.85)

文字激活色

background-focus

聚焦背景色

ffffff
======

聚焦背景色

border-width-focus

聚焦边框宽度

1px

聚焦边框宽度

border-style-focus

聚焦边框风格

solid

聚焦边框风格

border-color-focus

聚焦边框颜色

d9d9d9
======

聚焦边框颜色

border-radius-focus

聚焦圆角

4px

聚焦圆角

outline-active

杰

shadow-active

克

border-radius-active

290

聚焦轮廓

none

聚焦轮廓

shadow-focus

聚焦阴影

none

聚焦阴影

text-color-focus

聚焦文字颜色

rgba(0,0,0,0.85)

聚焦文字颜色

background-hover

悬停背景色

ffffff
======

悬停背景色

border-width-hover

悬停边框宽度

1px

悬停边框宽度

border-style-hover

悬停边框风格

solid

悬停边框风格

border-color-hover

悬停边框颜色

d9d9d9
======

悬停边框颜色

border-radius-hover

悬停圆角

4px

悬停圆角

outline-hover

悬停轮廓色

none

悬停轮廓色

shadow-hover

悬停阴影色

none

悬停阴影色

悬停文字颜色

rgba(0,0,0,0.85)

悬停文字颜色

克

text-color-hover

-O i

outline-focus

no ne

Oinone7 天从入门到精通

悬停危险边框色

E02020
======

悬停危险边框色

background-visited

访问后背景色

ffffff
======

访问后背景色

border-width-visited

访问后边框宽度

1px

访问后边框宽度

border-style-visited

访问后边框风格

solid

访问后边框风格

border-color-visited

访问后边框颜色

d9d9d9
======

访问后边框颜色

border-radius-visited

访问后圆角

4px

访问后圆角

outline-visited

访问后轮廓

none

访问后轮廓

shadow-visited

访问后阴影

none

访问后阴影

杰

border-color-danger

291

访问后文字颜色

rgba(0,0,0,0.85)

访问后文字颜色

primary-background

主背景色

035DFF
======

主背景色

primary-border-width

主边框宽度

1px

主边框宽度

primary-border-style

主边框风格

solid

主边框风格

primary-border-color

主边框颜色

035DFF
======

主边框颜色

primary-border-radius

主圆角

4px

主圆角

primary-outline

主轮廓

none

主轮廓

primary-shadow

主阴影

none

主阴影

primary-text-color

主文字颜色

ffffff
======

主文字颜色

default-text-color

次要按钮文字颜 色

次要按钮边框宽 度

克

default-border-width

-O i

text-color-visit

no ne

Oinone7 天从入门到精通

primary-background-danger

危险背景色

杰

primary-border-color-danger 危险按钮边框色

primary-text-color-danger

default-text-color-danger

default-background-danger

default-border-width-danger

default-border-color-danger

link-background-danger

危险按钮文字色 次要危险按钮文 字颜色 次要危险按钮背 景颜色
次要危险按钮边 框宽度 次要危险按钮边 框颜色 文字危险按钮背 景色

035DFF
======

次要按钮文字颜色

1px

次要按钮边框宽度

E02020
======

危险背景色

E02020
======

危险边框色

ffffff
======

危险按钮文字色

E02020
======

危险按钮次要色

ffffff
======

次要危险按钮背景颜色

1px

次要危险按钮边框宽度

E02020
======

次要危险按钮边框颜色

none

文字危险按钮背景色

292

Oinone7 天从入门到精通

primary-border-color-info

primary-text-color-info

default-text-color-info

default-background-info

default-border-width-info

default-border-color-info

link-background-info

link-border-color-info

通知按钮背景颜 色 通知按钮边框颜 色 通知按钮文字颜 色 次要通知按钮文
字颜色 次要通知按钮背 景颜色 次要通知按钮边 框宽度

次要通知按钮边 框颜色

通知文字按钮背 景颜色

通知文字按钮边 框颜色

通知文字按钮文 字颜色

警告按钮背景颜

克

link-text-color-info

框颜色

primary-background-warning

色

警告按钮边框颜

杰

primary-border-color-warning

primary-text-color-warning

default-text-color-warning

default-background-warning

default-border-width-warning

default-border-color-warning

link-background-warning

none

文字危险按钮边框颜色

8c8c8c
======

通知按钮背景颜色

8c8c8c
======

通知按钮边框颜色

ffffff
======

通知按钮文字颜色

8c8c8c
======

次要通知按钮文字颜色

ffffff
======

次要通知按钮背景颜色

no ne

primary-background-info

文字危险按钮边

1px

次要通知按钮边框宽度

8c8c8c
======

次要通知按钮边框颜色

none

通知文字按钮背景色

-O i

link-border-color-danger

色

警告按钮文字颜 色

次要警告按钮文 字颜色 次要警告按钮背 景颜色 次要警告按钮边 框宽度
次要警告按钮边 框颜色 文字警告按钮背 景色

none

通知文字按钮边框颜色

8c8c8c
======

通知文字按钮文字颜色

F7B500
======

警告按钮背景颜色

F7B500
======

警告按钮边框颜色

ffffff
======

警告按钮文字颜色

F7B500
======

次要警告按钮文字颜色

F7B500
======

次要警告按钮背景颜色

1px

次要警告按钮边框宽度

F7B500
======

次要警告按钮边框颜色

none

文字警告按钮背景色

293

Oinone7 天从入门到精通

primary-background-success

primary-border-color-success

primary-text-color-success

default-text-color-success

default-background-success

default-border-width-success

default-border-color-success

link-background-success

文字警告按钮文 字颜色 成功按钮背景色 成功按钮边框颜 色 成功按钮文字颜 色
次要成功按钮文 字颜色 次要成功按钮背 景颜色

次要成功按钮边 框宽度

次要成功按钮边 框颜色

文字成功按钮背 景颜色

文字成功按钮边 框颜色

文字成功按钮文

克

link-border-color-success

框颜色

link-text-color-success

none

文字警告按钮边框颜色

F7B500
======

文字警告按钮文字颜色

6DD400
======

成功按钮背景色

6DD400
======

成功按钮边框颜色

ffffff
======

成功按钮文字颜色

6DD400
======

次要成功按钮文字颜色

no ne

link-text-color-warning

文字警告按钮边

ffffff
======

次要成功按钮背景颜色

1px

次要成功按钮边框宽度

6DD400
======

次要成功按钮边框颜色

-O i

link-border-color-warning

字颜色

none

文字成功按钮背景颜色

none

文字成功按钮边框颜色

6DD400
======

文字成功按钮文字颜色

主激活色

E02020
======

主激活色

primary-border-width-active

主激活边框色

024CDE
======

主激活边框色

primary-border-style-active 主激活边框风格

solid

主激活边框风格

primary-border-color-active 主激活边框颜色

1px

主激活边框颜色

primary-border-radius-active

主激活圆角

4px

主激活圆角

primary-outline-active

主激活轮廓

none

主激活轮廓

primary-shadow-active

主激活阴影

none

主激活阴影

杰

primary-background-active

294

Oinone7 天从入门到精通 primary-text-color-active

主激活文字颜色

ffffff
======

主激活文字颜色

primary-background-focus

主焦点背景色

E02020
======

主焦点背景色

024CDE
======

主焦点边框宽度

主焦点边框风格

solid

主焦点边框风格

primary-border-color-focus

主焦点边框风格

1px

主焦点边框风格

primary-border-radius-focus

主焦点圆角

4px

主焦点圆角

primary-outline-focus

主焦点轮廓

none

主焦点轮廓

primary-shadow-focus

主焦点阴影

none

主焦点阴影

primary-text-color-focus

主悬停文字色

E02020
======

主悬停文字色

primary-background-hover

主悬停背景

024CDE
======

主悬停背景

主悬停边框宽度

solid

主悬停边框宽度

克

primary-border-width-hover

-O i

primary-border-style-focus

no ne

primary-border-width-focus' 主焦点边框宽度

主悬停边框风格

1px

主悬停边框风格

primary-border-color-hover

主悬停边框颜色

4px

主悬停边框颜色

primary-border-radius-hover 主悬停边框圆角

none

主悬停边框圆角

杰

primary-border-style-hover

primary-outline-hover

住悬停轮廓

none

住悬停轮廓

primary-shadow-hover

主悬停阴影

E02020
======

主悬停阴影

primary-text-color-hover

主悬停文字色

024CDE
======

主悬停文字色

primary-background-visited

主访问后背景色

035DFF
======

主访问后背景色

024CDE
======

主访问后边框宽度

solid

主访问后边框风格

primary-border-width-visited

primary-border-style-visited

主访问后边框宽 度 主访问后边框风 格

295

Oinone7 天从入门到精通 primary-border-color-visited

色 主访问后边框圆 角

1px

主访问后边框颜色

4px

主访问后边框圆角

primary-outline-visited

主访问后轮廓

none

主访问后轮廓

primary-shadow-visited

主访问后阴影

none

主访问后阴影

E02020
======

主访问后文字颜色

transparent

链接按钮背景色

no ne

primary-border-radius-visited

主访问后边框颜

none

链接按钮边框宽度

none

链接按钮边框风格

none

链接按钮文字颜色

link-background

link-border-width

link-border-style

link-border-color

link-border-radius

link-shadow

色 链接按钮背景色 链接按钮边框宽 度

链接按钮边框风 格

链接按钮文字颜 色

链接按钮圆角

none

链接按钮圆角

链接轮廓

none

链接轮廓

none

链接按钮阴影

E02020
======

链接按钮文字颜色

transparent

链接按钮激活背景色

none

链接按钮激活边框宽度

none

链接按钮激活边框风格

none

链接按钮激活边框颜色

none

链接按钮激活圆角

none

链接按钮激活轮廓

克

link-outline

主访问后文字颜

-O i

primary-text-color-visit

链接按钮文字颜

杰

link-text-color

链接按钮阴影

link-background-active

link-border-width-active

link-border-style-active

link-border-color-active

link-border-radius-active

link-outline-active

色

链接按钮激活背 景色

链接按钮激活边 框宽度 链接按钮激活边 框风格 链接按钮激活边 框颜色
链接按钮激活圆 角 链接按钮激活轮 廓

296

Oinone7 天从入门到精通

link-background-focus

link-border-width-focus

link-border-style-focus

link-border-color-focus

link-border-radius-focus

link-outline-focus

link-shadow-focus

link-text-color-focus

链接按钮激活文 字颜色 链接按钮聚焦背 景色 链接按钮聚焦边 框宽度
链接按钮聚焦边 框风格 链接按钮聚焦边 框颜色 链接按钮聚焦圆 角

链接按钮聚焦轮 廓

链接按钮聚焦阴 影

链接按钮聚焦文 字颜色

链接按钮悬停背 景色

链接按钮悬停边

克

link-background-hover

影

link-border-width-hover

框宽度

链接按钮悬停边

杰

link-border-style-hover

link-border-color-hover

link-border-radius-hover

link-outline-hover

link-shadow-hover

link-text-color-hover

link-background-visited

none

链接按钮激活阴影

E02020
======

链接按钮激活文字颜色

transparent

链接按钮聚焦背景色

none

链接按钮聚焦边框宽度

none

链接按钮聚焦边框风格

none

链接按钮聚焦边框颜色

no ne

link-text-color-active

链接按钮激活阴

none

链接按钮聚焦圆角

none

链接按钮聚焦轮廓

none

链接按钮聚焦阴影

-O i

link-shadow-active

框风格

链接按钮悬停边 框颜色

链接按钮悬停圆 角 链接按钮悬停轮 廓 链接按钮悬停阴 影 链接按钮悬停文
字颜色 链接按钮选中后 背景

E02020
======

链接按钮聚焦文字颜色

transparent

链接按钮悬停背景色

none

链接按钮悬停边框宽度

none

链接按钮悬停边框风格

none

链接按钮悬停边框颜色

none

链接按钮悬停圆角

none

链接按钮悬停轮廓

none

链接按钮悬停阴影

E02020
======

链接按钮悬停文字颜色

transparent

链接按钮选中后背景

297

Oinone7 天从入门到精通 链接按钮选中后

link-border-width-visited

边框宽度 链接按钮选中后

link-border-style-visited

边框风格 链接按钮选中后

link-border-color-visited

边框颜色

link-border-radius-visited

link-shadow-visited

link-text-color-visit

圆角 链接按钮选中后 轮廓 链接按钮选中后 阴影 链接按钮选中后

链接按钮选中后边框宽度

none

链接按钮选中后边框风格

none

链接按钮选中后边框颜色

none

链接按钮选中后圆角

none

链接按钮选中后轮廓

none

链接按钮选中后阴影

no ne

link-outline-visited

链接按钮选中后

none

文字颜色

E02020
======

链接按钮选中后文字颜色

表 3-40 平台内置变量按钮 (3) 输入框 变量

默认值

background

背景色

ffffff
======

背景色

border-width

边框宽度

1px

边框宽度

border-color

边框颜色

描述

克

-O i

变量名

e3e7ee
======

border-radius

圆角

4px

圆角

outline

轮廓

none

轮廓

shadow

阴影

none

阴影

text-color

文字颜色

rgba(0,0,0,0.85)

文字颜色

line-height

行高

22px

行高

counter-background

计数区域背景色

ffffff
======

计数区块背景色

counter-color

计数器文字颜色

rgba(0, 0, 0, 0.25)

计数器文字颜色

杰

边框颜色

298

Oinone7 天从入门到精通 计数器文字大小

12px

计数器文字大小

background-hover

悬停背景颜色

ffffff
======

悬停背景颜色

border-width-hover

悬停边框宽度

1px

悬停边框宽度

border-style-hover

悬停边框风格

solid

悬停边框风格

border-color-hover

悬停边框颜色

3F84FF
======

悬停边框颜色

border-radius-hover

悬停边框圆角

4px

悬停边框圆角

outline-hover

悬停轮廓

shadow-hover

悬停阴影

text-color-hover

悬停文字颜色

background-focus

激活背景色

ffffff
======

激活背景色

border-width-focus

激活边框宽度

1px

激活边框宽度

激活边框风格

solid

激活边框风格

no ne

counter-font-size

悬停轮廓

none

悬停阴影

rgba(0,0,0,0.85)

悬停文字颜色

border-color-focus

克

-O i

none

激活边框颜色

3F84FF
======

激活边框颜色

border-radius-focus

激活圆角

4px

激活圆角

outline-focus

激活轮廓

none

激活轮廓

杰

border-style-focus

0px 0px 0px 2px rgba(3, 93, shadow-focus

激活阴影

255

激活阴影

,0.1); text-color-focus

激活文字颜色

rgba(0,0,0,0.85)

激活文字颜色

readonly-border-color

只读边框颜色

e3e7ee
======

只读边框颜色

error-border-color

异常边框颜色

ff4d4f
======

异常时边框颜色

299

Oinone7 天从入门到精通 disabled-border-color

只读边框颜色

d9d9d9
======

只读边框颜色

表 3-41 平台内置变量输入框 (4) 分页器 变量

默认值

描述

height

高度

32px

高度

item-width

分页器宽度

32px

分页器宽度

item-height

分页器高度

30px

分页器高度

no ne

变量名

表 3-42 平台内置变量分页器 (5) 下拉框

默认值

描述

背景色

ffffff
======

背景色

border-width

边框宽度

1px

边框宽度

border-color

边框颜色

e3e7ee
======

边框颜色

圆角

4px

圆角

杰

border-radius

克

background

变量

-O i

变量名

outline

轮廓

none

轮廓

shadow

阴影

none

阴影

text-color

文字颜色

rgba(0,0,0,0.85)

文字颜色

background-hover

悬停背景颜色

ffffff
======

悬停背景颜色

border-width-hover

悬停边框宽度

1px

悬停边框宽度

border-style-hover

悬停边框风格

solid

悬停边框风格

border-color-hover

悬停边框颜色

3F84FF
======

悬停边框颜色

300

Oinone7 天从入门到精通 悬停边框圆角

4px

悬停边框圆角

outline-hover

悬停轮廓

none

悬停轮廓

shadow-hover

悬停阴影

none

悬停阴影

text-color-hover

悬停文字颜色

rgba(0,0,0,0.85)

悬停文字颜色

background-focus

激活背景色

ffffff
======

激活背景色

border-width-focus

激活边框宽度

1px

激活边框宽度

border-style-focus

激活边框风格

border-color-focus

激活边框颜色

border-radius-focus

激活圆角

outline-focus

激活轮廓

no ne

border-radius-hover

激活边框风格

3F84FF
======

激活边框颜色

4px

激活圆角

-O i

solid

none

激活轮廓

0px 0px 0px 2px

激活文字颜色

杰

text-color-focus

激活阴影

克

shadow-focus

rgba(3, 93, 255

激活阴影

,0.1);

rgba(0,0,0,0.85)

激活文字颜色

readonly-border-color

只读边框颜色

e3e7ee
======

只读边框颜色

error-border-color

异常边框颜色

ff4d4f
======

异常时边框颜色

disabled-border-color

只读边框颜色

d9d9d9
======

只读边框颜色

item-readonly-radius

选项只读圆角

4px

选项只读圆角

表 3-43 平台内置变量输入框 (6) 多行文本 变量名

变量

默认值

描述

background

背景色

ffffff
======

背景色

301

Oinone7 天从入门到精通 边框宽度

1px

边框宽度

border-color

边框颜色

e3e7ee
======

边框颜色

border-radius

圆角

4px

圆角

outline

轮廓

none

轮廓

shadow

阴影

none

阴影

text-color

文字颜色

rgba(0,0,0,0.85)

文字颜色

background-hover

悬停背景颜色

border-width-hover

悬停边框宽度

border-style-hover

悬停边框风格

border-color-hover

悬停边框颜色

3F84FF
======

悬停边框颜色

border-radius-hover

悬停边框圆角

4px

悬停边框圆角

悬停轮廓

none

悬停轮廓

悬停阴影

none

悬停阴影

text-color-hover

悬停文字颜色

rgba(0,0,0,0.85)

悬停文字颜色

background-focus

激活背景色

ffffff
======

激活背景色

border-width-focus

激活边框宽度

1px

激活边框宽度

border-style-focus

激活边框风格

solid

激活边框风格

border-color-focus

激活边框颜色

3F84FF
======

激活边框颜色

border-radius-focus

激活圆角

4px

激活圆角

ffffff
======

悬停背景颜色

1px

悬停边框宽度

solid

悬停边框风格

-O i

杰

shadow-hover

克

outline-hover

no ne

border-width

302

Oinone7 天从入门到精通 outline-focus

激活轮廓

none

激活轮廓

0px 0px 0px 2px rgba(3, shadow-focus

激活阴影

93, 255

激活阴影

,0.1); text-color-focus

激活文字颜色

rgba(0,0,0,0.85)

激活文字颜色

表 3-44 平台内置变量多行文本 (7) 文件上传 变量

默认值

描述

background

背景色

ffffff
======

背景色

border-width

边框宽度

1px

边框宽度

border-color

边框颜色

e3e7ee
======

边框颜色

shadow

4px

圆角

轮廓

none

轮廓

阴影

none

阴影

文字颜色

rgba(0,0,0,0.85)

文字颜色

杰

text-color

-O i

outline

圆角

克

border-radius

no ne

变量名

background-hover

悬停背景颜色

ffffff
======

悬停背景颜色

border-width-hover

悬停边框宽度

1px

悬停边框宽度

border-style-hover

悬停边框风格

solid

悬停边框风格

border-color-hover

悬停边框颜色

3F84FF
======

悬停边框颜色

border-radius-hover

悬停边框圆角

4px

悬停边框圆角

outline-hover

悬停轮廓

none

悬停轮廓

shadow-hover

悬停阴影

none

悬停阴影

303

Oinone7 天从入门到精通 悬停文字颜色

rgba(0,0,0,0.85)

悬停文字颜色

background-focus

激活背景色

ffffff
======

激活背景色

border-width-focus

激活边框宽度

1px

激活边框宽度

border-style-focus

激活边框风格

solid

激活边框风格

border-color-focus

激活边框颜色

3F84FF
======

激活边框颜色

border-radius-focus

激活圆角

4px

激活圆角

outline-focus

激活轮廓

no ne

text-color-hover

none

激活轮廓

0px 0px 0px 2px rgba(3,

shadow-focus

激活阴影

93, 255

激活阴影

,0.1);

激活文字颜色

rgba(0,0,0,0.85)

激活文字颜色

-O i

text-color-focus

表 3-45 平台内置变量文件上传

二、自定义组件-字段

杰

克

字段的自定义是我们日常前端最长见的开发需求，我们平台目前管理页面组件库用的
antd，我们组件开发大部分就是基于 antd 的组件，用 vue+ts
的语法进行封装，并注册为我 们系统的组件。 （一）自定义字段组件的三部曲：
① 新建 XField.vue 来定义一个 vue 原生组件

图 3-433 新建 XField.vue 来定义一个 vue 原生组件 ② 新建 XFieldWidget.ts
封装成 Oinone 的组件， 依赖@kunlun/dependencies 包提供的 SPI
机制实现，匹配规则见【本系列文章的开篇介绍】

304

Oinone7 天从入门到精通

图 3-434 新建 XFieldWidget.ts 封装成 Oinone 的组件

no ne

③ 注册

图 3-435 注册

-O i

（二）第一个自定义字段组件

杰

克

接下来一步一步地去自定义一个千分位展示的金额字段组件，感受下字段组件开发过程。
① Step1 （前端）新建 currency 目录
在开始前回顾下我们的【前端工程结构】，我们前端工程的 src/field 建一个
currency 目录,把自定义组件放到这个目录下：

305

杰

克

-O i

no ne

Oinone7 天从入门到精通

图 3-436 （前端）新建 currency 目录 ②

Step2 （前端）新建一个 vue 原生组件 ThousandthField.vue

1)  

使用 antd 的 a-input 组件

通过:value="valueStr"，让组件 value 跟 valueStr 进行绑定 通过
onThousandthFieldChange，onThousandthFieldFocus，onThousandthFieldBlur
分别监听组件的值变化、聚焦、失焦 2) 定义 vue 组件

306

Oinone7 天从入门到精通 a.props 定义接受从父组件传递过来的数据
b.setup(props)

杰

克

-O i

no ne

l transformThousandthStr 定义千分位转换逻辑 l watch 对 valueStr
第一次赋值 l onThousandthFieldChange，值变化时修改真正的 value l
onThousandthFieldFocus，获取焦点的时候把 valueStr，转换会 value l
onThousandthFieldBlur,失焦时把 valueStr 转化成千分位形式

307

克

-O i

no ne

Oinone7 天从入门到精通

③

杰

图 3-437 定义 vue 组件

Step3 （前端）新建 ThousandthFieldWidget.ts 封装成 Oinone 组件

1)  继承 FormFieldWidget
2)  initialize 为组件初始化方法
3)  通过 @SPI.ClassFactory(FieldWidget.Token({
    viewType:\[ViewType.Form,ViewType.Deta il,ViewType.Search\],ttype:
    \[ModelFieldType.Currency\],widget: 'ThousandthFieldWidget' }))
    来定义组件匹配规则：

<!-- -->

a.  viewType：ViewType.Form,ViewType.Detail,ViewType.Search
b.  ttype：ModelFieldType.Currency（对应后端@Field.Money）
c.  widget：ThousandthFieldWidget

308

-O i

no ne

Oinone7 天从入门到精通

图 3-438 （前端）新建 ThousandthFieldWidget.ts 封装成 Oinone 组件 Step4
（前端）注册 ThousandthFieldWidget

克

④

杰

修改 field 目录下 index.ts

图 3-439 修改 field 目录下 index.ts

⑤

Step5 （后端）修改 PetTalent 模型

增加一个年收入字段，ttype 定义为 Money，后端的 Money 对应前端 Currency

图 3-440 （后端）修改 PetTalent 模型 ⑥

Step6 （后端）修改 PetTalent 的 Form 视图的 Template 文件

增加 annualIncome 字段，把 widget 指定为 ThousandthFieldWidget

309

Oinone7 天从入门到精通

图 3-441 （后端）修改 PetTalent 的 Form 视图的 Template 文件 ⑦

Step7 重启系统看效果

no ne

图 3-442 重启系统看效果 （三）替换原有默认组件

杰

克

-O i

上面的例子是新增一个名叫 ThousandthFieldWidget 的匹配 ttype 为 Money
的字段组件， 如果我们希望把系统中所有的 Money
一般都替换成这个组件，而不是每个模型每个页面配置
过去。那么我们可以根据匹配规则来修改我们的组件代码就可以了。 ① Step1
（前端）修改 ThousandthFieldWidget.ts 的匹配规则 把原来的 widget:
'ThousandthFieldWidget' 改成 widget: \['ThousandthFieldWidget', '\*'\]。
a. \* 代表通配 b. 也可以删除 widget:
'ThousandthFieldWidget'，不定义也是通配 c. widget:
\['ThousandthFieldWidget', '\*'\] 即代表通配，同时也可以配置
ThousandthFieldWidget

310

Oinone7 天从入门到精通 图 3-443 （前端）修改 ThousandthFieldWidget.ts
的匹配规则 ②

Step2 （后端）修改 PetTalent 的 Form 视图

把 annualIncome 字段的 widget 配置去掉（widget="ThousandthFieldWidget"）

图 3-444 （后端）修改 PetTalent 的 Form 视图 ③

Step3 重启看效果

no ne

结果同上面 case （四）获取 xml 属性
在自定义组件过程中，可以针对不同的业务场景进行封装，一些通用的个性化需求，可
以沉淀在 xml 中。通过不同视图的 xml 配置，满足前端组件的个性化。

l

在组件的 ts 内获取

-O i

图 3-445 获取 xml 属性

图 3-446 在组件的 ts 内获取

克

当需要响应式时，在 ts 内部定义响应式变量赋值

杰

l

图 3-447 在 ts 内部定义响应式变量赋值 l

在对应的 vue 文件中获取

311

Oinone7 天从入门到精通 图 3-448 在对应的 vue 文件中获取
（五）值的提交和获取

在组件定义中，需要继承对应 ttype
的基类，基类中内置了值的提交、获取对应函数和 变量。值的提交和获取需要在
ts 文件中操作，字段对应的值默认是响应式变量。 1)

值提交

在 ts 文件中：

图 3-449 在 ts 文件中 值获取

no ne

2)  

注意，this.value
是异步赋值，如果业务中需要对值进行操作，需要判空和处理异常 的情况。

三、自定义组件-动作

-O i

图 3-450 值获取

杰

克

在日常开发中经常也会碰到自定义一些前端动作的需求。自定义动作有两个核心概念一
是定义前端 Action，二是定义前端 Action
的组件。这个跟其他自定义组件不大一样，比如
自定义字段组件，字段本身已经是存在的，但自定义前端 Action
组件，首先得确保前端 Action 存在，不存在得先定义前端 Action。
（一）第一个动作组件
前端自定义一个全新前端动作组件只要简单的几步，下面例子为构建一个
DoNothingActionWidget 动作组件。 ① Step1 （前端）Action 目录规范
在开始前回顾下我们的【前端工程结构】，我们前端工程的 src/action
目录,把自定义 组件放到这个目录下：

312

Oinone7 天从入门到精通 图 3-451（前端）Action 目录规范 ②

Step2 （前端）新建 DoNothingActionWidget 组件

杰

克

-O i

no ne

1)  定义前端 Action 的组件 DoNothingActionWidget 继承 ActionWidget
2)  用@SPI.ClassFactory(ActionWidget.Token({ name: 'demo.doNothing'
    }))来定 义组件匹配规则

<!-- -->

a.  name：demo.doNothing

<!-- -->

3)  用 Action.registerAction 定义前端 Action

<!-- -->

a.  -   //\*为模型通配符，可指定模型

b.  displayName: '啥也没干', //动作展示名
c.  name: 'demo.doNothing', //动作技术名称
d.  id: 'demo.doNothing', //动作组件 id
e.  contextType: ActionContextType.ContextFree, //设置动作上下文类型
f.  bindingType: \[ViewType.Table\] //设置按钮所在页面类型

图 3-452 （前端）新建 DoNothingActionWidget 组件 ③

Step3 （前端）注册 DoNothingActionWidget 组件

修改 action 目录下 index.ts

图 3-453 修改 action 目录下 index.ts

313

Oinone7 天从入门到精通 ④

Step4 （后端）修改 PetTalent 表格视图的 Template

图 3-454 （后端）修改 PetTalent 表格视图的 Template Step5 重启看效果

no ne

⑤

图 3-455 重启看效果

-O i

（二）覆盖平台动作（举例一）

杰

克

字段的 Widget 可以替换，Action 的 Widget
同样可以替换，今天我们就来写一个自定 义动作 Widget
来覆盖特定动作的前端逻辑。 ① Step1 （前端）新建 DeletePetTalentWidget.ts
在 src/action/delete 目录下新建 DeletePetTalentWidget.ts 文件， 用于给
PetTalent 模型的列表的删除加个二次确认：

314

杰

克

-O i

no ne

Oinone7 天从入门到精通

图 3-456 （前端）新建 DeletePetTalentWidget.ts ②

Step2 （前端）注册 DeletePetTalentWidget 组件

修改 action 目录下 index.ts

315

Oinone7 天从入门到精通

图 3-457 （前端）注册 DeletePetTalentWidget 组件 Step3 重启看效果

no ne

③

-O i

图 3-458 重启看效果

（三）覆盖平台动作（举例二）

杰

克

再举一个在创建页面中【确认】按钮的自定义动作 Widget
来覆盖原有动作的前端逻辑。 ① Step1 新建 CreatePetServer.ts 给 PetTalent
模型的表单添加一个自定义提交的动作

316

克

-O i

no ne

Oinone7 天从入门到精通

②

杰

图 3-459 新建 CreatePetServer.ts

Step2（前端）注册 CreatePetServer

修改 action 目录下 index.ts

图 3-460（前端）注册 CreatePetServer

四、自定义视图-表格
我们了解了字段、动作组件的自定义，在学习核心内容区的自定义也就比较轻松，基本
思路跟字段组件自定义是一样一样的，马上开始。
（一）自定义字段组件的三部曲 ① 新建 XView.vue 来定义一个 vue 原生组件
317

Oinone7 天从入门到精通

图 3-461 新建 XView.vue 来定义一个 vue 原生组件

杰

克

-O i

no ne

② 新建 XViewWidget.ts 封装成 Oinone 的组件，依赖@kunlun/core 包提供的
SPI 机制实 现，匹配规则见【本系列文章的开篇介绍】

图 3-462 新建 XViewWidget.ts 封装成 Oinone 的组件

318

Oinone7 天从入门到精通 ③ 注册

图 3-463 注册 （二）第一个自定义 View 组件

杰

克

-O i

no ne

接下来为 PetTalent 模型一步一步地去自定义一个 Card 模式展示的表格 view
组件，感 受下视图组件开发过程。 ① Step1 （前端）新建 pet 目录
在开始前回顾下我们的【前端工程结构】，找到我们前端工程的 src/view
目录,新建 pet 目录把自定义组件放到这个目录下。

图 3-464 （前端）新建 pet 目录 ②

Step2 （前端）新建一个 vue 原生组件 PetTypeCardView.vue

319

杰

克

-O i

no ne

Oinone7 天从入门到精通

图 3-465 （前端）新建一个 vue 原生组件 PetTypeCardView.vue ③

Step3 （前端）新建 PetTypeCardViewWidget.ts 封装成 Oinone 组件

1)  继承 TableWidget，复用表格能力
2)  initialize 为组件初始化方法
3)  通过 @SPI.ClassFactory(ViewWidget.Token({ type:
    \[ViewType.Custom,ViewType.Table\],
    widget:'PetTypeCard'}))来定义组件匹配 规则：

<!-- -->

a.  viewType：ViewType.Custom,ViewType.Table 320

Oinone7 天从入门到精通

杰

克

-O i

no ne

b.  widget：PetTypeCard

图 3-466 （前端）新建 PetTypeCardViewWidget.ts 封装成 Oinone 组件 ④

Step4（ 前端）自定义一个 Layout 并注册为只影响宠物品种模型的 Table 视图
新建 Register.ts 文件， 通过 registerLayout
函数注册为只影响宠物品种模型的 Table 视图，如果 moduleName 和 Model
不配置则会影响所有的模型 Table 视图的默认 Layout。

321

-O i

no ne

Oinone7 天从入门到精通

图 3-467（ 前端）自定义一个 Layout 并注册为只影响宠物品种模型的 Table
视图

Step5 （前端）注册 PetTalentCardViewWidget

克

⑤

杰

修改 view 目录下 index.ts

图 3-468 （前端）注册 PetTalentCardViewWidget

⑥

Step6 （前端）重启系统看效果

我们看的品种列表的表格已经发生变化

图 3-469 （前端）重启系统看效果 （三）第一个自定义的大数据表格 ① Setp1
(前端) 新建 virtual-table 目录 322

Oinone7 天从入门到精通

图 3-470 (前端) 新建 virtual-table 目录 ②

Step2 （前端）新建一个 vue 原生组件 VirtualTable.vue

杰

克

-O i

no ne

新增打印、导出、搜索、聚合等功能，若需要其它复杂功能，请查阅第三方文档自行定
制。

323

杰

克

-O i

no ne

Oinone7 天从入门到精通

324

杰

克

-O i

no ne

Oinone7 天从入门到精通

图 3-471 （前端）新建一个 vue 原生组件 VirtualTable.vue

③

Step3 （前端）新建 VirtualTable.ts 封装成 Oinone 组件

1)  继承 ViewWidget
2)  initialize 为组件初始化方法
3)  通 过 @SPI.ClassFactory(CustomWidget.Token({
    widget:'VirtualTable'})) 来 定义组件匹配规则：

<!-- -->

a.  widget：VirtualTable

325

杰

克

-O i

no ne

Oinone7 天从入门到精通

图 3-472 （前端）新建 VirtualTable.ts 封装成 Oinone 组件 ④

Step4（ 前端）自定义一个 Layout 并注册为只影响宠物店铺代理模型 A 模型的
Table

视图

326

Oinone7 天从入门到精通

no ne

新建 Register.ts 文件，通过 registerLayout
函数注册为只影响宠物店铺代理模型 A 的 Table 视图，如果 moduleName 和
Model 不配置则会影响所有的模型 Table 视图的默认 Layout。

⑤

-O i

图 3-473（前端）自定义一个 Layout 并注册为只影响宠物店铺代理模型 A
模型的 Table 视 图 Step5 （前端）注册 VirtualTable

克

修改 view 目录下 index.ts

⑥

杰

图 3-474（前端）注册 VirtualTable

Step6（前端）重启系统看效果

327

Oinone7 天从入门到精通 图 3-475 （前端）重启系统看效果

五、自定义视图-表单

no ne

前文说到如何自定义宠物达人表格，在中后台管理系统中，表单也是重要的组成部分。
那么本文会教大家如何结合平台自定义表单 （一）Step1 （前端）新建 petForm
目录 新建 petForm 目录把自定义组件放到 src/view 目录下

图 3-476 新建 petForm 目录把自定义组件放到 src/view 目录下

杰

克

-O i

（二）Step2 （前端）新建一个 vue 原生组件 PetForm.vue

328

杰

克

-O i

no ne

Oinone7 天从入门到精通

图 3-477 （前端）新建一个 vue 原生组件 PetForm.vue （三）Step3
（前端）新建 PetFormViewWidget.ts 封装成 Oinone 组件

① 继承 FormWidget，复用表单能力

329

Oinone7 天从入门到精通

杰

克

-O i

no ne

② initialize 为组件初始化方法 ③ 通过
@SPI.ClassFactory(CustomWidget.Token({ widget:'PetForm'}))来定义组
件匹配规则： a. widget：PetForm

330

杰

克

-O i

no ne

Oinone7 天从入门到精通

331

-O i

no ne

Oinone7 天从入门到精通

克

图 3-478 （前端）新建 PetFormViewWidget.ts 封装成 Oinone 组件
（四）Step4（ 前端）自定义一个 Layout 并注册为只影响宠物品种模型的 Form
视图

杰

新建 Register.ts 文件，通过 registerLayout
函数注册为只影响宠物品种模型的 Form 视图，如果 moduleName 和 Model
不配置则会影响所有的模型 Form 视图的默认 Layou。

图 3-479 （ 前端）自定义一个 Layout 并注册为只影响宠物品种模型的 Form
视图 （五）Step5（前端）注册 PetFormViewWidget 332

Oinone7 天从入门到精通 修改 view 目录下 index.ts

图 3-480 （前端）注册 PetFormViewWidget （六）Step6 (前端) 重启系统

-O i

no ne

前端刷新页面，点击宠物品种的创建按钮进入表单

图 3-481 前端刷新页面，点击宠物品种的创建按钮进入表单

六、自定义 Mask

杰

克

本文讲述如何替换已有的 mask，和添加自己的 mask 组件。以菜单放到 header
区域为例。 （一）自定义 Mask 组件 ① Step1 （前端）新建 mask 目录 新建
mask 目录把自定义组件放到 src/mask 目录下

图 3-482 新建 mask 目录把自定义组件放到 src/mask 目录下 ②

Step2 （前端）新建一个 vue 原生组件 CustomMaskComponent.vue

333

杰

克

-O i

no ne

Oinone7 天从入门到精通

334

no ne

Oinone7 天从入门到精通

图 3-483 （前端）新建一个 vue 原生组件 CustomMaskComponent.vue

克

-O i

MenuItem 组件

杰

l

335

杰

克

-O i

no ne

Oinone7 天从入门到精通

336

-O i

no ne

Oinone7 天从入门到精通

图 3-484 MenuItem 组件

Step3 （前端）新建 CustomMaskComponent.ts 封装成 Oinone 组件

克

1)  通 过 @SPI.ClassFactory(ViewWidget.Token({
    widget:'CustomMaskComponent'})) 来 定 义 组件匹配规则：

<!-- -->

a.  widget：CustomMaskComponent

杰

③

337

杰

克

-O i

no ne

Oinone7 天从入门到精通

338

杰

克

-O i

no ne

Oinone7 天从入门到精通

339

杰

克

-O i

no ne

Oinone7 天从入门到精通

340

杰

克

-O i

no ne

Oinone7 天从入门到精通

图 3-485 （前端）新建 CustomMaskComponent.ts 封装成 Oinone 组件 ④

Step4 （前端）注册 CustomMaskComponent

1)  修改 mask 目录下 index.ts

图 3-486 修改 mask 目录下 index.ts 2) main.ts 引入

图 3-487 main.ts 引入 ⑤

Step5 修改 mask 341

-O i

no ne

Oinone7 天从入门到精通

⑥

Step6

杰

前端刷新页面

克

图 3-488 修改 mask

图 3-489 前端刷新页面 （二）默认 Mask 1.

系统内置 Mask

系统内置的 Mask xml，多 tab 栏默认放在顶部是基于一下几点考虑: 1) Oinone
Mask 替换范围是页面、应用、整体； 342

Oinone7 天从入门到精通

no ne

2)  页面、应用定制灵活度高。

图 3-490 系统内置 Mask

-O i

页面效果

杰

克

l

图 3-491 页面效果 2.

替换多 tab 栏位置

当只有单应用时，大部分场景多 tab 栏放在 header 下方，本示例给出了多 tab
栏的另 一种展示形式的页面配置。有更多展示方式，可自由调整多 tab
栏的位置，配合 block 和 content 任意组合。

343

no ne

Oinone7 天从入门到精通

页面效果

杰

克

l

-O i

图 3-492 替换多 tab 栏位置

图 3-493 页面效果

第 4 章 Oinone 的高级特性
高级特性一章中主要介绍元数据的详细构成以及相关高级特性，比如事务、异步、网络
协议、分布式注意事项等等的详细介绍。 1. 后端的高级特性 344

Oinone7 天从入门到精通 2. 前端的高级特性 3. Oinone 分布式体验及进阶体验
4. 研发辅助：结构性代码及 SQL 优化

4.1 后端高级特性 了解 Oinone
的基础入门基本上可以胜任业务代码的开发，但对于构建一个完善的应用，
作为技术专家或者架构需要考虑的方面还有很多，这章期望能给到您解答构建应用的所有所
需知识，让您能成为那个可以带领小伙伴飞的人。

n 4.1.1 模块之 yml 文件结构详解

一、pamirs.boot 1.

pamirs.boot.init

-O i

no ne

本节是对 demo 的 boot 工程的 application-*.yml 文件关于 Oinone
相关配置的扩充讲 解，大家可以先通读留个影响，以备不时之需。
在基础入门的模块一章中大家构建，并通过启动前后应用，直观地感受到我们自己建的
demo 模块。在上述过程中想必大家都了解到我们 Oinone 的 boot
工程是专门用来做应用启
动管理，它完全没有任何业务逻辑，它只决定启动哪些模块、启动方式、以及相关配置。它
跟 Spring Boot 的一个普通工程没有什么差异。所有我们只要看
application-*.yml 文件， Oinone 提供了哪些特殊配置就能窥探一二。
这里主要介绍 pamirs 路径下的核心以及常用的配置项：

杰

克

①
描述：启动加载程序，是否启动元数据、业务数据和基础设施的加载与更新程序，
在应用启动时同时对模块进行生命周期管理 ② true \#\#标准版，只支持 true 2.
pamirs.boot.sync ①
描述：同步执行加载程序，启动时对模块进行生命周期管理采用同步方式 ② true
\#\#标准版，只支持 true 3. pamirs.boot.modules ①
描述：启动模块列表。这里只有 base 模块是必须的。为了匹配我们的前端模版，
在 demo
的例子中加入了其他几个通用业务模块。当然这些通用业务模块也是可以大大
降低大家的开发难度以及提升业务系统的设计质量 ② - base \#Oinone
的基础模块 ③ - common \#Oinone 的一些基础辅助功能 ④ - sequence
\#序列的能力 ⑤ - resource \#基础资源如 ⑥ - user \#基础用户 ⑦ - auth
\#权限 ⑧ - message \#消息 ⑨ - international \#国际化 ⑩ - business
\#商业关系 11 - file \#文件，demo
里没有默认加入，如果要开发导入导出相关功能，可以对应 引入改模块

345

Oinone7 天从入门到精通

no ne

12 - …… 还有很多通用业务模块以及这些模块的详细介绍，我们在介绍【Oinone
的 通用能力】的章节去展开 4. pamirs.boot.mode ①
dev：不走缓存，可以直接修改元数据。特别是我们在说页面设计的时候，可以修
改 base\_view 表直接生效不需要重启系统。 l 配置举例

图 4-1 pamirs.boot.mode 配置举例

-O i

二、pamirs.boot.profile 与 pamirs.boot.options

可选项

克

pamirs.boot.option, 在 pamirs.boot.options
中可以自定义可选项，也可以根据 pamirs.boot.profile
属性来指定这些可选项，pamirs.boot.profile 属性的默认值为 CUSTOMIZE。只有
pamirs.boot.profile=CUSTOMIZE 时，才能在 pamirs.boot.options 中自
定义可选项。 说明

是否加载存储在数据库中的模

杰

reloadModule

块信息

默认值

AUTO

READONLY

PACKAGE

DDL

false

true

true

true

true

checkModule

校验依赖模块是否安装

false

true

true

true

true

loadMeta

是否扫描包读取模块元数据

true

true

false

true

true

false

true

true

true

true

true

true

false

true

true

true

true

false

true

true

false

true

false

true

false

reloadMeta

computeMeta

editMeta

diffMeta

是否加载存储在数据库中元数 据 是否重算元数据
编辑元数据，是否支持编程式编 辑元数据 差量减计算元数据

346

Oinone7 天从入门到精通 刷新元数据缓存

true

true

true

true

true

rebuildHttpApi

刷新重建前后端协议

true

true

true

false

false

diffTable

差量追踪表结构变更

false

true

false

true

false

rebuildTable

更新重建表结构

true

true

false

true

false

printDDL

打印重建表结构 DDL

false

false

false

false

true

publishService

发布服务，是否发布远程服务

true

true

true

false

false

updateModule

分布式模块管理

updateMeta

no ne

refreshSessionMeta

初始化与更新元数据，是否将元 数据的变更写入数据库

false

true

false

true

false

false

true

false

true

false

true

true

false

true

false

初始化与更新内置业务数据，是 updateData

否将内置业务数据的变更写入

-O i

数据库 params

扩展参数

可自定义 可自定义 可自定义 可自定义 可自定义

克

表 4-1 pamirs.boot.options 列表

杰

可以在启动日志中可查看当前服务启动可选项：

图 4-2 在启动日志中查看当前服务启动可选项

三、pamirs.meta 347

Oinone7 天从入门到精通 1. pamirs.meta.metaPackages ① 描 述 ： 自 定 义
元 模 型 的 所 在 包 路 径 。 标 准 版 只 能 是
pro.shushi.pamirs.trigger.Model 2. 配置举例

图 4-3 pamirs.meta 配置举例

四、pamirs.framework 1.

pamirs.framework.gateway \#graphql 的可选项配置

杰

克

-O i

no ne

① pamirs.framework.gateway.show-doc \#是否对外提供 gql 的 scheme
文档查询能力， 在【构建第一个 Module 的 DemoMoudel
启动一节】中之所以可以用 Insomnia 开查看后端的 文档，就是这里要配置为
true ② pamirs.framework.gateway.statistics \#用于收集 DataLoader
执行过程中的状态， 比如缓存命中多少次，已经 load 了多少个对象，有多少次
error 等 2. pamirs.framework.hook ① pamirs.framework.hook.ignoreAll
\#默认为 false，为 true 忽略掉所有 hook 函 数 ②
pamirs.framework.hook.excludes \#排除掉部分 hook 函数 ③
pamirs.framework.data \#这个经常会使用到，大家一定要了解 ④
pamirs.framework.data.default-ds-key \# 模 块 的 默 认 数 据 库 key ，
对 应 pamirs.datasource 配置 ⑤ pamirs.framework.data.ds-map
\#为模块指定数据库 key， 对应 pamirs.datasource 配置。在 demo
中我们如果要为 demo\_core 这个模块配置独立数据库就可以在这里配置如
demo\_core: demo,并在 pamirs.datasource 配置 key 为 demo 的数据源 3.
pamirs.framework.system ① pamirs.framework.system.system-ds-key \# 元 数
据 系 统 对 应 的 数 据 源 ， 对 应 pamirs.datasource 配置 ②
pamirs.framework.system.system-Models \# 视 为 元 数 据 模 型 ， 一 起
放 到 system-ds-key 库 4. 配置举例

348

Oinone7 天从入门到精通

no ne

图 4-4 pamirs.framework 配置举例

五、pamirs.dialect.ds

克

-O i

1.  描述：pamirs.datasource 中数据源的方言信息，以 key 为对应。
2.  子参数有：type（默认：MySQL），version（默认：8.0），majorVersion（默认：
    8）
3.  配置举例

杰

图 4-5 pamirs.dialect.ds 配置举例

六、pamirs.datasource

1.  描述：安装模块所需要的数据源配置
2.  配置举例

349

-O i

no ne

Oinone7 天从入门到精通

图 4-6 pamirs.datasource 配置举例

克

七、pamirs.sharding

杰

1.  描述 Oinone 的分库分表配置，当使用 pamirs-trigger-bridge-tbschedule
    工程开 启内置 schedule 功能时必须配置
2.  配置举例 - demo 参考【框架之分库分表】

350

杰

克

-O i

no ne

Oinone7 天从入门到精通

？？？图 4-7 pamirs.sharding 配置举例

351

Oinone7 天从入门到精通 八、pamirs.mapper 1. 库配置：可以通过 YAML
的“pamirs.mapper.<global 或者 ds>”配置项进行库配置。
如果未配置，系统会采用默认值。 配置项

默认值

描述

databaseFormat

`%s`

库名格式化

tableFormat

`%s`

表名格式化

tablePattern

%s

动态表名表达式

表 4-2 库配置

no ne

2.  表配置：可以通过 YAML
    的“pamirs.mapper.<global 或者 ds>.table-info”配置
    项或者@Model.Persistence 注解进行表配置。注解优先级大于 YAML
    配置文件配置。如 果未配置，系统会采用默认值。 默认值

描述

logicDelete

true

是否逻辑删除

is\_delete

逻辑删除字段名

logicDeleteValue

REPLACE(unix\_timestamp(NOW(6)),'.','')

逻辑删除值

logicNotDeleteValue

0

非逻辑删除值

false

是否开启乐观锁

opt\_version

乐观锁字段名

keyGenerator

AUTO\_INCREMENT

主键自增规则

underCamel

true

驼峰下划线转换

capitalMode

false

大小写转换

columnFormat

`%s`

列名格式化，%s 将替换为列名

aliasFormat

`%s`

charset

utf8mb4

字符集

collate

bin

排序字符集

optimisticLocker

克

logicDeleteColumn

-O i

配置项

杰

optimisticLockerColumn

字段别名格式化，%s 将替换为字 段别名

表 4-3 表配置 3. 配置举例 352

no ne

Oinone7 天从入门到精通

-O i

图 4-8 pamirs.mapper 配置举例

九、pamirs.persistence

杰

克

1.  描述：自动建库，建表
2.  配置举例

图 4-9 pamirs.persistence 配置举例

十、pamirs.plus 1. 描述 mybatisplus 的代理配置 2. 配置举例

图 4-10 pamirs.plus 配置举例

十一、pamirs.event

353

Oinone7 天从入门到精通

杰

克

-O i

no ne

1.  pamirs.event.enabled：启用 RocketMQ
    功能，不启用的情况下无法使用任何功能， 使用详见【分布式消息】一节
2.  pamirs.event.rocket-mq.namesrv-addr：RocketMQ 连接地址字符串
3.  pamirs.event.rocket-mq.aliyun : 阿里云版本适配
4.  pamirs.event.schedule.enabled：启动异步任务工，不启用无法使用任何功能
5.  配置举例

图 4-11 pamirs.event 配置举例

十二、pamirs.auth 1. pamirs.auth.ModelFilter：配置模型所有的 query
方法不需要过权限控制 \#下个 版本作废，不建议使用 2.
pamirs.auth.funFilter：配置模型的特定 query 方法不需要过权限控制 3.
配置举例

354

Oinone7 天从入门到精通

no ne

图 4-12 pamirs.auth 配置举例

十三、pamirs.file

杰

克

-O i

1.  描述：导入导出相关配置，使用详见【文件导入导出】一节
2.  配置举例

图 4-13 pamirs.file 配置举例

十四、pamirs.channel 1. 描述： 2. 配置举例

图 4-14 pamirs.channel 配置举例

355

Oinone7 天从入门到精通 十五、pamirs.zookeeper 1. 描述:zk 配置的代理 2.
配置举例

图 4-15 pamirs.zookeeper 配置举例

十六、pamirs.eip

-O i

no ne

1.  描述：集成相关配置，使用详见【集成平台】一节
2.  配置举例

高德地图接口的 key 配置

杰

l

克

图 4-16 pamirs.eip 配置举例

图 4-17 高德地图接口的 key 配置

十七、pamirs.elastic 1. 描述：es 搜索引擎地址 ，使用详见【搜索引擎】一节
2. 配置举例

图 4-18 pamirs.elastic 配置举例

十八、pamirs.load Oinone 的默认模式下元数据都是以 DB 为准，当 A 模块依赖
B 模块，A 与 B 模块不在没 有部署在一起同时元数据的 Base
库也不是一个，那么 A 的元数据库怎么没有 B 模型，会导 356

Oinone7 天从入门到精通 致系统出现模型定义找不到的错误。那么则需要 A
启动内存元数据模式，因为在 A 的元数据 计算的时，因为 A 依赖 B
模块，同时有 B 的接口包，在内存中会扫描 B 的模型。所以我们要
启动内存模式。应对分布式开发场景设计，更多请参见【Oinone
的分布式开发组织模式】。

图 4-19 pamirs.load 配置举例

n 4.1.2 模块之启动指令

no ne

针对不同启动指令的组合可以满足不同场景需求，下面列举了几个常规组合方式，小伙
伴们务必把这几种模式都尝试一遍，会更有体感。 本节为小伙伴讲解 Oinone
模块的几种启动方式，它是为能灵活地应对企业市场的不同 场景需求，为
OP（本地化部署）、SaaS 和研发提供个性化支撑。也为【Oinone 独特性之单
体与分布式的灵活切换】提供基础支撑。

一、部署参数

名称

默认值

说明

-O i

参数

可选项：无/INSTALL/PACKAGE/RELOAD/DDL 安装-install 为 AUTO；upgrade 为
FORCE

打包-install 为 AUTO；upgrade 为 FORCE；profile 为

-Plifecycle

生命周期部署指令

RELOAD

PACKAGE

杰

克

重启-install、upgrade、profile 为 READONLY

打印变更 DDL-install 为 AUTO；upgrade 为 FORCE； profile 为 DDL

表 4-4 部署参数

如果在启动命令中配置了部署参数，可不再设置服务参数和可选项参数。下图为在启动
命令中添加部署参数的示例（如下图 4-20 所示）。

357

no ne

Oinone7 天从入门到精通

图 4-20 在启动命令中添加部署参数的示例

二、使用场景

杰

克

-O i

针对不同启动指令的组合可以满足不同场景需求，下面列举了几个常规组合方式，小伙
伴们务必把这几种模式都尝试一遍，会更有体感。
场景一：DDL(1)+RELOAD(N)应对专有 DBA 因为很多公司数据库是由专门的 DBA
来管理的，不允许应用直接变更数据库相关配置、 表结构、初始化数据。而
Oinone 是基于元数据驱动的，任何模型、行为的变化都会自动转
化成对物理存储的改变与元数据变化。 Oinone 为了适用企业 op
场景，特别增加了 DDL 模式。把发布上线分为两个步骤。 一：用 DDL
模式把涉及到数据库的变更与元数据初始化的脚本进行输出，交由客户公司 DBA
审批，并执行 二：用 RELOAD
模式，进行正常的应用重启工作，不进行安装、升级、以及数据库物理
变革等操作。

图 4-21 应用启动关闭自动 DDL 模式
场景二：PACKAGE(1)+RELOAD(N)应对提升多机器实例效率

1.  元数据差量计算、数据库变更、元数据变化保存都非常费时，如果每台机器都来一
    遍是非常费时费力的；
2.  分布式下多机器如果并发进行
    INSTALL，会导致数据库修改表结构、元数据变化保存 锁死。
    场景三：INSTALL 应对开发模式 研发在本地开发模式下 INSTALL
    是最有效率的，把所需依赖模块一把启动和调试。 358

Oinone7 天从入门到精通 上线如果要用 INSTALL 需要注意， 要逐台进行。
当然也可以改进成 INSTALL(1)+RELOAD(N) 模式。

三、启动命令解读 1. 查看启动命令

no ne

可以在启动日志中查看当前所用启动命令：

图 4-22 在启动日志中查看当前所用启动命令 2. 生命周期管理-Plifecycle

install upgrade profile

默认值

RELOAD

杰

启动配置项

克

-O i

除了通过启动 YAML 中 pamirs.boot
属性来设置集成方式，你还可以在应用启动命令中 使用-Plifecycle
参数来快捷控制集成方式和模块生命周期管理。该参数的可选项为 RELOAD、
INSTALL、CUSTOM\_INSTALL、PACKAGE、DDL。 java -jar <your jar name>.jar
-Plifecycle=RELOAD 启动命令会影响启动 YAML 中 pamirs.boot 属性中的
install、 upgrade 和 profile 属性。 如果不使用-Plifecycle 参数，则使用
YAML 中 pamirs.boot 属性中的 install、upgrade 和 profile 属性配置。若
YAML 中未配置，则采用默认值。 INSTALL

CUSTOM\_INSTALL

PACKAGE

DDL

AUTO

READONLY

AUTO

AUTO

AUTO

AUTO

AUTO

READONLY

FORCE

FORCE

FORCE

FORCE

CUSTOMIZE

READONLY

AUTO

CUSTOMIZE

PACKAGE

DDL

表 4-5 Plifecycle 可选项与启动项对应表 profile
属性请参考【服务启动可选项】。只有 pamirs.boot.profile=CUSTOMIZE 时， 在
pamirs.boot.options 中自定义的可选项才生效。 3. 自动建表-PbuildTable
java -jar <your jar name>.jar -PbuildTable=NEVER -PbuildTable
参数用于设置自动构建表结构的方式。如果不使用该参数，则 options
属性的默认值请参考【服务启动可选项】。-PbuildTable 参数可选项为： NEVER
- 不 自 动 构 建 表 结 构 ， 会 将 pamirs.boot.options 中 的 diffTable
和 rebuildTable 属性设置为 false

359

Oinone7 天从入门到精通

杰

克

-O i

no ne

EXTEND - 增量构建表结构，会将 pamirs.boot.options 中的 diffTable
属性设置为 false，rebuildTable 属性设置为 true DIFF -
差量构建表结构，会将 pamirs.boot.options 中的 diffTable 和 rebuildTable
属性设置为 true 4. 模块在线 -PmoduleOnline java -jar <your jar name>.jar
-PmoduleOnline=CHECK -PmoduleOnline
参数用于设置模块在线的方式。如果不使用该参数，则 profile 属性
的默认值请参考【服务启动可选项】。-PmoduleOnline 参数可选项为： ① NEVER
- 不读取存储在数据库中的模块信息，会将 pamirs.boot.options 中的
reloadModule 和 checkModule 属性设置为 false ② READ - 读 取 存 储 在 数
据 库 中 的 模 块 信 息 ， 会 将 pamirs.boot.options 中 的 checkModule
属性设置为 false，reloadModule 属性设置为 true ③ CHECK -
读取存储在数据库中的模块信息并校验依赖模块是否已安装，会将
pamirs.boot.options 中的 reloadModule 和 checkModule 属性设置为 true 5.
元数据在线-PmetaOnline java -jar <your jar name>.jar -PmetaOnline=MODULE
-PmetaOnline 参数用于设置元数据在线的方式，如果不使用该参数，则 profile
属性 的默认值请参考【服务启动可选项】。-PmetaOnline 参数可选项为： ①
NEVER - 不持久化元数据，会将 pamirs.boot.options 中的 updateModule、
reloadMeta 和 updateMeta 属性设置为 false ② MODULE -
只注册模块信息，会将 pamirs.boot.options 中的 updateModule 属性设 置为
true，reloadMeta 和 updateMeta 属性设置为 false ③ ALL -
注册持久化所有元数据，会将 pamirs.boot.options 中的 updateModule、
reloadMeta 和 updateMeta 属性设置为 true 6. 开放远程服务-PenableRpc
-PenableRpc 参数用于设置是否开启远程服务。如果不使用该参数，则 profile
属性的 默认值请参考【服务启动可选项】。-PenableRpc 参数可选项为 true 和
false。该参数会将 参数值设置到 pamirs.boot.options 中的 publishService
属性。 7. 开启 API 服务-PopenApi -PopenApi 参数用于设置是否开启 HTTP API
服务。如果不使用该参数，则 profile 属
性的默认值请参考【服务启动可选项】。-PopenApi 参数可选项为 true 和
false。该参数会 将参数值设置到 pamirs.boot.options 中的 rebuildHttpApi
属性。 8. 开启字段校验-PcheckField -PcheckField
参数用于设置是否开启字段校验。-PcheckField 参数可选项为 true 和
false。由于通常应用的字段数量非常多，会延长系统启动时长，所以默认不会开启字段校
验。 9. 启用数据初始化服务-PinitData -PinitData
参数用于设置是否开启数据初始化服务。如果不使用该参数，则 profile
属性的默认值请参考【服务启动可选项】。-PinitData 参数可选项为 true 和
false。该参 数会将参数值设置到 pamirs.boot.options 中的 updateData
属性。

四、不使用自动构建数据库表功能 Oinone LCDP
默认提供框架的所有服务，所以会自动构建数据库表。如果不需要使用 Oinone
的存储构建服务，可以设置 YAML
文件中关于自动建表的配置。这样就不会动态构建
数据库表，你可以手动搭建数据库表。 360

Oinone7 天从入门到精通

图 4-23 不使用自动构建数据库表功能

no ne

通过配置启动 YAML 中 pamirs.boot.options.rebuildTable 为 false
彻底关闭自动建表 功能。 也可以按需配置启动 YAML 中 pamirs.persistence
配置来关闭部分数据源的自动建表功 能。persistence
配置既可以针对全局也可以分数据源进行配置。

-O i

图 4-24 部分数据源不使用自动构建数据库表功能

n 4.1.3 模块之生命周期

杰

克

了解 Oinone 的启动生命周期过程，对于理解 Oinone
或者开发高级功能都有非常大的帮 助。 一、生命周期大图

361

杰

克

-O i

no ne

Oinone7 天从入门到精通

图 4-25 生命周期大图 二、平台扩展说明

平台节点通过 SPI 机制进行扩展，这里不展开更多详情请见 Oinone
内核揭秘系列文章 三、业务扩展说明

362

Oinone7 天从入门到精通 接口

说明

系统进入生命周期前置逻辑

LifecycleBeginAllInit

注：不能有任何数据库操作

使用场景

系统级别的信息收集上报 系统级别的信息收集上报、

LifecycleCompletedAllInit

系统生命周期完结后置逻辑

生命周期过程中的数据或上下文清 理

模块进入生命周期前置逻辑

LifecycleBeginInit

注：不能有任何数据库操作

预留，能做的事情比较少 本模块需等待其他模块初始化完毕
以后进行初始化的逻辑。

模块生命周期完结后置逻辑

比如： 1.集成模块的初始化

no ne

LifecycleCompletedInit

2.权限缓存的初始化

元数据编辑

MetaDataEditor

ExtendAfterBuilderInit

系统构建后置处理逻辑

模块在升级时的初始化逻辑

杰

UpgradeDataInit

ReloadDataInit

这个再初级教程中已经多次提及， 核心场景是想系统主动注册如

Action、Menu、View 等元数据

预留，能做的事情比较少，做一些 跟模块无关的事情
预留，能做的事情比较少，做一些 跟模块无关的事情

模块在初次安装时的初始化逻辑

克

InstallDataInit

系统构建前置处理逻辑

-O i

ExtendBuildInit

注：不能有任何数据库操作

……

根据模块启动指令来进行选择执行

注：根据启动指令来执行，是否执 逻辑，一般用于初始化业务数据。
行一次业务自己控制

应用启动参数与指令转化逻辑请见

模块在重启时的初始化逻辑

【模块之启动指令】一文

注：根据启动指令来执行，是否执 行一次业务自己控制

表 4-6 业务拓展说明 四、常用生命周期举例
（一）Install\Upgrade\Reload 的业务初始化(举例) ①

Step1 新建 DemoModuleBizInit

1)  DemoModuleBizInit 实现 InstallDataInit, UpgradeDataInit,
    ReloadDataInit

<!-- -->

a.  InstallDataInit 对应 init
b.  UpgradeDataInit 对应 upgrade
c.  ReloadDataInit 对应 reload

<!-- -->

2)  modules 方法代表改初始化类与哪些模块匹配，以模块编码为准
3)  priority 执行优先级

363

-O i

no ne

Oinone7 天从入门到精通

②

克

图 4-25 新建 DemoModuleBizInit Step2 重启看效果

杰

启动指令为-Plifecycle=INSTALL，转化指令为 install 为 AUTO；upgrade 为
FORCE 因为 DemoModule 我们已经执行过好多次了，所以会进入 upgrade
逻辑。系统重启的效 果跟我们预期的结果一致，确实执行了 DemoModuleBizInit
的 upgrade 方法。

图 4-26 系统重启执行 DemoModuleBizInit 的 upgrade 方法

364

Oinone7 天从入门到精通 （二）MetaDataEditor

l 回顾使用情况 最早在【模型的类型一文介绍传输模型】时初始化 ViewAction
窗口动作时使用到，这 里不过多介绍。下面主要介绍下 InitializationUtil
的工具类包含方法。 注：模块上报元数据只能通过注解或者实现 MetaDataEditor
接口并使用 InitializationUtil 工具来进行，更建议用注解方式。

n 4.1.4 模块之元数据详解

一、元数据说明 1.

ModuleDefinition

displayName

name

含义

对应注解

备注

-O i

元素数据构成

no ne

介绍 Module
相关元数据，以及对应代码注解方式。大家还是可以通读下，以备不时之 需。
如您还不了解 Module 的定义，可以先看下【Oinone
独特之源，元数据与设计原理】对 Module 的描述，本节主要带大家了解 Module
元数据构成，能让小伙伴非常清楚 Oinone 从 哪些维度来描述 Module。

显示名称

技术名称

@Module(

分类编码

杰

category

安装版本

克

latestVersion

displayName="", name="", version="", category="", summary="",

summary

描述摘要

moduleDependencies

依赖模块编码列表

dependencies={"",""}, exclusions={"",""}, priority=1L )

moduleExclusions

互斥模块编码列表

priority

排序

module

模块编码

@Module.module("")

dsKey

逻辑数据源名

@Module.Ds("")

excludeHooks

排除拦截器列表

@Module.Hook(excludes={"", ""})

365

Oinone7 天从入门到精通 website

站点

author

module 的作者

description

描述

application

是否应用

demo

是否演示应用 @Module.Advanced(

web

website="http://www.oinone

是否 web 应用

.top", website 去购买

author="Oinone",

no ne

是否需要跳转到

toBuy

description="Oinone", application=false,

selfBuilt

自建应用

demo=false, web=false,

toBuy=false,

-O i

selfBuilt=true,

license=SoftwareLicenseEnu m.PEEL1,

maintainer="Oinone",

许可证

contributors="Oinone", url="http://git.com" )

可选范围： GPL2 GPL2ORLATER GPL3 GPL3ORLATER AGPL3 LGPL3 ORTHEROSI PEEL1
PPL1

杰

克

license

默认 PEEL1

ORTHERPROPRIETARY

maintainer

维护者

contributors

贡献者列表

url

代码库的地址 加上该注解代表：

boot

是否自动安装的引导启 动项

@Boot

启动时会自动安装，不管 yml 文件的 modules 是否 配置

moduleClazz

模块定义所在类

只有用代码编写的模块才有

366

Oinone7 天从入门到精通 包路径，用于扫描该模

packagePrefix

块下的其他元数据

dependentPackagePrefix

依赖模块列对应的扫描 路径

state

状态

metaSource

元数据来源

publishCount

发布总次数

platformVersion

最新平台版本

系统自动计算，无需配置

本地与中心平台的版本

publishedVersion

最新发布版本

no ne

对应。做远程更新时会用 到

表 4-7 1.ModuleDefinition 2.

UeModule

homePageModel

homePageName

对应注解

备注

跳转模型编码

@UxHomepage(

对应一个 ViewAction，如

@UxRoute(

果 UxRoute 只配置了模型，

)

则默认到该模型的列表页

视图动作或者链接动作名 称

图标

杰

logo

含义

克

元素数据构成

-O i

是对 ModuleDefinition 的继承，并扩展了跟前端交互相关的元数据。

@UxAppLogo (logo="")

表 4-8 UeModule

二、元数据，代码注解方式 1.

Module

Module ├── ├── ├── ├── ├── ├── ├── ├── ├──

displayName 显示名称 name 技术名称 version 安装版本 category 分类编码
summary 描述摘要 dependencies 依赖模块编码列表 exclusions
互斥模块编码列表 priority 排序 module 模块编码

367

Oinone7 天从入门到精通

相关 Ux 注解

模块 3.

UxHomepage

4.  

UxAppLogo

杰

UxAppLogo └── logo 图标

克

UxHomepage 模块主页 └── UxRoute

-O i

2.  

no ne

│ └── value ├── Ds 逻辑数据源名 │ └── value ├── Hook 排除拦截器列表 │
└── excludes ├── Advanced 更多配置 │ ├── website 站点 │ ├── author 作者
│ ├── description 描述 │ ├── application 是否为应用 │ ├── demo
是否演示应用 │ ├── web 是否 web 应用 │ ├── toBuy 是否需要跳转到 website
去购买 │ ├── selfBuilt 是否自建应用 │ ├── license
许可证，枚举默认：PEEL1 │ ├── maintainer 维护者 │ ├── contributors
贡献者 │ └── url 代码库地址

n 4.1.5 模型之持久层配置 一、批量操作
批量操作包括批量创建与批量更新。批量操作的提交类型系统默认值为
batchCommit。 批量提交类型： l
useAffectRows，循环单次单条脚本提交，返回实际影响行数； l
useAndJudgeAffectRows，循环单次单条脚本提交，返回实际影响行数，若实际影
响行数与输入不一致，抛出异常； l
collectionCommit，将多个单条更新脚本拼接成一个脚本提交，不能返回实际影响
行数； l batchCommit，使用单条更新脚本批量提交，不能返回实际影响行数。
（一）全局配置

368

Oinone7 天从入门到精通

图 4-27 全局配置 （二）运行时配置

非乐观锁模型系统默认采用 batchCommit 提交更新操作；乐观锁模型默认采用
useAndJudgeAffectRows
提交更新操作。也可以使用以下方式在运行时改变批量提交方式。

no ne

图 4-28 运行时配置 （三）运行时校正

二、乐观锁（举例）

-O i

如果模型配置了数据库自增主键，而批量新增的批量提交类型为
batchCommit，则系统 将批量提交类型变更为 collectionCommit（如果使用
batchCommit，则需要单条提交以获得 正确的主键返回值，性能有所损失）。
如果模型配置了乐观锁，而批量更新的批量提交类型为 collectionCommit 或者
batchCommit，则系统将批量提交类型变更为
useAndJudgeAffectRows。也可以失效乐观锁，
让系统不做批量提交类型变更处理。

杰

克

在一些会碰到并发修改的数据，往往需要进行并发控制，一般数据库层面有两种一种是
悲观锁、一种是乐观锁。Oinone 对乐观锁进行了良好支持。 （一）定义方式
乐观锁的两种定义方式： ① 通过快捷继承
VersionModel，构建带有乐观锁，唯一编码 code 且主键为 id 的模 型。 ②
可以在字段上使用@Field.Version 注解来标识该模型更新数据时使用乐观锁。
如果更新的实际影响行数与入参数量不一致，则会抛出异常，错误码为
10150024。如
果是批量更新数据，为了返回准确的实际影响行数，批量更新由批量提交改为循环单条数据
提交更新，性能有所损失。 （二）失效乐观锁
一个模型在某些场景下需要使用乐观锁来更新数据，而另一些场景不需要使用乐观锁来
更新数据，则可以使用以下方式在一些场景下失效乐观锁。更多元位指令用法见【函数之元
位指令】的一文。

369

Oinone7 天从入门到精通 图 4-28 失效乐观锁 （三）不抛乐观锁异常

将批量提交类型设置为 useAffectRows
即可，这样可改由外层逻辑对返回的实际影响行 数进行自主判断。

图 4-29 将批量提交类型设置为 useAffectRows

（四）构建第一个 VersionModel

-O i

no ne

① Step1 新建 PetItemInventroy 模型，继承快捷模型 VersionModel

克

图 4-30 新建 PetItemInventroy 模型

杰

② Step2 修改 DemoMenu，增加访问入口

图 4-31 修改 DemoMenu

③ Step3 重启看效果 1) 体验一：页面上新增、修改数据库字段中的
opt\_version 会自动加一

图 4-32（效果图一）

图 4-33（效果图二）

370

Oinone7 天从入门到精通

图 4-34（效果图三）

图 4-35（效果图四）

no ne

2)  体验二：同时打两个页面，依次点击，您会发现一个改成功，一个没有改成功。但页面
    都没有报错，只是 update 返回影响行数一个为 1，另一个为 0 而已。

-O i

图 4-36 编辑宠物商品库存

克

图 4-37 宠物商品库存列表

杰

注：增加了乐观锁，我们在写代码的时候一定要注意，单记录更新操作的时候要去判断
返回结果（影响行数），不然没改成功，程序是不会抛错的。不像 batch
接口默认会报错。 ④ Step4 预留任务：重写 PetItemInventroy 的 update 函数
留个任务，请各位小伙伴自行测试玩玩，这样会更有体感

371

no ne

Oinone7 天从入门到精通

图 4-38 重写 PetItemInventroy 的 update 函数

n 4.1.6 模型之元数据详解

一、模型元数据 （一）安装与更新

-O i

介绍 Model
相关元数据，以及对应代码注解方式。大家还是可以通读并练习每种不同的
使用方式，这个是 Oinone
的设计精华所在。当您不知道如何配置模型、字段、模型间的关
系、以及枚举都可以到这里找到。

杰

克

使用@Model.Model
来配置模型的不可变更编码。模型一旦安装，无法在对该模型编码
值进行修改，之后的模型配置更新会依据该编码进行查找并更新；如果仍然修改该注解的配
置值，则系统会将该模型识别为新模型，存储模型会创建新的数据库表，而原表将会
rename 为废弃表。 如果模型配置了@Base 注解，表明在 studio
中该模型配置不可变更；如果字段配置了 @Base 注解，表明在 studio
中该字段配置不可变更。 （二）注解配置

模型类必需使用@Model 注解来标识当前类为模型类。
可以使用@Model.Model、@Fun 注解模型的模型编码（也表示命名空间），先取
@Model.Model 注解值，若为空则取@Fun 注解值，若皆为空则取全限定类名。
（三）模型元信息

模型的 priority，当展示模型定义列表时，使用 priority
配置来对模型进行排序。 模型的 ordering，使用 ordering
属性来配置该模型的数据列表的默认排序。 模型元信息继承形式： l
不继承（N） l 同编码以子模型为准（C） l 同编码以父模型为准（P） 372

Oinone7 天从入门到精通 l 父子需保持一致，子模型可缺省（P=C）
注意：模型上配置的索引和唯一索引不会继承，所以需要在子模型重新定义。数据表的
表名、表备注和表编码最终以父模型配置为准；扩展继承父子模型字段编码一致时，数据表
字段定义以父模型配置为准。 名称

描述

抽象继承

同表继承

代理继承

多表继承

基本信息

显示名称

N

N

N

N

summary

描述摘要

N

N

N

N

label

数据标题

check

rule

no ne

displayName

N

N

N

模型校验方法

N

N

N

N

模型校验表达式

N

N

N

N

N

N

N

N

技术名称

N

N

N

N

逻辑数据表名

N

P=C

P=C

N

type

模型类型

N

N

N

N

chain

是否是链式模型

N

N

N

N

index

索引

N

N

N

N

unique

唯一索引

N

N

N

N

managed

需要数据管理器

N

N

N

N

-O i

N

模型编码

table

杰

name

模型编码

克

Model

高级特性

373

Oinone7 天从入门到精通 优先级，默认 100

N

N

N

N

ordering

模型查询数据排序

N

N

N

N

relationship

是否是多对多关系模型

N

N

N

N

inherited

多重继承

N

N

N

N

unInheritedFields

不从父类继承的字段

N

N

N

N

unInheritedFunctions

不从父类继承的函数

N

N

N

N

P=C

P=C

N

no ne

priority

高级特性-数据源

dsKey

数据源

N

-O i

高级特性-持久化

是否逻辑删除

P

P

P

N

logicDeleteColumn

逻辑删除字段

P

P

P

N

P

P

P

N

逻辑删除状态值

杰

logicDeleteValue

克

logicDelete

logicNotDeleteValue

非逻辑删除状态值

P

P

P

N

underCamel

字段是否驼峰下划线映射

P

P

P

N

capitalMode

字段是否大小写映射

P

P

P

N

高级特性-序列生成配置

sequence

配置编码

C

C

C

N

prefix

前缀

C

C

C

N

suffix

后缀

C

C

C

N

374

Oinone7 天从入门到精通 separator

分隔符

C

C

C

N

size

序列长度

C

C

C

N

step

序列步长

C

C

C

N

initial

初始值

C

C

C

N

format

序列格式化

C

C

C

N

no ne

高级特性-关联关系（或逻辑外键）

外键值是否唯一

C

C

C

N

foreignKey

外键名称

C

C

C

N

relationFields

关系字段列表

C

C

C

N

references

关联模型

C

C

C

N

关联字段列表

C

C

C

N

C

C

C

N

克

referenceFields

-O i

unique

关系数量限制

杰

limit

pageSize

查询每页个数

C

C

C

N

domainSize

模型筛选可选项每页个数

C

C

C

N

domain

模型筛选，前端可选项

C

C

C

N

onUpdate

更新关联操作

C

C

C

N

onDelete

删除关联操作

C

C

C

N

N

N

N

N

静态配置

Static

静态元数据模型

375

Oinone7 天从入门到精通 表 4-9 字段定义继承形式 名称

描述

抽象继承

同表继承

代理继承

多表继承

字段定义

字段定义

C

C

C

C

表 4-10 字段定义继承形式 （四）模型约束 ①

主键约束

no ne

每个模型都可以配置自身的主键列表，也可以不配置主键。主键值不可缺省，可以索引
到模型所对应数据表中唯一的一条记录。 ② 外键约束
模型与模型之间的关联关系可以配置外键约束来约束关联关系之间数据的变更行为。
③ 校验约束
模型可以配置校验函数对该模型的数据进行校验，存储数据时，校验数据是否合法合规。

二、字段元数据

杰

克

-O i

模型字段描述的是实体的特征属性。模型与字段之间的关联关系由 Model 的
Model 与 Field 的 Model 进行关联。ModelField 继承关系抽象类 Relation。
使用@Field 注解来描述模型的字段。如果未配置字段类型，系统会根据 Java
代码的字 段声明类型来自动获取业务类型。建议配置 displayName
属性来描述字段在前端的显示名称。 可以使用 defaultValue
配置字段的默认值。 （一）元数据注解说明

376

杰

克

-O i

no ne

Oinone7 天从入门到精通

图 4-39 元数据注解说明

377

Oinone7 天从入门到精通 （二）安装与更新

使用@Field.field
来配置字段的不可变更编码。字段一旦安装，无法在对该字段编码
值进行修改，之后的字段配置更新会依据该编码进行查找并更新；如果仍然修改该注解的配
置值，则系统会将该字段识别为新字段，存储模型会创建新的数据库表字段，而原字段将会
rename 为废弃字段。 （三）基础配置 ①

不可变更字段

业务类型

BINARY

杰

克

-O i

no ne

使用 immutable
属性来描述该字段前后端都无法进行更新操作，系统会忽略不可变更字
段的更新操作。 ② 自动生成编码的字段 可以使用@Field.Sequence
注解在字段上配置编码生成规则，为编码为空的字段自动生
成编码。详见【模型编码生成器】 ③ 字段的序列化与反序列化 使用@Field
注解的 serialize 属性来配置非字符串类型属性的序列化与反序列化方式，
最终会以序列化后的字符串持久化到存储中。详见【字段之序列化方式】 ④
前端默认配置 可以使用@Field
注解中的以下属性来配置前端的默认视觉与交互规则，也可以在前端
设置覆盖以下配置。 l required，是否必填 l invisible，是否不可见 l
priority，字段优先级，列表的列使用该属性进行排序 （四）字段类型
类型系统由基本类型、复合（组件）类型、引用类型和关系类型四种类型系统构成。通
过类型系统描述应用程序、数据库和前端视觉视图如何进行交互，数据及数据间关系如何处
理的协议。 ① 基本类型 Java 类型

数据库类型

Byte

TINYINT

Byte\[\]

BLOB

规则说明

二进制类型，不推荐使用 整数, 包括整数（10-11 位有效数字）、长整数（19-20
位有效数字）和大整数（超过 19 位）。 【数据库规则】：默认使用 int；如果
size 小于 6

Short INTEGER

smallint

则使用 smallint；如果 size 超过 6 则使用 int；如

Integer

int

果 size 超过 10 位数字，即大于 11（包含符号位），

Long

bigint

则使用长整数 bigint；如果 size 超过 19 位数字，即

BigInteger

decimal(size,0)

大于 20（包含符号位），则使用大数 decimal。若未 配置 size，则按 Java
类型推测。 【前端交互规则】：整数使用 Number 类型，长整数
和大整数前后端协议使用字符串类型。

378

Oinone7 天从入门到精通 浮点数, 包括单精度浮点数（7-8 位有效数字）、双
精度浮点数（15-16 位有效数字）和大数（超过 15 位）。
【数据库规则】：默认使用单精度浮点数 float；

FLOAT

Float

float(M,D)

Double

double(M,D)

BigDecimal

decimal(M,D)

如果 size 超过 7 位数字，即大于等于 8，则使用双精 度浮点数 double；如果
size 超过 15 位数字，即大于 等于 16，则使用大数 decimal。若未配置
size，则按 Java 类型推测。 【前端交互规则】：单精度浮点数 float
和双精度浮 点数 double 使用 Number 类型（因为都使用 IEEE754 协议 64
位进行存储），大数前后端协议使用字符串 类型。

Boolean

tinyint(1)

布尔类型，值为 1,true(真)或 0,false(假)

no ne

BOOLEAN

【前端交互规则】：可选项从 ModelField 的 options 字段获取，options
字段值为字段指定数据字典子集

ENUM

Enum

与数据字典指定基本

的 JSON 序列化字符串。前后端传递的是可选项的

类型一致

name，数据库存储使用可选项的 value。multi 属性

为 true，则使用多选控件；multi 属性为 false，则

TEXT

String

HTML

String

varchar(size)

text

克

String

text

杰

STRING

-O i

使用单元控件

DATETIME

java.util.Date

字符串，size 为长度限制默认值参考，前端可以 view 中覆盖该配置

多行文本，编辑态组件为多行文本框，长度限制为配 置项 size 值 富文本编辑器
日期时间类型 【数据库规则】：日期和时间的组合， 时间格式为 YYYY-MM-DD
HH:MM:SS\[.fraction\]，默

datetime(fraction)

java.sql.Timestamp timestamp(fraction)

认精确到秒，在默认的秒精确度上，可以带小数，最 多带 6
位小数，即可以精确到 microseconds (6 digits) precision。可以通过设置
fraction 来设置 精确小数位数，最终存储在字段的 decimal 属性上。
【前端交互规则】：前端默认使用日期时间控件，根 据日期时间类型格式化格式
format 格式化日期时间 年份类型 日期类型

YEAR

java.util.Date

year

【数据库规则】：默认“YYYY”格式表示的日期值
【前端交互规则】：前端默认使用年份控件，根据日 期类型格式化格式 format
格式化日期

DATE

java.util.Date

date

日期类型

java.sql.Date

date

【数据库规则】：默认“YYYY-MM-DD”格式表示的日

379

Oinone7 天从入门到精通 期值
【前端交互规则】：前端默认使用日期控件，根据日 期类型格式化格式 format
格式化日期 时间类型 TIME

java.util.Date

time(fraction)

java.sql.Time

time(fraction)

【数据库规则】：默认“HH:MM:SS”格式表示的时间 值
【前端交互规则】：前端默认使用时间控件，根据日 期类型格式化格式 format
格式化日期

表 4-11 基本类型 复合类型

业务类型

Java 类型

数据库类型

MONEY

BigDecimal

decimal(M,D)

规则说明 金额，前端使用金额控件，可以使用 currency 设置币种字

no ne

②

段

表 4-12 复合类型 引用类型

业务类型

Java 类型

数据库类型

规则说明

-O i

③

引用字段

【数据库规则】：点表达式最后一级对应的字段类型；

基本类型或关 不存储或 varchar、 数据库字段值默认为 Java
字段的序列化值，默认使用 系类型

text

JSON 序列化

克

RELATED

【前端交互规则】：点表达式最后一级对应的字段控件 类型

业务类型

杰

表 4-13 引用类型

Java 类型

数据库类型

规则说明

O2O

模型/DataMap

不存储或 varchar、text

一对一关系

M2O

模型/DataMap

不存储或 varchar、text

多对一关系

O2M

List<模型/DataMap>

不存储或 varchar、text

一对多关系

M2M

List<模型/DataMap>

不存储或 varchar、text

多对多关系

④

关系类型

表 4-14 关系类型

380

Oinone7 天从入门到精通 多值字段或者关系字段需要存储，默认使用 JSON
格式序列化。多值字段数据库字段类 型默认为
varchar(1024)；关系字段数据库字段类型默认为 text。 ⑤ 类型默认推断 M
代表精度，即有效长度（总位数）， D 代表标度，即小数点后的位数，fraction
为 时间秒以下精度。multi 表示该字段为多值字段。 推断

Field 注解

Byte

@Field

BINARY

无

blob

String

@Field

STRING

size=128

varchar(128)

@Field

STRING

type&gt;

@Field

Short

@Field

Integer

@Field

Long

e

) varchar(1024

STRING

size=1024

INTEGER

M=5

smallint(6)

INTEGER

M=10

integer(11)

bigint(20)

-O i

Map

置

size=1024,multi=tru varchar(1024

no ne

List<primitive

ttype

推断配置

推断数据库配

Java 类型

)

@Field

INTEGER

M=19

@Field

INTEGER

M=64

@Field

FLOAT

M=7,D=2

float(7,2)

@Field

FLOAT

M=15,D=4

double(15, 4)

@Field

FLOAT

M=64,D=6

Boolean

@Field

BOOLEAN

无

tinyint(1)

java.util.Date

@Field

fraction=0

datetime

YEAR

无

year

DATE

无

date

TIME

fraction=0

time

克

BigInteger

Double

BigDecimal

杰

Float

java.util.Date

java.util.Date

java.util.Date

@Field.Date(type=DateTypeEnum.YEA
R)
@Field.Date(type=DateTypeEnum.DAT
E)
@Field.Date(type=DateTypeEnum.TIM
E)

DATETIM
E

decimal(64,0
)

decimal(64,6
)

381

Oinone7 天从入门到精通
java.sql.Timestam

DATETIM

@Field

p

E

fraction=0

timestamp

java.sql.Date

@Field

DATE

无

date

java.sql.Time

@Field

TIME

fraction=0

time

Long

@Field.Date

fraction=0

datetime

enum implements

E

@Field

IEnum
primitive type

DATETIM

@Field.Enum(dictionary=数据字典编
码)
@Field.Enum(dictionary=数据字典编

type>

码)

模型类

无

ENUM

无

no ne

List<primitive

ENUM

根据枚举
value 类型
根据枚举
value 类型

multi=true

varchar(512)

@Field.Relation

M2O

无

text

DataMap

@Field.Relation

M2O

无

text

List<模型类>

@Field.Relation

O2M

multi=true

text

List<DataMap>

@Field.Relation

O2M

multi=true

text

-O i

ENUM

①

主键

杰

（五）字段约束

克

表 4-15 类型默认推断

可以使用 Yaml 或者@Model.Advanced 的 keyGenerator
属性来配置模型主键的自动生成 规则，AUTO\_INCREMENT 或者分布式
ID。如果不配置，将不会自动生成主键值。 ② 逻辑外键约束
在创建关联关系字段的时候，可以使用@Field.Relation 注解的 onUpdate 和
onDelete
属性指定在删除模型或更新模型关系字段值时，对关联模型进行的相应操作。操作包括
RESTRICT、NO ACTION、SET NULL 和 CASCADE，默认值为 RESTRICT。 l RESTRICT
是指模型与关联模型有关联记录的情况下，引擎会阻止模型关系字段的
更新或删除模型记录； l NO ACTION
是指不作约束（这里与数据库约束的定义不相同）； l CASCADE
表示在更新模型关系字段或者删除模型时，级联更新关联模型对应记录的
关联字段值或者级联删除关联模型对应记录； l SET NULL
则是表示在更新模型关系字段或者删除模型的时候，关联模型的对应关
联字段将被 SET NULL（该字段值允许为 null 的情况下，若不允许为
null，则引擎 阻止对模型的操作）。 ③ 通用校验约束 382

Oinone7 天从入门到精通 字段业务类型

size

limit

decimal

BINARY

INTEGER

有效数字

FLOAT

有效数字

mime

min

max

文件类型

最小比特位

最大比特位

最小值

最大值

最小值

最大值

小数位数

BOOLEAN

STRING

存储字符数 多选最多数量

存储字符数

TEXT

MONEY

有效数字

RELATED

字符数

字符数

字符数

字符数

字符数

字符数

小数位数

最小值

最大值

-O i

HTML

no ne

ENUM

克

表 4-16 通用校验约束（表一）

max

时间格式

最早日期时间

最晚日期时间

YEAR

时间格式

最早年份

最晚年份

DATE

时间格式

最早日期

最晚日期

时间格式

最早时间

最晚时间

DATETIME

TIME

fraction

format

杰

min

字段业务类型

时间精度

时间精度

表 4-17 通用校验约束（表二）

字段业务类型

size

RELATED

存储字符数(若序列化存储)

domainSize

limit

pageSize

383

Oinone7 天从入门到精通 O2O

存储字符数(若序列化存储)

可选项每页个数

M2O

存储字符数(若序列化存储)

可选项每页个数

O2M

存储字符数(若序列化存储)

可选项每页个数 关系数量限制 查询每页个数

M2M

存储字符数(若序列化存储)

可选项每页个数 关系数量限制 查询每页个数

表 4-18 通用校验约束（表三）

④

no ne

在模型或字段上配置 check
函数，则处理前端请求时会进行校验约束。也可以调用模型 上的 check
函数进行编程式校验。 默认值约束

克

（六）关系字段

-O i

字段默认值 defaultValue
可以是基本类型或者关系类型的序列化值。时间类型可以使 用 format
来格式化时间表达式或者使用长整数来设置默认值。 枚举类型使用枚举项值
value 来设置默认值。如果需要进行复杂的计算请使用模型的 construct
构造函数来配置解决。 ⑤ 唯一约束 将字段或者模型上配置 unique
唯一索引，可以为模型或字段添加唯一约束。 ⑥ 可选项约束
使用枚举定义字段的可选项值，可以为字段提供可选项约束功能。

杰

关联关系用于描述模型间的关联方式： l 多对一关系，主要用于明确从属关系 l
一对多关系，主要用于明确从属关系 l
多对多关系，主要用于弱依赖关系的处理，提供中间模型进行关联关系的操作 l
一对一关系，主要用于多表继承和行内合并数据

384

no ne

Oinone7 天从入门到精通

图 4-40 关系字段

-O i

① 名词解释

杰

克

关联关系比较重要的名词解释如下： l 关联关系：使用 relation
表示，模型间的关联方式的一种描述，包括关联关系类
型、关联关系双边的模型和关联关系的读写 l 关联关系字段：业务类型 ttype 为
O2O、O2M、M2O 或 M2M 的字段 l 关联模型：使用 references
表示，自身模型关联的模型 l 关联字段：使用 referenceFields
表示，关联模型的字段，表示关联模型的哪些字
段与自身模型的哪些字段建立关系 l 关系模型：自身模型 l 关系字段：使用
relationFields 表示，自身模型的字段，表示自身模型的哪些字
段与关联模型的哪些字段建立关系 l 中 间 模 型 ， 使 用 through 表 示 ，
只 有 多 对 多 存 在 中 间 模 型 ， 模 型 的 relationship=true ②
关联关系的默认视图 l
一对多默认视图，编辑态在行内是下拉多选，在详情是选项卡表格；展示态在行内
是折叠面板表格，在详情是选项卡表格 l
多对一默认视图，编辑态在行内是下拉单选，在详情是下拉单选；展示态在行内是
文字，在详情是文字 l
多对多默认视图，编辑态在行内是下拉多选，在详情是选项卡表格；展示态在行内
是折叠面板表格，在详情是选项卡表格 l
一对一默认视图，编辑态在行内是平铺，在详情是分组；展示态在行内是平铺，在
详情是分组
在后端研发的使用上所有关联关系和引用的处理都限制在本模型，即模道至多处理到当
前模型的字段，不再继续依据关联关系和引用处理关联模型。但是可以手动调用模型上的链
式方法 fieldQuery、fieldCreate 和 fieldUpdate
来完成关联关系的查询与更新操作。 385

Oinone7 天从入门到精通 使用 O2M 或者 M2M
关联关系关联的临时模型没有分页查询操作。 ③ 关联关系的配置
可以使用@Field.Relation 注解的
relationFields、referenceFields、references 和 through 来配置关联关系。
relationFields 与 referenceFields 为存储关联关系的一一映射字段列表。
如果 relationFields 缺省， 一对多或者多对多关系的 relationFields
默认为模型主键； 一对一或者多对一关系的 relationFields
默认为关联关系字段名加上首字母大写的主键名
拼接而成的字符串。如果有多个主键，则 relationFields 和 referenceFields
也对应有多 个字段。 如果配置了 relationFields，但 referenceFields
缺省，则 referenceFields 与 relationFields 字段名一致。 一对多关系的
referenceFields 必填。如果 referenceFields 缺省，多对多，多对一或
者一对一关系的 referenceFields 默认为主键。 缺省关系字段默认值

缺省关联字段默认值

no ne

关系类型

默认为关系模型名+关系模型的 pk；如

一对多

默认为关系模型的 pk

果关系另一端的多对一字段名不是关

系模型名，则需明确指定，使两端关系 字段与关联字段对应

默认为关联关系字段名+关系模型的 pk

默认为关联模型的 pk

多对一

默认为关联关系字段名+关系模型的 pk

默认为关联模型的 pk

多对多

默认为关系模型的 pk

默认为关联模型的 pk

克

-O i

一对一

杰

表 4-19 关联关系的配置

多对多使用 through
来指定中间模型的模型编码，如果指定模型编码的中间模型不存在， 系统会根据
through 自动生成中间模型，中间模型的默认字段为与两端模型关联的关系字段。
与关系模型关联的关系字段名称为关系模型名称加上关系模型的主键拼接而成的字符串；与
关联模型关联的多对一字段名称为关联模型名称加上关联模型主键拼接而成的字段串。如果
与关系模型关联的关系字段名称和与关联模型关联的多对一字段名称冲突，需要使用
throughRelationFields 和 throughReferenceFields
明确配置指定字段名称解决冲突。
系统根据模块的依赖关系，自动生成的中间模型将生成在先加载的建立多对多关系的关
系模型所在模块。 ④ 读写关联关系字段 默认关联关系字段的 store 属性为
false，relationStore 为 true。若设置关联关系字 段 relationStore 属性为
true，则会为关联关系字段生成关系字段用于存储关联关系。若
设置关联关系字段 store 属性为
true，则存储时序列化字段值存储到数据库中，查询时从
数据库中反序列化得到字段值。 字段类型为 varchar 且长度为 128，
如果需要改变字段长度， 可以使用@Field.Advanced 的 columnDefinition
设置。当 store 属性为 false 时，则字段 值为关联关系查询得到的结果。如果
store 为 false 且 relationStore 为 false，则只能对
字段进行赋值来设置字段值。 386

Oinone7 天从入门到精通 ⑤

关联操作

-O i

no ne

调用数据管理器的 API 不会触发关联操作，需要调用 fieldQuery 和 fieldSave
方法进 行关联模型的关联操作。 前端的查询接口会根据 GraphQL
协议进行关联查询。
前端的新增和更新接口默认会存储当前模型的关联关系字段和递归新增和更新一对多
关系的关联关系字段。更新接口会检查当前模型的逻辑外键约束。可以调用模型的
ignore 方法或设置模型数据的 ignore 属性来改变递归深度，避免循环操作。
前端的删除接口会默认删除当前模型数据和根据级联配置进行当前模型的关联关系字
段的关联操作。删除接口会检查当前模型的逻辑外键约束。可以调用模型的
ignore 方法或 设置模型数据的 ignore 属性来改变递归深度，避免循环操作。 ⑥
关联数据分页 可以使用关系字段配置中分页数量 pageSize
来限定关联查询的返回结果数量。可选项 可以使用 domainSize
来限定可选项返回结果数量，由前端从字段元数据中获取并设置为可
选项查询分页数量限制。 ⑦ 反转关系 一对多关联关系可以设置 inverse 为 true
反转关系，反转关系后关联关系存储在一对 多关系中“一”这一端。 ⑧ 引用字段
引用字段可以通过与其他字段建立引用关系来获取数据。 当引用字段的 store
属性为 true 时，则字段值为存储的字段值，数据存储时将被引用
字段值存储到数据存储中（unset 掉被引用字段，则直接存储引用字段值）；当
store 属性 为 false 时，则数据为被引用字段的字段值且不会存储。

克

n 4.1.7 函数之元数据详解

杰

介绍 Function
相关元数据，以及对应代码注解方式。大家还是可以通读下，以备不时 之需。
如您还不了解 Function 的定义，可以先看下【Oinone
独特之源，元数据与设计原则】 对 Function 的描述，本节主要带大家了解
Function 元数据构成，能让小伙伴非常清楚 Oinone 从哪些维度来描述
Function，

一、元数据说明

（一）FunctionDefinition 元素数据构成

含义

对应注解

备注

namespace

函数命名空间

@Fun("")

@Fun 或@Model.Model

name

技术名称

@Function( name="",

scene

可用场景

description

描述

scene={}, summary="",

见：FunctionSceneEnum

openLevel=FunctionOpenEnum .REMOTE

387

Oinone7 天从入门到精通 openLevel

开放级别

fun

编码

displayName

显示名称

)

见：FunctionOpenEnum

@Function.fun("")

函数类型

type

见

默认：4(改)

dataManager

language

数据管理器函数 默认：false

@Function.Advanced(

函数语言

displayName="",

默认：DSL

type=FunctionTypeEnum.UPDA

是否内置函数

no ne

TE, isBuiltin

dataManager=false,

language=FunctionLanguageE

category

分类

num.JAVA,

isBuiltin=false,

系统分组

group

FunctionCategoryEnum

category=FunctionCategoryE num.OTHER,

-O i

pamirs

见：

系统版本

version

1.0.0

group="pamirs",

version="1.0.0", timeout=5000,

timeout

超时时间

retries=0,

retries

克

isLongPolling=false,

重试次数

是否支持 long

longPollingTimeout=1 )

杰

isLongPolling

longPollingKey="userId"

longPollingKey

longPollingTimeout

transactionConfig

polling，默认 false 支持从上下文中获取 字段作为 key

long polling 超时时 间 事务配置

见 TransactionConfig

JSON 存储

@PamirsTransactional 系统推断值，见：

source

来源

extPointList

函数包含扩展点

系统推断值

module

所属模块

系统推断值

FunctionSourceEnum

388

Oinone7 天从入门到精通 位

系统推断值

attributes

属性

系统推断值

imports

上下文引用

系统推断值

context

上下文变量

系统推断值

codes

函数内容

系统推断值

beanName

bean 名称

系统推断值

rule

前端规则

clazz

函数位置

method

函数方法

argumentList

函数参数

returnType

返回值类型

系统推断值，一般 Action.rule 传递下来的

-O i

no ne

bitOptions

系统推断值

系统推断值 系统推断值， List<Argument> 系统推断值

克

表 4-20 FunctionDefinition

杰

（二）TransactionConfig

函数事务管理之配置项事务，具体事务使用请见【函数之事务管理】
元素数据构成

含义

transactionManager

事务管理器

enableXa

对应注解

备注

@PamirsTransactional( transactionManager="",

分布式事务

enableXa=false,

默认为 false

isolation=Isolation.DEFAULT, propagation=Propagation.REQUIRED,

isolation

事务隔离级别

timeout=-1, readOnly=false,

propagation

事务传递类型

rollbackFor={}, rollbackForClassName={},

timeout

过期时间

noRollbackFor={}, noRollbackForClassName={},

389

Oinone7 天从入门到精通 readOnly

只读

rollbackForExpCode={},

false

noRollbackForExpCode={} )

rollbackForExpCode

回滚异常编码

rollbackForExpCode

忽略异常编码

namespace

函数命名空间

系统推断值

fun

函数编码

系统推断值

active

生效

系统推断值

二、元数据，代码注解方式 （一）命名空间注解 Fun

@Fun 函数申明 └── value 命名空间 ②

Model

（二）函数信息注解 Function

杰

①

克

@Model └── Model 命名空间

-O i

①

no ne

表 4-21 TransactionConfig

@Function ├── name 技术名称 ├── scene 可用场景 ├── summary 描述摘要 ├──
openLevel 开放级别 ├── Advanced 更多配置 │ ├── displayName 显示名称 │
├── type 函数类型 默认 FunctionTypeEnum.UPDATE │ ├── managed
数据管理器函数 默认 false │ ├── language 语言 默认
FunctionLanguageEnum.JAVA │ ├── builtin 是否内置函数 默认否 │ ├──
category 分类 FunctionCategoryEnum.OTHER │ ├── group 系统分组
默认：pamirs │ ├── version 系统版本 │ ├── timeout 超时时间 390

Oinone7 天从入门到精通 │ ├── retries 重试次数 │ ├── isLongPolling
是否支持 long polling 默认 false │ ├── longPollingKey
支持从上下文中获取字段作为 key 默认 userId │ └── longPollingTimeout long
polling 超时时间 └── fun └──value （三）函数事务管理注解 ①

PamirsTransactional

克

-O i

no ne

@PamirsTransactional value @AliasFor("transactionManager") ├──
transactionManager @AliasFor("value") 默认值："" ├── propagation
事务传递类型 默认值：Propagation.REQUIRED ├── isolation 事务隔离级别
默认值：Isolation.DEFAULT ├── timeout 过期时间 ├── readOnly 只读
默认：false ├── rollbackFor 回滚异常类 ├── rollbackForClassName
回滚异常类名 ├── rollbackForExpCode 回滚异常编码 ├── noRollbackFor
忽略异常类 ├── noRollbackForClassName 忽略异常类名 ├──
noRollbackForExpCode 忽略异常编码 └── enableXa 分布式事务 默认为 false

n 4.1.8 函数之事务管理 一、事务管理介绍

杰

函数 Function 支持事务字段为 isTransaction（默认为 false），事务传播行为
propagationBehavior（默认 PROPAGATION\_SUPPORTS），事务隔离级别
isolationLevel（默
认使用数据库默认的事务隔离级别），所以不会默认为函数添加事务。另外事务配置提供全
局配置。 平台事务管理兼容 Spring
声明式与编程式事务，支持多数据源事务管理。事务管理中
多数据源嵌套独立事务，不会造成死锁风险。使用多数据源或分表操作，不会导致脏读。如
果需要多数据源分布式事务，请使用 PamirsTransational 分布式事务管理方案
（@PamirsTransational(enableXa=true)）。分布式事务一般用于量小的跨模块配置管理场
景。 （一）使用方式 声明式事务，使用@PamirsTransactional
注解在需要事务管理的类或方法上标注。在 非无代码场景下，与@Transactional
注解功能一致。 编程式事务，使用 PamirsTransactionTemplate
即可。在非无代码场景下，与 TransactionTemplate 功能一致。
配置式事务，使用 TxConfig 模型在模块安装时初始化存储事务配置数据。
（二）事务特性 391

Oinone7 天从入门到精通 (1) 原子性（atomicity）:强调事务的不可分割. (2)
一致性（consistency）:事务的执行的前后数据的完整性保持一致. (3)
隔离性（isolation）:一个事务执行的过程中,不应该受到其他事务的干扰 (4)
持久性（durability）:事务一旦结束,数据就持久到数据库 （三）事务隔离级别
事务隔离级别指的是一个事务对数据的修改与另一个并行的事务的隔离程度，当多个事
务同时访问相同数据时，如果没有采取必要的隔离机制，就可能发生以下问题：
问题

描述

一个事务读到另一个事务未提交的更新数据，所谓脏读，就是指事务 A
读到了事务 B 还没有 脏读

提交的数据，比如银行取钱，事务 A 开启事务，此时切换到事务 B，事务 B
开启事务–&gt;取 走 100 元，此时切换回事务 A，事务 A
读取的肯定是数据库里面的原始数据，因为事务 B 取 走了 100
块钱，并没有提交，数据库里面的账务余额肯定还是原始余额，这就是脏读

no ne

在一个事务里面的操作中发现了未被操作的数据
比方说在同一个事务中先后执行两条一模 不可重复读 一样的 select
语句，期间在此次事务中没有执行过任何 DDL 语句，但先后得到的结果不一
致，这就是不可重复读

是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修
幻读

改，这种修改涉及到表中的全部数据行。
同时，第二个事务也修改这个表中的数据，这种
修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没

-O i

有修改的数据行，就好象 发生了幻觉一样。

表 4-22 事务隔离级别

隔离级别

描述

使用数据库本身使用的隔离级别 ORACLE（读已提交） MySQL（可重复读）

杰

DEFAULT

克

（四）Pamirs（Spring）支持的隔离级别

READ\_UNCOMITTED

READ\_COMMITED

REPEATABLE\_READ

读未提交（脏读）最低的隔离级别，一切皆有可能。

读已提交，ORACLE 默认隔离级别，有不可重复读以及幻读风险。

可重复读，解决不可重复读的隔离级别，但还是有幻读风险。
串行化，最高的事务隔离级别，不管多少事务，挨个运行完一个事务的所有子

SERLALIZABLE

事务之后才可以执行另外一个事务里面的所有子事务，这样就解决了脏读、不
可重复读和幻读的问题了

表 4-23 隔离级别与描述

隔离级别

脏读可能性

不可重复读可能性

幻读可能性

加锁度

392

Oinone7 天从入门到精通 READ\_UNCOMITTED

是

是

是

否

READ\_COMMITED

否

是

是

否

REPEATABLE\_READ

否

否

是

否

SERLALIZABLE

否

否

否

是

表 4-24 隔离级别说明表 （五）事务的传播行为 \* 保证同一个事务中

A 抛异常 B 正常

PROPAGATION\_REQUIRES\_NEW （两个独立事务）

PROPAGATION\_NESTED

(B 的事务嵌套在 A 的事务 中)

克

异常状态

-O i

no ne

l PROPAGATION\_REQUIRED 支持当前事务，如果不存在 就新建一个(默认) l
PROPAGATION\_SUPPORTS 支持当前事务，如果不存在，就不使用事务 l
PROPAGATION\_MANDATORY 支持当前事务，如果不存在，抛出异常 \*
保证没有在同一个事务中 l PROPAGATION\_REQUIRES\_NEW
如果有事务存在，挂起当前事务，创建一个新的事务 l
PROPAGATION\_NOT\_SUPPORTED
以非事务方式运行，如果有事务存在，挂起当前事务 l PROPAGATION\_NEVER
以非事务方式运行，如果有事务存在，抛出异常 l PROPAGATION\_NESTED
如果当前事务存在，则嵌套事务执行 A 中嵌套 B 事务，嵌套
PROPAGATION\_REQUIRES\_NEW 方法勿与 A 在同类中。

A 回滚，B 正常提交

PROPAGATION\_REQUIRED (同一个事务)

A 与 B 一起回滚

A 与 B 一起回滚

B 先回滚，A 再正常提交

A 与 B 一起回滚

B 先回滚，A 再回滚

A 与 B 一起回滚

A 与 B 一起回滚

B 先提交，A 再提交

A 与 B 一起提交

A 与 B 一起提交

杰

1.如果 A 中捕获 B 的异常，并没有 继续向上抛异常，则 B 先回滚，A A 正常

再正常提交；

B 抛异常 2.如果 A 未捕获 B 的异常，默认则 会将 B 的异常向上抛，则 B
先回滚， A 再回滚 A 抛异常 B 抛异常 A 正常 B 正常

表 4-25 事务传播行为

二、声明式事务（举例） （一）Step1 修改 PetShopBatchUpdateAction

a.  不损害任何性能。
b.  事务保障率超过 4 个 9 393

Oinone7 天从入门到精通

no ne

c.  经过阿里的大厂验证，特别是在阿里的结算平台中得到了很好的验证
    @PamirsTransactional
    更多配置项请参考【函数之元数据详解】，自己多试试。同时
    @PamirsTransactional 百分百兼容@Transactional。

图 4-41 修改 PetShopBatchUpdateAction （二）Step2 重启看效果

杰

克

-O i

进入店铺管理列表页，选择记录点击【批量更新数据状态】按钮，修改记录的数据状态
为【未启用】，提交看效果。期望效果为：提示系统异常，数据修改失败。

图 4-42 数据状态显示已启用

图 4-43 批量更新数据状态

394

Oinone7 天从入门到精通

图 4-44 提示系统异常

三、编程式事务（举例）

no ne

为了提升性能，特别是在高并发场景，编程式事务开发模式有利于精细化控制事务开启
长度，尽可能地在事务开启前，把费时的查询工作、数据准备做完。基本套路如下：

图 4-45 编程式事务（举例）

杰

克

-O i

（一）Step1 修改 PetShopBatchUpdateAction

图 4-46 修改 PetShopBatchUpdateAction （二）Step2 重启看效果

跟声明式事务一致的效果

四、配置式事务
略，该模式一般用于平台内部使用以及无代码编辑器管理事务时用到，就不举例了

五、分布式事务（不建议使用） 如果要严格意义上的分布式事务，需要配置
enableXa 为 true， @PamirsTransational(enableXa=true)。同时引入依赖包。
395

Oinone7 天从入门到精通

图 4-47 分布式事务 注：该版本还不支持远程 RPC
后的分布式事务，因该模式有很大的弊端，也就是把原本
无状态的服务变成有状态，导致性能和耦合度都极差。所以我们一般使用事务性消息、异步
任务等最终一致性方案去替代。

n 4.1.9 函数之元位指令
元位指令系统是通过给请求上下文的指令位字段作按位与标记来对函数处理下发对应
指令的系统。

no ne

一、元位指令介绍
元位指令系统是通过给请求上下文的指令位字段作按位与标记来对函数处理下发对应指令的系统。

指令名

前端

后端

默认值

默认值

builtAction 内建动作

否

否

21

unlock

失效乐观锁

描述

是否是平台内置定义的服务器动作 对应操作：

PamirsSession.directive().disableBuiltAct ion();
PamirsSession.directive().enableBuiltActi

杰

20

指令

克

位

-O i

元位指令系统分为请求上下文指令和数据指令两种。 （一）数据指令
数据指令基本都是系统内核指令。业务开发时用不到这里就不介绍了。前 20
位都是系 统内核预留 （二）请求上下文指令

on(); 系统对带有乐观锁模型默认使用乐观锁 对应操作： 否

否

PamirsSession.directive().enableOptimisti cLocker();
PamirsSession.directive().disableOptimist icLocker();
系统后端操作默认不进行数据校验， 标记后生效 数据校验

22

check

数据校验

是

否

对应操作： PamirsSession.directive().enableCheck();
PamirsSession.directive().disableCheck(); 是否自动填充默认值

23

defaultValue 默认值计算

是

否

对应操作： PamirsSession.directive().enableDefaultVa

396

Oinone7 天从入门到精通 lue(); PamirsSession.directive().disableDefaultV
alue(); 前端请求默认执行扩展点，可以标记忽略扩展 点。
后端编程式调用数据管理器默认不执行扩展 点 24

extPoint

执行扩展点

是

否

对应操作： PamirsSession.directive().enableExtPoint( );
PamirsSession.directive().disableExtPoint (); 是否进行函数调用拦截

hook

拦截

是

否

对应操作： PamirsSession.directive().enableHook();

no ne

25

PamirsSession.directive().disableHook();

系统默认进行权限校验与过滤， 标记后使用权限 校验

26

authenticate

鉴权

是

否

对应操作：

PamirsSession.directive().sudo();

27

ormColumn

ORM 字段别 名

-O i

PamirsSession.directive().disableSudo();

否

否

系统指令，请勿设置

usePkStrateg 使用 PK 策 y

略

是

否

29

fromClient

是否客户端 调用

策略 对应操作：

PamirsSession.directive().enableUsePkStra tegy();
PamirsSession.directive().disableUsePkStr

杰

28

克

使用 PK 是否空作为采用新增还是更新的持久化

ategy(); 是否客户端（前端）调用 对应操作： 是

否

PamirsSession.directive().enableFromClien t();
PamirsSession.directive().disableFromClie nt();

30

sync

同步执行函 数

否

否

异步执行函数强制使用同步方式执行（仅对 Spring Bean 有效）
忽略函数管理器处理，防止 Spring 调用重复拦 截

31

ignoreFunMan 忽略函数管 agement

理

否

否

对应操作： PamirsSession.directive().enableIgnoreFun Management();
PamirsSession.directive().disableIgnoreFu 397

Oinone7 天从入门到精通 nManagement();

表 4-26 请求上下文指令 请求上下文指令：使用 session 上下文中非持久化
META\_BIT 属性设置指令。

二、使用指令

no ne

（一）普通模式

图 4-48 普通模式 （二）批量设置模式

三、使用举例

-O i

图 4-49 批量设置模式

杰

克

我们在【模型之持久层配置】一文中提到过失效乐观锁，我们在这里就尝试下吧。
（一）Step1 修改 PetItemInventroyAction 手动失效乐观锁

398

no ne

Oinone7 天从入门到精通

（二）Step2 重启看效果

-O i

图 4-50 修改 PetItemInventroyAction

① 体验一：页面上修改记录，数据库字段中的 opt\_version 不再自动加一

杰

克

② 体验二：同时打两个页面，依次点击，您会发现两次都成功。数据库字段中的
opt\_version 不再自动加一

图 4-51 编辑宠物商品库存

图 4-52 编辑宠物商品库存

399

Oinone7 天从入门到精通

图 4-53 宠物商品库存的数据库记录变化

n 4.1.10 函数之触发与定时

克

-O i

no ne

函数的触发和定时在很多场景中会用到，也是一个 Oinone
的基础能力。比如我们的流
程产品中在定义流程触发时就会让用户选择模型触发还是时间触发，就是用到了函数的触发
与定时能力。 整体链路示意图如下（如下图 4-54 所示），本文只讲 trigger
里的两类任务，一个是
触发任务，一个是定时任务，异步任务放在【函数之异步执行】单独去介绍。

杰

图 4-54 整体链路示意图

一、触发任务 TriggerTaskAction（举例） 触发任务的创建，使用
pamirs-middleware-canal 监听 mysql 的 binlog 事件，通过 rocketmq
发送变更数据消息，收到 MQ 消息后，创建 TriggerAutoTask。
触发任务的执行，使用 TBSchedule 拉取触发任务后，执行相应函数。
注意：pamirs-middleware-canal 监听的数据库表必须包含触发模型的数据库表。
（一）Step1 下载 canal 中间件 下载，去.txt 后缀为
pamirs-middleware-canal-deployer-3.0.1.zip，解压文件如下：

图 4-55 下载 canal 中间件 （二）Step2 引入依赖 pamirs-core-trigger 模块

400

Oinone7 天从入门到精通 ① pamirs-demo-api 增加 pamirs-trigger-api

图 4-56 pamirs-demo-api 增加 pamirs-trigger-api

no ne

② DemoModule 在模块依赖定义中增加
@Module(dependencies={TriggerModule.MODULE\_MODULE})

-O i

图 4-57 DemoModule 在模块依赖定义中增加
@Module(dependencies={TriggerModule.MODULE\_MODULE})

杰

克

③ pamirs-demo-boot 增加 pamirs-trigger-core 和
pamirs-trigger-bridge-tbschedule 的依赖

图 4-58 增加 pamirs-trigger-core 和 pamirs-trigger-bridge-tbschedule
的依赖 ④ 修改 pamirs-demo-boot 的 applcation-dev.yml a. 修改
pamris.event.enabled 和 pamris.event.schedule.enabled 为 true b.
pamirs\_boot\_modules 增加启动模块:trigger

401

no ne

Oinone7 天从入门到精通

图 4-59 修改 pamirs-demo-boot 的 applcation-dev.yml

-O i

（三）Step3 启动 canal 中间件

① canal 的库表需要手工建

杰

克

图 4-60 canal 的建库语句

402

杰

克

-O i

no ne

Oinone7 天从入门到精通

图 4-61 canal 的建表语句

403

Oinone7 天从入门到精通

杰

克

-O i

no ne

② 修改 canal 的启动配置 a. canal\_tsdb
就是上面建库，用户名和密码换成本机的； b. 配置 filter:
demo.demo\_core\_pet\_talent，监听 PetTalent 模型数据变化， filter 为
canal 第一次启动默认监听的表。如果数据库中 canal\_filter 表有数据这个
修改无效； c. filter
目前需要手工配置，在下个版本中已经去掉了手工配置，而且文中的 canal
中间件已经是 2.2.2 版本了，兼容当前教程的版本。

图 4-62 修改 canal 的启动配置 pamirs.canal 相关配置说明

canal.ip: 运行时 ip 404

Oinone7 天从入门到精通

-O i

no ne

canal.port: 运行时端口 canal.zkClusters: 连接 zookeeper 集群地址
canal.destinations: 运行时`Canal`的所有实例
canal.destinations.destinaion: `Canal`的单个实例配置值为所有实例唯一
canal.destinations.destinaion.id:
与`canal.destinations.destinaion.slaveId`配 置一致
canal.destinations.destinaion.slaveId: 为 Canal 的实例 ID
canal.destinations.destinaion.filter: 为 Canal 监听过滤正则
canal.destinations.destinaion.dbUserName: 为 Canal 监听的 MySQL 的用户名
canal.destinations.destinaion.dbPassword: 为 Canal 监听的 MySQL
的用户密码 canal.destinations.destinaion.topic: 为监听到数据后往
RocketMQ 的指定 Topic 发送 消息 canal.destinations.destinaion.dbs:
为连接的 MySQL 实例的 ip 和端口，如果为主从配 置且主从都开启了 Binlog
同步功能则可以配置两个地址
canal.destinations.destinaion.memoryStorageBufferSiz 与
canal.destinations.destinaion.dynamicTopic 为固定值不需要更改
canal.tsdb: 用来保存 canal 运行时的元数据，配置为 canal\_tsdb
库相关的连接信息 ③ 启动 canal 中间件 a. 进入 canal
中间件解压目录执行下面命令就可以启动 b. --spring.config.location
请配置绝对路径，换成自己本机的就可以

克

图 4-63 启动 canal 中间件

（四）Step4 新建触发任务

杰

新建 PetTalentTrigger 类，当 PetTalent
模型的数据记录被新建时触发系统做一些事 情。

图 4-64 新建触发任务 （五）Step5 重启应用看效果 ①

解决启动是 dubbo 报错

405

Oinone7 天从入门到精通
启动过程中会报如下错误，虽然不影响结果，但是还是要把它消灭掉。修改
bootstarp.yml 文件关闭 SpringCloud 的自动注册就好了：

杰

克

-O i

no ne

图 4-65 解决启动是 dubbo 报错

406

杰

克

-O i

no ne

Oinone7 天从入门到精通

407

杰

克

-O i

no ne

Oinone7 天从入门到精通

②

图 4-66 代码效果

再次重启查看效果

前端新增一个宠物达人，在后台 Console
搜索“被创建”，我们就看到对应由触发器打 印出来的日志：

408

no ne

Oinone7 天从入门到精通

图 4-67 再次重启看效果 （六）Step6 修改 canal 的 Topic

杰

克

-O i

在分布式环境下可以通过修改 canal 的
topic(canal.destinations.destinaion.topic) 来个隔离多个应用的触发消息。
① 新建 DemoNotifyTopicEdit 利用 Topic 修改 api，增加后缀【"\_"+
DemoModule.MODULE\_MODULE】 ② canal 的配置
canal.destinations.destinaion.topic 改
为:CHANGE\_DATA\_EVENT\_TOPIC\_demo\_core ③ 小伙伴自行测试

图 4-68 修改 canal 的 Topic

409

克

-O i

no ne

Oinone7 天从入门到精通

图 4-69 canal.destinations.destinaion.topic 改
为:CHANGE\_DATA\_EVENT\_TOPIC\_demo\_core

杰

二、定时任务

定时任务是一种非常常见的模式，这里就不介绍概念了，直接进入示例环节
（一）Step1 新建 PetTalentAutoTask 实现 ScheduleAction 注： ①
getInterfaceName()需要跟 taskAction.setExecuteNamespace 定义保持一致，都
是函数的命名空间； ②
taskAction.setExecuteFun("execute");跟执行函数名“execute”一致； ③
TaskType 需 配 置 为 CYCLE\_SCHEDULE\_NO\_TRANSACTION\_TASK ， 把 定 时
任 务 的 schedule
线程分开，要不然有一个时间长的任务会导致普通异步或触发任务全部延时。

410

杰

克

-O i

no ne

Oinone7 天从入门到精通

图 4-70 新建 PetTalentAutoTask 实现 ScheduleAction

（二）Step2 修改 DemoModuleBizInit，进行定时任务初始化

模块更新的时候调用 petTalentAutoTask.initTask()，initTask
本身是幂等的所以多 掉几次没有关系。在【模块之生命周期】一文介绍过
InstallDataInit、UpgradeDataInit、
ReloadDataInit，您有兴趣可以去回顾下。

411

no ne

Oinone7 天从入门到精通

图 4-71 修改 DemoModuleBizInit，进行定时任务初始化

-O i

（三）Step3 重启看效果

克

图 4-72 重启看效果

n 4.1.11 函数之异步执行

杰

异步任务是非常常见的一种开发模式，它在分布式的开发模式中有很多应用场景如：
a.
高并发场景中，我们一般采用把长流程切短，用异步方式去掉可以异步的非关键功
能，缩小主流程响应时间，提升用户体验 b.
异构系统的集成调用，通过异步任务完成解耦与自动重试 c.
分布式系统最终一致性的可选方案 今天我们了解 Oinone 如何结合
Spring+TbSchedule 来完成异步任务： 一、TbSchedule 介绍
它是一个支持分布式的调度框架，让批量任务或者不断变化的任务能够被动态的分配到
多个主机的 JVM
中,在不同的线程组中并行执行,所有的任务能够被不重复,不遗漏的快速处
理。基于 ZooKeeper 的纯 Java 实现，由 Alibaba 开源。在互联网和电商领域
TBSchedule
的使用非常广泛,目前被应用于阿里巴巴、淘宝、支付宝、京东、聚美、汽车之家、国美等
很多互联网企业的流程调度系统。也是笔者早期在阿里参与设计的一款产品。
下图为 Oinone 的异步任务执行原理图（如下图 4-73
所示），先做一个大致了解：

412

-O i

no ne

Oinone7 天从入门到精通

（一）基础管理工具

克

图 4-73 Oinone 的异步任务执行原理图

杰

1.  下载 tbSchedule 的控制台 jar
    包去除文件后缀.txt（详见文末【附件一】）
2.  启动控制台

图 4-74 启动控制台 3. 访问地址

图 4-75 访问地址 4. 配置 zk 连接参数

413

Oinone7 天从入门到精通

克

-O i

（二）Oinone 默认实现任务类型

no ne

图 4-76 配置 zk 连接参数

•

杰

图 4-77 Oinone 默认实现任务类型

•

baseScheduleNoTransactionTask baseScheduleTask remoteScheduleTask ---
适用于 pamirs-middleware-schedule 独立部署场景
serialBaseScheduleNoTransactionTask serialBaseScheduleTask
serialRemoteScheduleTask --- 适用于 pamirs-middleware-schedule
独立部署场

景 • • •

cycleScheduleNoTransactionTask delayMsgTransferScheduleTask
deleteTransferScheduleTask

• • • •

注： 1) 默认情况下：所有任务的任务项都只配置了一个任务项
0，只有一台机器能分配任 务。

414

Oinone7 天从入门到精通 a. 如果要修改配置可以在启动项目中放置
schedule.json，来修改配置 b. 人工进入控制修改任务对应任务项的配置 2)
如果想为某一个核心任务配置的独立调度器，不受其他任务执行影响。那么见【独
立调度的异步任务】

-O i

no ne

（三）任务表相关说明

图 4-78 任务表相关说明

二、构建第一个异步任务（举例）

克

（一）Step1 新建 PetShopService 和 PetShopServiceImpl

杰

1.  新建 PetShopService 定义 updatePetShops 方法

图 4-79 新建 PetShopService 定义 updatePetShops 方法 2.
PetShopServiceImpl 实现 PetShopService 接口并在 updatePetShops
增加@XAsync 注解： a. displayName =
"异步批量更新宠物商店"，定义异步任务展示名称 b. limitRetryNumber =
3，定义任务失败重试次数，，默认：-1 不断重试 c. nextRetryTimeValue =
60，定义任务失败重试的时间数，默认：3 d.
nextRetryTimeUnit，定义任务失败重试的时间单位，默认：
TimeUnitEnum.SECOND e. delayTime，定义任务延迟执行的时间数，默认：0 f.
delayTimeUnit，定义任务延迟执行的时间单位，默认：TimeUnitEnum.SECOND

415

Oinone7 天从入门到精通

图 4-80 l 实现 PetShopService 接口并在 updatePetShops 增加@XAsync 注解
（二）Step2 修改 PetShopBatchUpdateAction 的 conform 方法

克

-O i

no ne

引入 PetShopService 修改 conform 方法 利用 ArgUtils
进行参数转化，ArgUtils 会经常用到 调用 petShopService.updatePetShops
方法

杰

a.  b.  c.  d.  

416

克

-O i

no ne

Oinone7 天从入门到精通

图 4-81 修改 PetShopBatchUpdateAction 的 conform 方法

杰

（三）Step3 重启看效果

异步会有一定的延迟，我们按以下步骤测试下异步执行效果 1.
进入商店管理列表页，选择中一行数据点击批量更新数据状态按钮，进入批量修改
宠物商店数据状态页面：

图 4-82 进入批量修改宠物商店数据状态页面 2.
在批量修改宠物商店数据状态页面，数据状态设置为未启用，点击组合动作按钮回
到商店管理列表页： 417

Oinone7 天从入门到精通

图 4-83 点击组合动作按钮回到商店管理列表页

克

-O i

no ne

3.  查看商店管理列表页的数据记录的数据状态字段是否修改成功，此时可能未修改成
    功，也可能已经修改成功，因为本身就是毫秒级的速度，点击搜索刷新数据，发现数据记录
    的数据状态字段修改成功：

图 4-84 发现数据记录的数据状态字段修改成功

杰

4.  查看任务表，根据任务表与日期的对照关系查询指定表：

图 4-85 根据任务表与日期的对照关系查询指定表

三、异步任务高级玩法 （一）顺序异步任务（举例）

这里的顺序任务是指把任务按一定规则分组以后按时间顺序串行执行，不同分组间的任
务不相互影响。有点类似 mq 的顺序消息，
eg：订单的状态变更的异步任务需要根据任务产生时间顺序执行。那么分组规则是按订
单 id 分组，执行顺序按任务产生顺序执行。 (1) Step1 PetShopService 和
PetShopServiceImpl 1. 修改 PetShopService 新增定义
asyncSerialUpdatePetShops 方法

418

Oinone7 天从入门到精通

图 4-86 修改 PetShopService 新增定义 asyncSerialUpdatePetShops 方法

杰

克

-O i

no ne

2.  修 改 PetShopServiceImpl 实 现 ScheduleAction 接 口 ， 并 增 加
    asyncSerialUpdatePetShops 方法

<!-- -->

a.  引入 executeTaskActionService 用于提交异步串行任务 ExecuteTaskAction
    ① setExecuteNamespace(getInterfaceName())，确保跟
    getInterfaceName()一致 ②
    setExecuteFun("execute");跟执行函数名“execute”一致 ③
    setTaskType(TaskType.SERIAL\_BASE\_SCHEDULE\_NO\_TRANSACTION\_TASK.getValue(
    ))，必须用
    SERIAL\_BASE\_SCHEDULE\_NO\_TRANSACTION\_TASK，其为顺序执行任务类型
    ④ setBizId(petShop.getCreateUid())//根据创建人 Id
    分组，根据实际业务情况决 定
b.  getInterfaceName()跟函数的命名空间保持一致

419

克

-O i

no ne

Oinone7 天从入门到精通

图 4-87 getInterfaceName()跟函数的命名空间保持一致

杰

(2) Step2 修改 PetShopBatchUpdateAction 的 conform 方法

改调用异步顺序方法，petShopService.asyncSerialUpdatePetShops(shops)

420

克

-O i

no ne

Oinone7 天从入门到精通

杰

图 4-88 修改 PetShopBatchUpdateAction 的 conform 方法 (3) Step3
重启看效果

页面效果跟构建第一个异步任务一样，但任务生产和执行逻辑不一样。会根据
biz\_id 分配任务项与分组确保执行顺序： 1.
分配任务项，相同任务项一定会分配给同一个 schedule 的执行者； 2.
分组，任务在同一个 schedule 的执行者，相同分组 Id
一定会分配给同一个线程执 行，页面操作完以后查看数据任务表：

图 4-89 根据 biz\_id 分配任务项与分组确保执行顺序
（二）独立调度的异步任务（举例）

421

Oinone7 天从入门到精通
如果把所有任务都放在同一个任务类型下，复用同一套任务策略、任务配置、任务执行
器。那么当某些不重要的异步任务大量失败会影响其他任务的执行，所以我们在一些高并发
大任务量的场景下会独立给一些核心异步任务配置独立调度策略。 (1) Step1
修改 pamirs-demo-core 的 pom 增加对 pamirs-middleware-schedule-core
依赖，为了复用 Oinone 默认实现任务类型
的基础逻辑，在例子中我们自定义的异步任务继承
SerialBaseScheduleNoTransactionTask 的基础逻辑：

图 4-90 增加 pamirs-middleware-schedule-core 依赖

-O i

no ne

(2) Step2 新建 PetShopUpdateCustomAsyncTask

克

图 4-91 新建 PetShopUpdateCustomAsyncTask

(3) Step3 修改 PetShopServiceImpl 的 asyncSerialUpdatePetShops 方法

杰

修改 TaskType 为 PetShopUpdateCustomAsyncTask.TASK\_TYPE：

图 4-92 修改 TaskType 为 PetShopUpdateCustomAsyncTask.TASK\_TYPE 422

Oinone7 天从入门到精通 (4) Step4 初始化数据

杰

克

-O i

no ne

下载文件 schedule.json，放在 pamirs-demo-boot 的 src/main/resources/init
目录 下（详见文末【附件一】）。 我们在系统原有提供的
schedule.json，中增入任务类型为 petShopUpdateCustomAsyncTask
的配置,配置项"taskType": "CUSTOM"，标志为客户自定义。 实际注册到
TbSchedule 会按 beanNames 转化为 taskType，其他参数含义见 TbSchedule 的
管理控制台有对应中文说明：

图 4-93 增入任务类型为 petShopUpdateCustomAsyncTask 的配置 (5) Step5
重启看效果

页面效果跟构建第一个异步任务一样，但任务生产和执行逻辑不一样。会根据
biz\_id 分配任务项与分组确保执行顺序，同时会有独立的调度器以及规则配置：
1. 在 tbSchedule
的管理控制台，可以看见多了一个“petShopUpdateCustomAsyncTask”
的任务类型，点编辑就可以看到我们配置任务类型对应的参数：

423

Oinone7 天从入门到精通

no ne

图 4-94 tbSchedule 管理控制台

-O i

2.  页面操作完以后查看对应数据任务表

图 4-95 查看对应数据任务表

四、不同应用如何隔离执行单元

杰

克

在 schedule 跟模块部署一起的时候，多模块独立 boot
的情况下，需要做必要的配置。 如果 schedule
独立部署则没有必要，因为全部走远程，不存在类找不到的问题： ① 通过配置
pamirs.zookeeper.rootPath，确保两组机器都能覆盖所有任务分片，这
样不会漏数据； ② 通过 pamirs.event.schedule.ownSign
来隔离。确保两组机器只取各自产生的数据， 这样不会重复执行数据。

图 4-96 配置 pamirs.zookeeper.rootPath

n 4.1.12 函数之内置函数与表达式
本文意在列全所有内置函数与表达式，方便大家查阅。 424

Oinone7 天从入门到精通 一、内置函数
内置函数是系统预先定义好的函数，并且提供表达式调用支持。 （一）通用函数
1. 数学函数 表达式

名称

说明

函数场景: 表达式 ABS

绝对值

函数示例: ABS(number) 函数说明: 获取 number 的绝对值 函数场景: 表达式

FLOOR

向下取整

函数示例: FLOOR(number) 函数说明: 对 number 向下取整 函数场景: 表达式

向上取整

函数示例: CEIL(number)

no ne

CEIL

函数说明: 对 number 向上取整 函数场景: 表达式

ROUND

四舍五入

函数示例: ROUND(number)

函数说明: 对 number 四舍五入 函数场景: 表达式

取余

函数示例: MOD(A,B)

-O i

MOD

函数说明: A 对 B 取余 函数场景: 表达式

SQRT

平方根

函数示例: SQRT(number)

克

函数说明: 对 number 平方根

COS

正弦

杰

SIN

余弦

函数场景: 表达式 函数示例: SIN(number) 函数说明: 对 number 取正弦
函数场景: 表达式 函数示例: COS(number) 函数说明: 对 number 取余弦
函数场景: 表达式

PI

圆周率

函数示例: PI() 函数说明: 圆周率 函数场景: 表达式

ADD

相加

函数示例: ADD(A,B) 函数说明: A 与 B 相加 函数场景: 表达式

SUBTRACT

相减

函数示例: SUBTRACT(A,B) 函数说明: A 与 B 相减 函数场景: 表达式

MULTIPLY

乘积

函数示例: MULTIPLY(A,B) 函数说明: A 与 B 相乘

425

Oinone7 天从入门到精通 函数场景: 表达式 DIVIDE

相除

函数示例: DIVIDE(A,B) 函数说明: A 与 B 相除 函数场景: 表达式

MAX

函数示例: MAX(collection)

取最大值

函数说明: 返回集合中的最大值，参数 collection 为 集合或数组 函数场景:
表达式

MIN

函数示例: MIN(collection)

取最小值

函数说明: 返回集合中的最小值，参数 collection 为 集合或数组 函数场景:
表达式 函数示例: SUM(collection)

求和

函数说明: 返回对集合的求和，参数 collection 为集

no ne

SUM

合或数组

函数场景: 表达式

AVG

函数示例: AVG(collection)

取平均值

函数说明: 返回集合的平均值，参数 collection 为集 合或数组

-O i

函数场景: 表达式

COUNT

函数示例: COUNT(collection)

计数

函数说明: 返回集合的总数，参数 collection 为集合 或数组

2.  

大写金额

杰

UPPER\_MONEY

克

函数场景: 表达式 函数示例: UPPER\_MONEY(number) 函数说明:
返回金额的大写，参数 number 为数值或数 值类型的字符串

表 4-27 数学函数

文本函数 表达式

名称

说明

函数场景: 表达式 TRIM

空字符串过滤

函数示例: TRIM(text) 函数说明: 去掉文本字符串 text 中的首尾空格，文本
为空时，返回空字符串 函数场景: 表达式

IS\_BLANK

是否为空字符串

函数示例: IS\_BLANK(text) 函数说明: 判断文本字符串 text 是否为空
函数场景: 表达式

STARTS\_WITH

是否以指定字符串开始 函数示例: STARTS\_WITH(text,start) 函数说明:
判断文本字符串 text 是否以文本字符串

426

Oinone7 天从入门到精通 start 开始，文本为空时，按照空字符串处理

函数场景: 表达式 ENDS\_WITH

是否以指定字符串结束

函数示例: ENDS\_WITH(text,start) 函数说明: 判断文本字符串 text
是否以文本字符串 end 结束，文本为空时，按照空字符串处理 函数场景: 表达式

CONTAINS

函数示例: CONTAINS(text,subtext)

包含

函数说明: 判断文本字符串 text 是否包含文本字符串 subtext，文本 text
为空时，按照空字符串处理 函数场景: 表达式

LOWER

函数示例: LOWER(text)

小写

函数说明: 小写文本字符串 text，文本为空时，按照空

no ne

字符串处理

函数场景: 表达式

UPPER

函数示例: UPPER(text)

大写

函数说明: 大写文本字符串 text，文本为空时，按照空 字符串处理

函数场景: 表达式

函数示例: REPLACE(text,oldtext,newtext)

-O i

REPLACE

替换字符串

函数说明: 使用文本字符串 newtext 替换文本字符串 text 中的文本字符串
oldtext 函数场景: 表达式

杰

JOIN

获取字符串长度

克

LEN

连接字符串

函数示例: LEN(text) 函数说明: 获取文本字符串 text 的长度，文本为空时，
按照空字符串处理 函数场景: 表达式 函数示例: JOIN(text,join) 函数说明:
将文本字符串 text 连接文本字符串 join， 文本为空时，按照空字符串处理
函数场景: 表达式

PARSE

反序列化 JSON 字符串

函数示例: PARSE(text) 函数说明: 将 JSON 文本字符串 text 反序列化为集合或
者 map 函数场景: 表达式

JSON

序列化为 JSON 字符串

函数示例: JSON(object) 函数说明: 将记录 object 序列化为 JSON 字符串

表 4-28 文本函数 3.

正则函数 表达式

名称

说明

427

Oinone7 天从入门到精通 函数场景: 表达式 MATCHES

函数示例: MATCHES(text,regex)

正则匹配

函数说明: 校验字符串是否满足正则匹配，例如 regex
为\[a-zA-Z\]\[a-zA-Z0-9\]\*\$，来校验 text 是否匹配 函数场景: 表达式

CHECK\_PHONE

手机号校验

函数示例: CHECK\_PHONE(text) 函数说明: 校验手机号是否正确 函数场景:
表达式

CHECK\_EMAIL

邮箱校验

函数示例: CHECK\_EMAIL(text) 函数说明: 校验邮箱是否正确 函数场景: 表达式

CHECK\_USER\_NAME

用户名校验

函数示例: CHECK\_USER\_NAME(text) 函数说明: 校验用户名是否正确

CHECK\_PWD

密码强弱校验

no ne

函数场景: 表达式

函数示例: CHECK\_PWD(text) 函数说明: 判断密码是否满足强弱校验 函数场景:
表达式

CHECK\_INTEGER

整数校验

函数示例: CHECK\_INTEGER(text) 函数说明: 校验是否为整数

-O i

函数场景: 表达式

CHECK\_ID\_CARD

身份证校验

函数示例: CHECK\_ID\_CARD(text) 函数说明: 校验身份证是否正确 函数场景:
表达式

中文校验

杰

CHECK\_CHINESE

合法 URL 校验

克

CHECK\_URL

CHECK\_NUMBER

纯数字校验

函数示例: CHECK\_URL(text) 函数说明: 校验 URL 是否正确 函数场景: 表达式
函数示例: CHECK\_CHINESE(text) 函数说明: 校验是否为中文文本 函数场景:
表达式 函数示例: CHECK\_NUMBER(text) 函数说明: 校验是否为纯数字
函数场景: 表达式

CHECK\_TWO\_DIG

验证是否两位小数

函数示例: CHECK\_TWO\_DIG(text) 函数说明: 校验是否两位小数 函数场景:
表达式

CHECK\_IP

IP 地址校验

函数示例: CHECK\_IP(text) 函数说明: 校验 IP 地址是否正确 函数场景:
表达式

CHECK\_CONTAINS\_CHINESE

包含中文校验

函数示例: CHECK\_CONTAINS\_CHINESE(text) 函数说明: 校验是否包含中文

CHECK\_SIZE\_MAX

只能输入 n 个字符

函数场景: 表达式 函数示例: CHECK\_SIZE\_MAX(text,n)

428

Oinone7 天从入门到精通 函数说明: 只能输入 n 个字符

函数场景: 表达式 CHECK\_SIZE\_MIN

至少输入 n 个字符

函数示例: CHECK\_SIZE\_MIN(text,n) 函数说明: 至少输入 n 个字符 函数场景:
表达式

CHECK\_SIZE

输入 m-n 个字符

函数示例: CHECK\_SIZE(text,m,n) 函数说明: 输入 m-n 个字符

CHECK\_CODE

只能由英文、数字、下划 线组成

函数场景: 表达式 函数示例: CHECK\_CODE(text) 函数说明:
只能由英文、数字、下划线组成 函数场景: 表达式

CHECK\_ENG\_NUM

只能包含英文和数字

函数示例: CHECK\_ENG\_NUM(text)

no ne

函数说明: 只能包含英文和数字

表 4-29 正则函数 时间函数 表达式

名称

说明

NOW

-O i

函数场景: 表达式

返回当前时间

函数示例: NOW() 函数说明: 返回当前时间 函数场景: 表达式

返回当前时间字符串

克

NOW\_STR

杰

4.  

TODAY\_STR

返回今天的日期字符串

函数示例: NOW\_STR() 函数说明: 返回当前时间字符串，精确到时分秒，格式 为
yyyy-MM-dd hh:mm:ss 函数场景: 表达式 函数示例: TODAY\_STR() 函数说明:
返回今天的日期字符串，精确到天，格式为 yyyy-MM-dd 函数场景: 表达式
函数示例: ADD\_DAY(date,days)

ADD\_DAY

加减指定天数

函数说明: 将指定日期加/减指定天数，date 为指定日 期，days
为指定天数，当为负数时在 date 上减去此天 数 函数场景: 表达式 函数示例:
ADD\_MONTH(date,months)

ADD\_MONTH

加减指定月数

函数说明: 将指定日期加/减指定月数，date 为指定日 期，months
为指定月数，当为负数时在此 date 上减去 此月数

ADD\_YEAR

加减指定年数

函数场景: 表达式 函数示例: ADD\_YEAR(date,years)

429

Oinone7 天从入门到精通 函数说明: 将指定日期加/减指定年数，date 为指定日
期，years 为指定年数，当为负数时在此 date 上减去此 年数 TO\_DATE

ADD\_WORK\_DAY

函数示例: TO\_DATE(date,pattern)

转换为时间

函数说明: 将 date 字符串按格式转换为时间

工作日加减天数(跳过周 末)

函数示例: ADD\_WORK\_DAY(date,days)

表 4-30 时间函数 5.

集合函数 表达式

名称

说明

LIST\_GET

no ne

函数场景: 表达式 获取集合(或数组)中的元素

函数示例: LIST\_GET(list,index) 函数说明: 获取集合 list 中索引为数字
index 的 元素

函数场景: 表达式

LIST\_IS\_EMPTY

判断集合(或数组)是否为空

函数示例: LIST\_IS\_EMPTY(list)

-O i

函数说明: 传入一个对象集合，判断是否为空 函数场景: 表达式

LIST\_CONTAINS

判断集合(或数组)是否包含元素 函数示例: LIST\_CONTAINS(list,item)
函数说明: 判断集合 list 是否包含元素 item 函数场景: 表达式

将元素添加到集合(或数组)

LIST\_REMOVE

函数示例: LIST\_ADD(list,item) 函数说明: 将元素 item 添加到集合 list
函数场景: 表达式

将元素添加到集合(或数组)的指定 函数示例:
LIST\_ADD\_BY\_INDEX(list,index,item)

杰

LIST\_ADD\_BY\_INDEX

克

LIST\_ADD

位置

函数说明: 将元素 item 添加到集合 list 的索引 index 处 函数场景: 表达式

移除集合(或数组)中的元素

函数示例: LIST\_REMOVE(list,item) 函数说明: 从集合 list 中移除元素 item
函数场景: 表达式

LIST\_COUNT

获取集合(或数组)元素数量

函数示例: LIST\_COUNT(list) 函数说明: 传入一个对象集合，获取集合元素数量
函数场景: 表达式

LIST\_IDS

获取集合(或数组)中的所有 id

函数示例: LIST\_IDS(list) 函数说明: 传入一个对象集合，获取集合中的所有
id 组成的列表

LIST\_FIELD\_VALUES

将对象集合(或数组)转化为属性集 合

函数场景: 表达式 函数示例: LIST\_FIELD\_VALUES(list,Model,field) 430

Oinone7 天从入门到精通 函数说明: 传入一个对象集合，该对象的模型和属
性字段，返回属性值集合 函数场景: 表达式 LIST\_FIELD\_EQUALS

判断对象集合(或数组)中属性值匹 配情况

函数示例: LIST\_FIELD\_EQUALS(list,Model,field,value) 函数说明:
判断对象集合(或数组)中属性值匹配 情况，返回布尔集合 函数场景: 表达式
函数示例:

LIST\_FIELD\_NOT\_EQ 判断对象集合(或数组)中属性值不
LIST\_FIELD\_NOT\_EQUALS(list,Model,field,valu UALS

匹配情况

e)  函数说明: 判断对象集合(或数组)中属性值不匹 配情况，返回布尔集合

LIST\_FIELD\_IN

no ne

函数场景: 表达式

判断对象集合(或数组)中属性值是 否在指定集合(或数组)中

函数示例:

LIST\_FIELD\_IN(list,Model,field,list) 函数说明:
判断对象集合(或数组)中属性值是否 在指定集合(或数组)中，返回布尔集合
函数场景: 表达式 函数示例:

-O i

LIST\_FIELD\_NOT\_IN

判断对象集合(或数组)中属性值是 否不在指定集合(或数组)中

LIST\_FIELD\_NOT\_IN(list,Model,field,list) 函数说明:
判断对象集合(或数组)中属性值是否 不在指定集合(或数组)中，返回布尔集合

克

函数场景: 表达式

LIST\_OR

将一个布尔集合进行逻辑与运算 LIST\_AND(list)

杰

LIST\_AND

函数示例: 函数说明: 将一个布尔集合进行逻辑与运算，返回 布尔值 函数场景:
表达式 函数示例:

将一个布尔集合进行逻辑或运算 LIST\_OR(list) 函数说明:
将一个布尔集合进行逻辑或运算，返回 布尔值

函数场景: 表达式 函数示例: STRING\_LIST\_TO\_NU MBER\_LIST

将一个字符集合转换为数值集合

STRING\_LIST\_TO\_NUMBER\_LIST(list) 函数说明:
将一个字符集合转换为数值集合，如果
转换成功，返回一个数值集合；转换失败，返回集 合本身

431

Oinone7 天从入门到精通 函数场景: 表达式 函数示例: COMMA

将集合里面的值用逗号拼接

COMMA(list) 函数说明: 将集合里面的值用逗号拼接「集合里面 的值只能是
Number 或者 String 类型」，返回一个 字符串 函数场景: 表达式 函数示例:

CONCAT

将集合里面的值用指定的符号拼接

CONCAT(list, split) 函数说明: 将集合里面的值用 split 拼接「集合里
面的值只能是 Number 或者 String 类型」，返回一 个字符串

键值对函数 表达式

名称

MAP\_GET

说明

从键值对中获取指定键的 值

函数场景: 表达式

函数示例: MAP\_GET(map,key) 函数说明: 从键值对中获取键为 key 的值

-O i

6.  

no ne

表 4-31 集合函数

函数场景: 表达式

MAP\_IS\_EMPTY

判断键值对是否为空

函数示例: MAP\_IS\_EMPTY(map) 函数说明: 判断键值对 map 是否为空

向键值对中添加键值

杰

MAP\_PUT

克

函数场景: 表达式

MAP\_REMOVE

MAP\_COUNT

函数示例: MAP\_PUT(map,key,value) 函数说明: 将键为 key 的值为 value
添加到键值对 map 中 函数场景: 表达式

移除键值对中的元素

函数示例: MAP\_REMOVE(map,key) 函数说明: 从键值对 map 中移除键 key
函数场景: 表达式

获取键值数量

函数示例: MAP\_COUNT(map) 函数说明: 获取键值对 map 的键值数量

表 4-32 键值对函数 7.

上下文函数 表达式

名称

说明

函数场景: 表达式 CURRENT\_UID

获取当前用户 id

函数示例: CURRENT\_UID() 函数说明: 获取当前用户 id

432

Oinone7 天从入门到精通 函数场景: 表达式 CURRENT\_USER\_NAME

获取当前用户名

函数示例: CURRENT\_USER\_NAME() 函数说明: 获取当前用户的用户名 函数场景:
表达式

CURRENT\_USER

获取当前用户

函数示例: CURRENT\_USER() 函数说明: 获取当前用户

CURRENT\_ROLE\_IDS

获取当前用户的角色 id 列 表

函数场景: 表达式 函数示例: CURRENT\_ROLE\_IDS() 函数说明:
获取当前用户的角色 id 列表 函数场景: 表达式

CURRENT\_ROLES

获取当前用户的角色列表 函数示例: CURRENT\_ROLES() 函数说明:
获取当前用户的角色列表 函数场景: 表达式 函数示例: CURRENT\_PARTNER\_ID()

no ne

CURRENT\_PARTNER\_ID

获取当前用户的合作伙伴 id

函数说明: 获取当前用户的合作伙伴 id 函数场景: 表达式

CURRENT\_PARTNER

获取当前用户的合作伙伴 函数示例: CURRENT\_PARTNER() 函数说明:
获取当前用户的合作伙伴

8.  

对象函数 表达式

-O i

表 4-33 上下文函数

名称

说明

EQUALS

判断是否为空

杰

IS\_NULL

克

函数场景: 表达式 函数示例: IS\_NULL(文本或控件) 函数说明:
判断对象是否为空，为空则返回 true，不为 空则返回
false，可用于判断具体值或者控件 函数场景: 表达式

判断是否相等

函数示例: EQUALS(A,B) 函数说明: 判断 A 和 B 是否相等 函数场景: 表达式

FIELD\_GET

获取对象属性值

函数示例: GET(obj,dotExpression) 函数说明:
从对象中根据点表达式获取属性值

表 4-34 对象函数 9.

逻辑函数 表达式

名称

说明

函数场景: 表达式 IF

条件表达式

函数示例: IF(A,B,C) 函数说明: 如果 F 满足条件 A，则返回 B，否则返回 C，
支持多层嵌套 IF 函数

433

Oinone7 天从入门到精通 函数场景: 表达式 AND

逻辑与

函数示例: AND(A,B) 函数说明: 返回 条件 A 逻辑与 条件 B 的值 函数场景:
表达式

OR

逻辑或

函数示例: OR(A,B) 函数说明: 返回 条件 A 逻辑或 条件 B 的值 函数场景:
表达式

NOT

逻辑非

函数示例: NOT(A) 函数说明: 返回 逻辑非 条件 A 的值

表 4-35 逻辑函数 （二）特定场景函数 商业函数 表达式

no ne

1.  

名称

说明

函数场景: 商业公司

CURRENT\_CORP\_ID

获取当前用户的公司 id 函数示例: CURRENT\_CORP\_ID() 函数说明:
获取当前用户的公司 id 函数场景: 商业公司

获取当前用户的公司

函数示例: CURRENT\_CORP()

-O i

CURRENT\_CORP

函数说明: 获取当前用户的公司 函数场景: 商业店铺

CURRENT\_SHOP\_ID

获取当前用户的店铺 id 函数示例: CURRENT\_SHOP\_ID()

2.  

获取当前用户的店铺

杰

CURRENT\_SHOP

克

函数说明: 获取当前用户的店铺 id 函数场景: 商业店铺 函数示例:
CURRENT\_SHOP() 函数说明: 获取当前用户的店铺

表 4-36 商业函数

逻辑 DSL 函数 表达式

名称

说明

函数场景: 逻辑 DSL FOR\_INDEX

获取循环的 index

函数示例: FOR\_INDEX(context) 函数说明: 获取循环的 index

表 4-37 逻辑 DSL 函数

二、表达式
表达式，是由数字、算符、函数、数字分组符号（括号）、自由变量和约束变量等以能
求得数值的有意义排列方法所得的组合。约束变量在表达式中已被指定数值，而自由变量则
可以在表达式之外另行指定数值。

434

Oinone7 天从入门到精通
表达式可以使用运算符（+、-、\*、/、&&、||、!、==、!=）、点表达式（例如：模型
A.字段 C.关联模型字段 A）和内置函数。表达式格式如：IF(ISNULL(模型 A.字段
x),模型 A.字段 y.关联模型字段 z,模型 A.字段 m)
表达式中模型字段的前端展现使用展示名称
displayName，表达式原始内容使用技术名 称 name。 （一）点表达式
点表达式是表达式的子集，由变量名与点组成。点前的变量与点后的变量为从属关系，
点后的变量从属于点前的变量。可以使用点表达式获取由全表达式确定的最后一个点后变量
的值。 （二）正则表达式 说明

CHECK\_PHONE

手机号校验

CHECK\_EMAIL

邮箱校验

CHECK\_USER\_NAME

用户名校验

CHECK\_INTEGER

(强密码校验) 整数校验

身份证校验

杰

克

CHECK\_ID\_CARD

密码强弱校验

\^(1\[3-9\])\\d{9}\$

CHECK\_URL

[^1]+\[-|a-z0-9A-Z.\_\]+@(\[a-z0-9A-Z\]+(\[a-z0-9A-Z\]+)?\\.)+\[a-z\]{2,}\$
非空校验

\^(?=.*\[a-z\])(?=.*\[A-Z\])\[a-zA-Z0-9\~!@&%\#\_(.)\]{ 8,16}\$

-O i

CHECK\_PWD

正则表达式

no ne

对应内置函数

合法 URL 校验

\^-{0,1}\[1-9\]\d*\$

^\d{15}$)|(^\d{18}$)|(^\d{17}(\d|X|x)\$
\^(?:(?:https?)://)(?:(?:1\d{2}|2\[0-4\]\d|25\[05\]|\[1-9\]\d|\[1-9\])(?:.(?:1\d{2}|2\[0-4\]\d|25\[0
-5\]|\[1-9\]\d|\d)){2}(?:.(?:1\d{2}|2\[0-4\]\d|25
\[0-5\]|\[1-9\]\d|\d))|(?:(?:\[a-z\u00a1-\uffff0-9\]-*)*\[a-z\u00a1-\uffff0-9\]+)(?:.(?:\[a-z\u00a
1-\uffff0-9\]-*)*\[a-z\u00a1-\uffff0-9\]+)\*)(?::
(\[1-9\]|\[1-9\]\d|\[1-9\]\d{2}|\[1-9\]\d{3}|\[1-5\]\d{
4}|6\[0-4\]\d{3}|65\[0-4\]\d{2}|655\[0-2\]\d|6553\[0 -5\]))?(?:/\S*)?\$

CHECK\_CHINESE

中文校验

CHECK\_NUMBER

纯数字校验

CHECK\_TWO\_DIG

验证是否两位小数

CHECK\_IP

IP 地址校验

[^2]{0,}\$

[^3]\*\$

^\[0-9\]+(.\[0-9\]{2})?\$\ ^((2\[0-4\]\d|25\[0-5\]|\[01\]?\d\d?).){3}(2\[0-4\]\
d|25\[0-5\]|\[01\]?\d\d?)\$

435

Oinone7 天从入门到精通 CHECK\_CONTAINS\_CHINESE

包含中文校验

CHECK\_SIZE

只能输入 n 个字符

\^.{n}\$

CHECK\_SIZE\_MIN

至少输入 n 个字符

\^.{n,}\$

CHECK\_SIZE\_MAX

最多输入 n 个字符

\^.{0,n}\$

CHECK\_SIZE\_RANGE

输入 m-n 个字符

\^.{m,n}\$

CHECK\_ENG\_NUM

只能由英文、数字、下划线 组成

[^4]\*\$

no ne

CHECK\_CODE

\^.?\[\u4e00-\u9fa5\]{0,}.?\$

只能包含英文和数字

[^5]\*\$

表 4-38 正则表达式 （三）内置变量

-O i

在表达式中可以使用点表达式来获取内置变量的属性及子属性的属性。例如，使用
activeRecord 来获取当前记录。activeRecord.id 来获取当前选中行记录的 id。
1. 数据变量 变量

名称

说明

2.  

当前选中值

杰

activeRecord

克

选中单行记录跳转视图初始化时，值为单条当前选中记
录；选中多行记录跳转视图初始化时，值为当前选中记
录列表；整表单校验时，值为当前表单提交记录；单字
段校验时，值为当前字段值。作为动作筛选条件时，值 为动作模型定义数据。

表 4-39 数据变量

上下文变量 变量

名称

module

模块

tenant

租户

lang

语言

country

国家

说明

使用示例: context.module 示例说明：请求上下文中的模块 使用示例:
context.tenant 示例说明：请求上下文中的租户 使用示例: context.lang
示例说明：请求上下文中的语言 使用示例: context.country
示例说明：请求上下文中的国家

436

Oinone7 天从入门到精通 使用示例: context.env

env

环境

extend

扩展信息

示例说明：请求上下文中的环境 使用示例: context.extend.扩展变量名
示例说明：请求上下文中的扩展信息

表 4-40 上下文变量 （四）内置函数

内置函数章节介绍的内置函数可以在表达式中使用。例如，使用
ABS(activeValue.amount)来获取当前选中记录金额的绝对值。

n 4.1.13 Action 之校验

杰

克

-O i

no ne

在 Action 的类型一文中有涉及到【ServerAction
之校验】，本文介绍一个特殊的写法，
当内置函数和表达式不够用的时候，怎么扩展。还是拿 PetShopProxyAction
举例，修改如 下：

437

杰

克

-O i

no ne

Oinone7 天从入门到精通

图 4-97 PetShopProxyAction 扩展配置 注： 1、check
属性指定了校验函数名称，命名空间必须与服务器动作一致。
2、校验函数的入参必须与服务器动作一致 3、使用
PamirsSession\#getMessageHub 方法可通知前端错误的属性及需要展示的提示
信息，允许多个。

438

Oinone7 天从入门到精通 n 4.1.14 Search 之非存储字段条件 search
默认查询的是模型的 queryPage 函数，但我们有时候需要替换调用的函数，下
个版本支持。其核心场景为当搜索条件中有非存储字段，如果直接用 queryPage
函数的 rsql 拼接就会报错。本文介绍一个比较友好的临时替代方案。

一、非存储字段条件（举例） （一）Step1 为 PetTalent 新增一个非存储字段
unStore

图 4-98 为 PetTalent 新增一个非存储字段 unStore （二）Step2 修改
PetTalent 的 Table 视图的 Template

no ne

在<template slot="search" cols="4"></template>标签内增加一个查询条件：

图 4-99 修改 PetTalent 的 Table 视图的 Template （三）Step3 重启看效果

杰

克

-O i

进入宠物达人列表页，在搜索框【非存储字段测试】输入查询内容，点击搜索报错
（四）Step4 修改 PetTalentAction 的 queryPage 方法

439

杰

克

-O i

no ne

Oinone7 天从入门到精通

图 4-100 修改 PetTalentAction 的 queryPage 方法 （五）Step5 重启看效果

在搜索框非存储字段测试输入查询内容，跟搜索达人是一样的效果：

440

Oinone7 天从入门到精通

n 4.1.15 框架之网关协议 一、多端协议 l 协议内容格式 （一）请求头 头信息
headerMap

杰

克

-O i

1.  

no ne

图 4-101 重启看效果

图 4-102 头信息 headerMap 2.

请求地址 requestUrl

例如 http://127.0.0.1:8090/pamirs/DemoCore?scene=redirectListPage 3.
HTTP 参数键值对 parameterMap url 中 queryString
在服务端最终会转化为参数键值对。 （二）请求体格式 请求体格式采用 GraphQL
协议。请求体格式分为 API 请求和上下文变量。以商品的 test
接口为例，请求格式如下： 1. API 请求格式

441

-O i

no ne

Oinone7 天从入门到精通

图 4-103 API 请求格式

上下文变量 variables

克

2.  

请求策略 requestStrategy

类型

杰

名称

checkStrategy

CheckStrategyEnum

说明

校验策略： RETURN\_WHEN\_COMPLETED - 全部校验完成再返回 结果
RETURN\_WHEN\_ERROR - 校验错误即返回结果 消息级别： DEBUG("debug",
"调试", "调试"), INFO("info", "信息", "信息"), WARN("warn", "警告",
"警告"), SUCCESS("success", "成功", "成功"),

msgLevel

InformationLevelEnum

ERROR("error", "错误", "错误") 不设置，则只返回错误消息；
上方消息级别清单，越往下级别越高。
只有消息的级别高于或等于该设定级别才返回，否 则会被过滤。

442

Oinone7 天从入门到精通 onlyValidate

Boolean

只校验不提交数据

表 4-41 请求策略 requestStrategy 上下文变量式例如下：

图 4-104 上下文变量式例

no ne

（三）响应体格式

杰

克

-O i

协议响应内容包括 data、extensions 和 errors 三部分，extensions 和 errors
是可缺 省的。data 部分为业务数据返回值。应用业务层可以在 extensions
中添加 API 返回值之外 的扩展信息。extensions 中包含 success、messages 和
extra 三部分，success 标识请求是 否成功。如果业务正确处理并返回，则
errors 部分为空；如果业务处理返回失败，则将错 误信息添加到 errors 中。
正确响应格式示例如下：

图 4-105 正确响应格式

443

Oinone7 天从入门到精通

杰

克

-O i

no ne

错误响应格式示例如下：

图 4-106 错误响应格式

二、Pamirs API DSL Pamirs API DSL 采用 GraphQL 协议。

GraphQL 是一个用于 API
的查询语言，是一个使用基于类型系统来执行查询的服务端
运行时（类型系统由你的数据定义）。GraphQL
并没有和任何特定数据库或者存储引擎绑定，
而是依靠你现有的代码和数据支撑。 Pamirs aPaaS 在 GraphQL 的基础上支持了
BigDecimal、BigInteger、Date、Double、 Html、Money、Void、Map、Obj。

三、Pamirs Query DSL Pamirs Query DSL 采用 RSQL 协议。 444

Oinone7 天从入门到精通 协议原文：RSQL is a query language for
parametrized filtering of entries in RESTful APIs. It’s based on FIQL
(Feed Item Query Language) – an URI-friendly syntax for expressing
filters across the entries in an Atom Feed. FIQL is great for use in
URI; there are no unsafe characters, so URL encoding is not required. On
the other side, FIQL’s syntax is not very intuitive and URL encoding
isn’t always that big deal, so RSQL also provides a friendlier syntax
for logical operators and some of the comparison operators.
中译说明：RSQL 是一种查询语言，用于对 RESTful API
中的条目进行参数化过滤。它 基于 FIQL（Feed Item Query Language）——一种
URI 友好的语法，用于跨 Atom Feed 中 的条目表达过滤器。FIQL 非常适合在
URI 中使用；没有不安全的字符，因此不需要 URL 编 码。另一方面，FIQL
的语法不太直观，URL 编码也不总是那么重要，因此 RSQL 还为逻辑运
算符和一些比较运算符提供了更友好的语法。

no ne

n 4.1.16 框架之网关协议-RQSL 及扩展 一、RSQL / FIQL 解析器

-O i

RSQL 是一种查询语言， 用于对 RESTful API 中的条目进行参数化过滤。 它基于
FIQL （Feed Item Query Language）——一种 URI 友好的语法，用于跨 Atom Feed
中的条目表达过滤器。 FIQL 非常适合在 URI
中使用，没有不安全的字符，因此不需要 URL 编码。另一方面，FIQL
的语法不太直观，URL 编码也不总是那么重要，因此 RSQL
还为逻辑运算符和一些比较运算 符提供了更友好的语法。

克

例如，您可以像这样查询资源：/movies?query=name=="Kill Bill";year=gt=2003
or /movies?query=director.lastName==Nolan and
year&gt;=2000。参见以下示例： 这是一个用 JavaCC 和 Java
编写的完整且经过彻底测试的 RSQL 解析器。因为 RSQL 是 FIQL
的超集，所以它也可以用于解析 FIQL。

杰

（一）语法和语义

以下语法规范采用 EBNF 表示法（ISO 14977）编写。 RSQL
表达式由一个或多个比较组成，通过逻辑运算符相互关联： Logical AND : ; or
and Logical OR : , or or 默认情况下，AND 运算符优先（即，在任何 OR
运算符之前对其求值）。但是，可以使
用带括号的表达式来更改优先级，从而产生所包含表达式产生的任何结果。 input
= or, EOF; or = and, { "," , and }; and = constraint, { ";" , constraint
}; constraint= ( group | comparison ); 445

Oinone7 天从入门到精通 group = "(", or, ")";
比较由选择器、运算符和参数组成。 comparison=选择器、比较运算、参数；
选择器标识要筛选的资源表示形式的字段（或属性、元素…）。它可以是任何不包含保
留字符的非空 Unicode
字符串（见下文）或空格。选择器的特定语法不由此解析器强制执行。
selector=未保留 str； 比较运算符采用 FIQL
表示法，其中一些运算符还具有另一种语法：

• • • • • •

no ne

•

Equal to : == Not equal to : != Less than : =lt= or &lt; Less than or
equal to : =le= or &lt;= Greater than operator : =gt= or &gt; Greater
than or equal to : =ge= or &gt;= In : =in= Not in : =out=

-O i

•

您还可以使用自己的运算符简单地扩展此解析器（请参阅下一节）。

克

comparison-op = comp-fiql | comp-alt; comp-fiql = ( ( "=", { ALPHA } ) |
"!" ), "="; comp-alt = ( "&gt;" | "&lt;" ), \[ "=" \];

杰

参数可以是单个值，也可以是用逗号分隔的括号中的多个值。不包含任何保留字符或空
格的值可以不加引号，其他参数必须用单引号或双引号括起来。 arguments = (
"(", value, { "," , value }, ")" ) | value; value = unreserved-str |
double-quoted | single-quoted; unreserved-str = unreserved, { unreserved
} single-quoted = "'", { ( escaped | all-chars - ( "'" | "" ) ) }, "'";
double-quoted = '"', { ( escaped | all-chars - ( '"' | "" ) ) }, '"';
reserved = '"' | "'" | "(" | ")" | ";" | "," | "=" | "!" | "\~" | "&lt;"
| "&gt;"; unreserved = all-chars - reserved - " "; escaped = "",
all-chars; all-chars = ? all unicode characters ?;

446

Oinone7 天从入门到精通
如果需要在带引号的参数中同时使用单引号和双引号，则必须使用（反斜杠）转义其
中一个引号。如果要按字面意思使用，请将其加倍为\\。反斜杠只有在引用的参数中才有
特殊含义，而不是在未引用的参数。 （二）示例

1.  正常类型 •

-O i

二、Oinone 拓展协议：

no ne

-   name=="Kill Bill";year=gt=2003
-   name=="Kill Bill" and year&gt;2003
-   genres=in=(sci-fi,action);(director=='Christopher
    Nolan',actor==\*Bale);year=ge=2000
-   genres=in=(sci-fi,action) and (director=='Christopher Nolan' or
    actor==\*Bale) and year&gt;=2000
-   director.lastName==Nolan;year=ge=2000;year=lt=2010
-   director.lastName==Nolan and year&gt;=2000 and year&lt;2010
    genres=in=(sci-fi,action);genres=out=(romance,animated,horror),director==Que\*Ta
    rantino
-   genres=in=(sci-fi,action) and genres=out=(romance,animated,horror)
    or director==Que\*Tarantino

杰

克

Is null : =isnull= • Not null : =notnull= • Like to : =like= • Not like
to : =notlike= • Column equal to : =cole= • Not column equal to :
=colnot= • like ‘xxxx%’ : =starts= • not like ‘xxxx%’ :=notstarts= •
like ‘%xxxx’ : =ends= • not like ‘%xxxx’ : =notends= 2. 二进制枚举 •
Intersect : =has= • Not Intersect : =hasnt= • Contain : =contain= • Not
Contain : =notcontain=

n 4.1.17 框架之网关协议-GraphQL 协议 GraphQL 是一个用于 API
的查询语言，是一个使用基于类型系统来执行查询的服务端
运行时（类型系统由你的数据定义）。GraphQL
并没有和任何特定数据库或者存储引擎绑定，
而是依靠你现有的代码和数据支撑。 447

Oinone7 天从入门到精通 一个 GraphQL
服务是通过定义类型和类型上的字段来创建的，然后给每个类型上的每
个字段提供解析函数。例如，一个 GraphQL 服务告诉我们当前登录用户是
me，这个用户的 名称可能像这样：

图 4-107 GraphQL 服务用户名称

no ne

一并的还有每个类型上字段的解析函数：

-O i

图 4-108 每个类型上字段的解析函数

杰

克

一旦一个 GraphQL 服务运行起来（通常在 web 服务的一个 URL
上），它就能接收 GraphQL
查询，并验证和执行。接收到的查询首先会被检查确保它只引用了已定义的类型和字段，然
后运行指定的解析函数来生成结果。

例如这个查询：

图 4-109 解析函数查询 会产生这样的 JSON 结果：

448

Oinone7 天从入门到精通 图 4-110 JSON 结果 了解更多
https://graphql.cn/learn/

n 4.1.18 框架之网关协议-Variables 变量
我们在应用开发过程有一种特殊情况在后端逻辑编写的时候需要知道请求的发起入口，
平台利用 GQL 协议中的 Variables 属性来传递信息，本文就介绍如何获取。

一、前端附带额外变量 属性名

类型

说明

scene

String

菜单入口

克

-O i

no ne

表 4-42 前端附带额外变量

杰

图 4-111 variables 信息中的 scene

二、后端如何接收 variables 信息 通过
PamirsSession.getRequestVariables()可以得到 PamirsRequestVariables
对象。

三、第一个 variable（举例） （一）Step1 修改
PetTalentAction，获取得到前端传递的 Variables

449

no ne

Oinone7 天从入门到精通

图 4-112 修改 PetTalentAction （二）Step2 重启验证

-O i

点击宠物达人不同菜单入口，查看效果

杰

克

图 4-113 效果一

图 4-114 效果二

n 4.1.19 框架之网关协议-后端占位符
在我们日常开发中会有碰到一些特殊场景，需要由前端来传一些如“当前用户
Id”、 “当前用户
code”诸如此类只有后端才知道值的参数，那么后端占位符就是来解决类似问
题的。如前端传\${currentUserId}，后端会自动替换为当前用户 Id。
（一）Step1 后端定义占位符 我们新建一个 UserPlaceHolder 继承
AbstractPlaceHolderParser，用 namespace 来定
义一个“currentUserId”的占位符，其对应值由 value()决定为
“PamirsSession.getUserId().toString()”，active 要为真才有效，priority
为优先级。

450

no ne

Oinone7 天从入门到精通

图 4-115 后端定义占位符

-O i

（二）Step2 前端使用后端占位符

杰

克

我们经常在 o2m 和 m2m 中会设置 domain 来过滤数据，这里案例就是在 field
中设置来 过滤条件，domain="createUid ==
$#{currentUserId}"，注意这里用的是$\#{currentUserId}
而不是\${currentUserId}，这是前端为了区分真正变量和后端占位符，提交的时候会把\#过
滤掉提交。修改宠物达人表格视图的 Template 中 search 部分。

图 4-116 前端使用后端占位符

451

Oinone7 天从入门到精通 （三）Step3 重启看效果

no ne

请求上都带上了 createUid==\${currentUserId}

图 4-117 请求上都已带上 createUid==\${currentUserId}

n 4.1.20 框架之 Session

一、PamirsSession 介绍

-O i

在日常开发中，我们经常需要把一些通用的信息放入程序执行的上下文中，以便业务开
发人员快速获取。那么 Oinone 的 PamirsSession 就是来解决此类问题的。

杰

克

在 Oinone 的体系中 PamirsSession 是执行上下文的承载，
您能从中获取业务基础信息、
指令信息、元数据信息、环境信息、请求参数，以及前后端 MessageHub
等。在前面的学习 过程中我们已经多次接触到了如何使用 PamirsSession： 1.
在【框架之网关协议-后端占位符】一文中，使用
PamirsSession.getUserId()来获 取当前登入用户
Id，诸如此类的业务基础信息； 2. 在 【 框 架 之 网 关 协 议 -variables 变
量 】 一 文 中 ， 使 用 PamirsSession.getRequestVariables()得到
PamirsRequestVariables 对象，进而获取前端 请求的相关信息； 3.
在【模型之持久层配置】一文中，使用
PamirsSession.directive(),来操作元位指 令系统，进而影响执行策略； 4.
在【Action 之校验】、【构建第一个 Function】、【SPI
机制-扩展点】、【面向对 象-继承与多态】等文章中，都用到
PamirsSession.getMessageHub()来设置返回消息。

二、构建模块自身 Session（举例） 不同的应用场景对 PamirsSession
的诉求是不一样的，这个时候我们就可以去扩展 PamirsSession
来达到我们的目的 （一）构建模块自身 Session 的步骤 1.
构建自身特有的数据结构 XSessionData 2. 对 XSessionData
进行线程级缓存封装 3. 利用 Hook 机制初始化 XSessionData 并放到
ThreadLocal 中 4. 定义自身 XSessionApi 5. 实现 XSessionApi
接口、SessionClearApi。在请求结束时会调用 SessionClearApi 的 clear 方法
452

Oinone7 天从入门到精通

no ne

6.  定义 XSession 继承 PamirsSession

图 4-118 扩展 PamirsSession 的经典案例设计图 （二）构建 Demo 应用自身
Session

下面的例子为给 Session 放入当前登陆用户 Step1 新建 DemoSessionData 类

-O i

①

杰

克

构建自身特有的数据结构 DemoSessionData， 增加一个模型为 PamirsUser
的字段 user， DemoSessionData 用 Data 注解，注意要用 Oinone
平台提供的@Data：

图 4-119 新建 DemoSessionData 类

②

Step2 新建 DemoSessionCache

对 DemoSessionData 进行线程级缓存封装

453

no ne

Oinone7 天从入门到精通

③

-O i

图 4-120 对 DemoSessionData 进行线程级缓存封装 Step3 新建
DemoSessionHook

杰

克

利用 Hook 机制，调用 DemoSessionCache 的 init 方法初始化 DemoSessionData
并放到 ThreadLocal 中。 @Hook(module= DemoModule.MODULE\_MODULE),
规定只有增对 DemoModule 模块访问的请
求该拦截器才会生效，不然其他模块的请求都会被 DemoSessionHook 拦截。

图 4-121 新建 DemoSessionHook ④

Step4 新建 DemoSessionApi

图 4-122 新建 DemoSessionApi

454

Oinone7 天从入门到精通 ⑤

Step5 新建 DemoSessionHolder

no ne

a.  实现 DemoSessionApi 接口
b.  实现 SessionClearApi 接口，在请求结束时会调用 SessionClearApi 的
    clear 方法

图 4-123 新建 DemoSessionHolder

Step6 新建 DemoSession

克

-O i

⑥

⑦

杰

图 4-124 新建 DemoSession

Step7 修改 UserPlaceHolder

使用 DemoSession.getUser().getId()替代 PamirsSession.getUserId()

455

no ne

Oinone7 天从入门到精通

⑧

Step8 重启看效果

-O i

图 4-125 修改 UserPlaceHolder

跟【框架之网关协议-后端占位符】的例子效果一样

克

n 4.1.21 框架之分布式消息

一、介绍

杰

消息中间件是在分布式开发中常见的一种技术手段，用于模块间的解耦、异步处理、数
据最终一致等场景。 Oinone 对开源的 RocketMQ
进行了封装，是平台提供的一种较为简单的使用方式，并非 是对 RocketMQ
进行的功能扩展。同时也伴随着两个非常至关重要的目的： a. 适配不同企业对
RocketMQ 的不同版本选择，不至于改上层业务代码。目前已经适配 RocketMQ
的开源版本和阿里云版本。 下个版本会对 API 进行升级支持不同类型
MQ，以适配 不同企业对 MQ 的不同要求，应对一些企业客户已经对 MQ
进行技术选择； b. 对协议头进行扩展：如多租户的封装，saas 模式中为了共用
MQ 基础资源，需要在消 息头中加入必要租户信息。

二、使用准备 demo
工程默认已经依赖消息，这里只是做介绍无需大家额外操作，大家可以用 maven
依赖树命令查看引用关系。 （一）依赖包 1. 核心 POM

456

Oinone7 天从入门到精通 图 4-126 核心 POM 2.

多租户 POM

只要在 boot 工程中引入就可以，不影响开发

图 4-127 多租户 POM 3.

相关功能引入

-O i

no ne

增加模型、触发器都依赖 MQ

克

图 4-128 增加模型、触发器都依赖 MQ （二）yml 配置文件参考

请见【模块之 yml 文件结构详解的】pamirs.event 部分

杰

三、使用说明

（一）发送消息（NotifyProducer） (1) 概述

NotifyProducer 是 Pamirs Event 中所有生产者的基本
API，它仅仅定义了消息发送的
基本行为，例如生产者自身的属性，启动和停止，当前状态，以及消息发送方法。它本身并
不决定消息如何发送，而是根据具体的实现确定其功能。 目前仅实现了
RocketMQProducer，你可以使用下面介绍的方法轻松使用这些功能。 (2)
使用方法 1. Notify 注解方式 ① 使用示例

457

Oinone7 天从入门到精通

图 4-129 Notify 注解方式使用示例

杰

克

-O i

no ne

② 解释说明 1) 使用 Component 注解方式注册 Spring Bean。 2) Notify
注解指定 topic 和 tags。 3) topic 和 tags 对应 NotifyEvent 中的 topic 和
tags。 2. RocketMQProducer 方法调用 ① 使用示例

458

Oinone7 天从入门到精通 图 4-130 RocketMQProducer 方法调用

-O i

no ne

② 解释说明 1) 使用 Component 注解方式注册 Spring Bean。 2) 使用
Autowired 注解方式装配 RocketMQProducer 实例。 3) 使用 send
方法发送指定消息。 4) 在【发送普通消息】方法中，该实现效果与 Notify
注解方式所示完全一致。 5)
在【发送有序消息】方法中，队列选择器是必须配置的，queueSize 属性为 MQ 队
列的总数量，在 broker
中配置。有序消息必须配合有序消费者才能达到有序消费的目
的，否则还是无序的常规消息，消费者需要配置
@NotifyListener(consumerType=ConsumerType.ORDERLY 6)
在【发送事务消息】方法中指定的 group 为
ProducerGroup，事务消息是通过不同 的 Producer 发出的，
事务消息监听请参考 TransactionListener 注解的相关使用方法。 （示例中的
group 与下文介绍中的一致） 3. 使用 TransactionListener 开启事务消息监听
① 使用示例

克

图 4-131 使用 TransactionListener 开启事务消息监听

杰

② 解释说明 1) 实现 NotifyTransactionListener 接口。 2) 使用 Component
注解方式注册 Spring Bean。 3) 添加 TransactionListener
注解注册事务监听，生成对应的生产者。 4) 当前 ProducerGroup
将使用这个类的 BeanName，即"demoTransactionListener"。 如果你想自定义
ProducerGroup，可以使用 TransactionListener 的 value 属性进行设 置。
（二）消费消息（NotifyConsumer） (1) 概述 NotifyConsumer 是 Pamirs Evnet
中所有消费者的基本 API，与 NotifyProducer 类似，
它仅仅定义了消息消费的基本行为，例如消费者自身的属性，启动和停止，当前状态，以及
消息的监听和订阅方法。它本身并不决定消息如何消费以及如何被订阅，而是根据具体的实
现确定其功能。 目前仅实现了
RocketMQEventPushConsumer，你可以使用下面介绍的方法轻松使用这些 功能。
(2) 使用方法 1. 在类上使用 NotifyListener 注解 ① 使用示例 459

Oinone7 天从入门到精通

图 4-132 在类上使用 NotifyListener 注解

杰

克

-O i

no ne

② 解释说明 1) 实现 NotifyEventListener 接口。 2) 使用 Component
注解方式注册 Spring Bean。 3) 当前 ConsumerGroup 将使用这个类的
BeanName，即"demoConsumerClass"。如果你 想自定义 ConsumerGroup，可以使用
Component 的 value 属性进行设置。 4) 从 body
中将可以获取生产者发送的数据对象，并且已经做好了类型处理，可以直
接使用。 5) 使 用 原 生 的 RocketMQ 发 送 的 消 息 ， 类 型 可 能 是 无
法 识 别 的 ， 你 可 以 使 用 NotifyListener 中提供的 bodyClass
来指定类型。 6) topic 和 tags 对应 NotifyEvent 中的 topic 和 tags。 2.
在方法上使用 NotifyListener 注解 ① 使用示例

图 4-133 在方法上使用 NotifyListener 注解 ② 解释说明 1) 使用 Bean
注解方式注册 Spring Bean。 2) 方法返回值为 NotifyEventListener 类型。
460

Oinone7 天从入门到精通 3) 当前 ConsumerGroup 将使用对应方法生成的
BeanName，即"ModelConsumer"和 "dtoConsumer"。如果你想自定义
ConsumerGroup，可以使用 Bean 的 value 属性进行设 置。 （三）实战

-O i

no ne

约定：每个模块下的 Topic 和 Tags
必须定义常量池进行统一管理，主要是为了方便维 护与管理，技术没有限制 (1)
常规消息（举例） ① Step1 新建 PetNotifyEnum 用 PetNotifyEnum
来管理模块的所有 Topic 和 Tags 的常量定义：

克

图 4-134 新建 PetNotifyEnum

② Step2 新建 PetItemInventoryMqProducer

杰

新建 PetItemInventroy 模型对应消息生产者，用于发送 PetItemInventroy
模型变动的 相关消息：

图 4-135 新建 PetItemInventoryMqProducer 461

Oinone7 天从入门到精通 ③ Step3 新建 PetItemInventoryMqConsumer

no ne

新建 PetItemInventoryMqConsumer，订阅 PetItemInventroy
模型变动的相关消息，并 进行相关处理：

图 4-136 PetItemInventoryMqConsumer ④ Step4 修改 PetItemInventroyAction

杰

克

-O i

在修改 PetItemInventroy 完成之后，发送 topic 为
【PetNotifyEnum.PetItemInventroyMq.Topic.PET\_ITEM\_INVENTROY\_CHANGE】，tag
为 【PetNotifyEnum.PetItemInventroyMq.Tag.UPDATE】的消息出去：

图 4-137 修改 PetItemInventroyAction ⑤ Step5 重新看效果 1)
编辑商品库存记录

462

Oinone7 天从入门到精通

图 4-138 编辑商品库存记录 2) 查看后端日志是否打印

no ne

图 4-139 查看后端日志是否打印 (2) 顺序消息（举例）

杰

克

-O i

① Step1 修改 PetItemInventoryMqProducer
增加一个顺序消息发送的方法，发送时根据商品库存的 Id
就分队列，相同队列顺序消 费：

图 4-140 修改 PetItemInventoryMqProducer

463

Oinone7 天从入门到精通 ② Step2 修改 PetItemInventoryMqConsumer

no ne

增加@NotifyListener(consumerType= ConsumerType.ORDERLY)的注解：

图 4-141 修改 PetItemInventoryMqProducer ③ Step3 修改
PetItemInventroyAction

杰

克

-O i

调用 petItemInventoryMqProducer 的顺序消息发送接口：

图 4-142 修改 PetItemInventroyAction ④ Step4 重启看效果 同常规消息 (3)
事务消息（举例） 注：这种写法默认第一次是 UNKNOWN，然后通过 MQ
回调二次确认，在消息时效性要求
高的场景下是不符合要求的。对实效性要求高的，请见下面事务消息-优化（举例）章节。
① Step1 新建 NotifyTransactionListener

464

Oinone7 天从入门到精通

图 4-143 新建 NotifyTransactionListener ② Step2 修改
PetItemInventoryMqProducer

克

-O i

no ne

增加发送事务性消息的方法，通过.setIsTransaction(true)来显示设置该消息是事务
消息，通过
setGroup("petItemInventoryMqTransactionListener")来匹配事务监听处理器：

图 4-144 修改 PetItemInventoryMqProducer

杰

③ Step3 修改 PetItemInventroyAction 调用 petItemInventoryMqProducer
的事务性消息发送接口：

465

Oinone7 天从入门到精通 图 4-145 修改 PetItemInventroyAction ④ Step4
重启看效果 1) 编辑商品库存记录

图 4-146 编辑商品库存记录

no ne

2)  查看后端日志是否打印
    消息回滚，没有消息消费的日志，从日志打印时间上看 MQ 回调会有延迟

-O i

图 4-147 MQ 日志打印一

图 4-148 MQ 日志打印二

杰

克

⑤ Step5 修改 NotifyTransactionListener

图 4-149 修改 NotifyTransactionListener ⑥ Step6 重启看效果
消息提交，并看到消息消费的日志，从日志打印时间上看 MQ 回调会有延迟：

466

Oinone7 天从入门到精通 图 4-150 MQ 日志打印三

图 4-151 MQ 日志打印四 (4) 事务消息-优化（举例）

克

-O i

no ne

① Step1 修改 PetItemInventoryMqProducer 修改 PetItemInventoryMqProducer
事务性消息发送方法 sendTransactionMessage，增 加
NotifyExecuteLocalTransactionCallback 入参：

图 4-152 修改 PetItemInventoryMqProducer

杰

② Step2 修改 PetItemInventroyAction 修改 PetItemInventroyAction 的
update 方法

467

杰

克

-O i

no ne

Oinone7 天从入门到精通

图 4-153 修改 PetItemInventroyAction

③ Step3 重启看效果 编辑商品库存记录，发现消息的处理几乎没有延迟

图 4-154 编辑商品库存记录

④ Step4 模拟业务成功，消息发送失败

468

Oinone7 天从入门到精通

克

-O i

no ne

修改 PetItemInventroyAction 的 update 方法

杰

图 4-155 修改 PetItemInventroyAction 的 update 方法 ⑤ Step5 重启看效果

这个效果跟第一种事务消息一样，消息提交延迟严重：

图 4-156 MQ 日志打印四

图 4-157 MQ 日志打印五

469

Oinone7 天从入门到精通 ⑥ Step6 总结
优化后的事务消息，在正常情况下时效性非常高，异常情况下也能通过
NotifyTransactionListener 做保障。

n 4.1.22 框架之分布式缓存 分布式缓存 Oinone 平台主要用到了
Redis，为了让业务研发时可以无感使用 RedisTemplate 和
StringRedisTemplate，已经提前注册好了 redisTemplate 和
stringRedisTemplate，而且内部会自动处理相关特殊逻辑以应对多租户环境，小伙伴不能
自己重新定义 Redis 的相关 bean。

l

使用说明

杰

克

-O i

no ne

（一）配置说明

图 4-158 分布式缓存配置说明

（二）代码示例

图 4-159 代码示例

n 4.1.23 框架之信息传递

470

Oinone7 天从入门到精通 在【Action 之校验】、【构建第一个
Function】、【SPI 机制-扩展点】、【面向对象
-继承与多态】等文章中，都用到
PamirsSession.getMessageHub()来设置返回信息，基本
上都是在传递后端逻辑判断是异常信息，而且在系统报错时也会通过它来返回错误信息，前
端接收到错误信息则会以提示框的方式进行错误提示。其实后端除了可以返回错误信息以外，
还可以返回调试、告警、成功、信息等级别的信息给前端。但是默认情况下前端只提示错误
信息，可以通过前端的统一配置放开提示级别，有点类似后端的日志级别。

一、不同信息类型的举例 （一）Step1 新建 PetTypeAction

杰

克

-O i

no ne

借用 PetType 模型的表格页做为信息传递的测试入口，为 PetType 模型新增一个
ServerAction，在代码中对信息的所有类型进行模拟：

图 4-160 为 PetType 模型新增一个 ServerAction

（二）Step2 （前端）修改提示级别

在项目初始化时【使用 CLI 构建初始化前端工程】，在 src/middleware
有拦截器的默 认实现，修改信息提示的默认级别为 ILevel.SUCCESS：

图 4-161（前端）修改提示级别

471

Oinone7 天从入门到精通 图 4-162（前端）修改提示级别 （三）Step3
重启系统看效果

no ne

从页面效果中看到已经不在是只提示错误信息。从协议端看错误级别的信息是在
errors 下，其他级别的信息是在 extensions 下：

杰

克

-O i

图 4-163 系统提示

图 4-164 系统提示的请求返回结果

二、MessageHub 的其他说明 是实现上看 MessageHub 是基于 GQL
协议，前后端都有配套实现。同时前端还提供了订 阅 MessageHub
的信息功能，以满足前端更多交互要求，前端 MessageHub 提供的订阅能力使
用教程请见前端高级特性之【框架之 MessageHub】一文。

n 4.1.24 框架之分库分表
随着数据库技术的发展如分区设计、分布式数据库等，业务层的分库分表的技术终将成
老一辈程序员的回忆，谈笑间扯扯蛋既羡慕又自吹地说到“现在的研发真简单，连分库分表
都不需要考虑了”。竟然这样为什么要写这篇文章呢？因为现今的数据库虽能解决大部分场
景的数据量问题，但涉及核心业务数据真到过亿数据后性能加速降低，能给的方案都还有一
472

Oinone7 天从入门到精通
定的局限性，或者说性价比不高。相对性价比比较高的分库分表，也会是现阶段一种不错的
补充。言归正传 Oinone 的分库分表方案是基于 Sharding-JDBC
的整合方案，所以大家得先 具备一点【Sharding-JDBC 的知识】。

一、分表（举例）

-O i

no ne

做分库分表前，大家要有一个明确注意的点就是分表字段的选择，它是非常重要的，与
业务场景非常相关。在明确了分库分表字段以后，甚至在功能上都要做一些妥协。比如分库
分表字段在查询管理中做为查询条件是必须带上的，不然效率只会更低。
（一）Step1 新建 ShardingModel 模型 ShardingModel
模型是用于分表测试的模型，我们选定 userId 作为分表字段。分表字
段不允许更新，所以这里更新策略设置类永不更新，并在设置了在页面修改的时候为
readonly：

克

图 4-165 新建 ShardingModel 模型 （二）Step2 配置分表策略

杰

1.  配置 ShardingModel 模型走分库分表的数据源 pamirsSharding
2.  为 pamirsSharding 配置数据源以及 sharding 规则

<!-- -->

a.  pamirs.sharding.define 用于 Oinone 的数据库表创建用
b.  pamirs.sharding.rule 用于分表规则配置

图 4-166 分库分表配置一

473

-O i

no ne

Oinone7 天从入门到精通

克

图 4-167 分库分表配置二

（三）Step3 配置测试入口

杰

修改 DemoMenus 类增加一行代码，为测试提供入口：

图 4-168 配置测试入口

（四）Step4 重启看效果

1.  自行尝试增删改查
2.  观察数据库表与数据分布

图 4-169 自行尝试增删改查 474

Oinone7 天从入门到精通

图 4-170 观察数据库表与数据分布

-O i

no ne

二、分库分表（举例） （一）Step1 新建 ShardingModel2 模型 ShardingModel2
模型是用于分库分表测试的模型，我们选定 userId 作为分表字段。分
库分表字段不允许更新，所以这里更新策略设置类永不更新，并在设置了在页面修改的时候
为 readonly：

克

图 4-171 新建 ShardingModel2 模型 （二）Step2 配置分库分表策略

杰

1.  配置 ShardingModel2 模型走分库分表的数据源 testShardingDs
2.  新增两个数据库配置:testShardingDs\_0、testShardingDs\_1
3.  为 testShardingDs 配置数据源以及 sharding 规则

<!-- -->

a.  pamirs.sharding.define 用于 Oinone 的数据库表创建用
b.  pamirs.sharding.rule 用于分库分表规则配置

图 4-172 分库分表配置三 475

杰

克

-O i

no ne

Oinone7 天从入门到精通

？？？图 4-173 分库分表配置四 476

杰

克

-O i

no ne

Oinone7 天从入门到精通

？？？图 4-174 分库分表配置五 477

Oinone7 天从入门到精通 （三）Step3 配置测试入口

修改 DemoMenus 类增加一行代码，为测试提供入口:

图 4-175 配置测试入口 （四）Step4 重启看效果

no ne

1.  自行尝试增删改查
2.  观察数据库表与数据分布

杰

克

-O i

图 4-176 自行尝试增删改查

图 4-177 观察数据库表与数据分布

n 4.1.25 框架之搜索引擎 一、使用场景
在碰到大数据量并且需要全文检索的场景，我们在分布式架构中基本会架设
ElasticSearch 来作为一个常规解决方案。在 Oinone
体系中增强模型就是应对这类场景， 其背后也是整合了 ElasticSearch。

二、整体介绍

478

no ne

Oinone7 天从入门到精通

图 4-178 Oinone 与 es 整合设计图 （一）基础环境安装 1.

Canal 安装

杰

克

-O i

见【函数之触发与定时】一文 2. 修改 Canal 配置并重启 新增`Canal`的实例
destinaion: pamirs，监听分表模型的 binlog-filter:
demo.demo\_core\_sharding\_Model……用于增量同步。

479

杰

克

-O i

no ne

Oinone7 天从入门到精通

？？？图 4-179 修改 Canal 配置并重启 480

Oinone7 天从入门到精通 3.

ES 安装

①
下载安装包或直接下载，下载后去除后缀.txt，然后解压文件（下载详情见文末【附件
一】） ② 替换安装目录/config 下的
elasticsearch.yml，主要是文件中追加了三个配置

图 4-180 elasticsearc.yml 追加三个配置 ③ 启动

no ne

a.  导入环境变量（ES 运行时需要 JDK18 及以上版本 JDK 运行环境, ES
    安装包中包含 了一个 JDK18 版本）

克

b.  运行 ES

-O i

图 4-181 导入环境变量

④ 停止 ES

杰

图 4-182 运行 ES

图 4-183 停止 ES 4.

ES 控制台安装

① 下载文件，下载后去除后缀.txt，然后解压文件，解压之后执行 bin/cerebro
或者 bin/cerebro.bat (windows）（下载详情见文末【附件一】） ② 进入
cerebro-0.9.4/bin 目录下执行以下命令

图 4-184 进入 cerebro-0.9.4/bin 目录执行命令 ③ 启动后访问地址:
http://localhost:9000 481

no ne

Oinone7 天从入门到精通

图 4-185 启动后访问地址: http://localhost:9000

-O i

④ Node address 填入 es 服务地址

图 4-186 Cerebro 连接 es 成功

克

恭喜 es 环境搭建完毕，我们开始进入学习。

三、第一个增强模型（举例）

杰

（一）Step1 相关依赖包引入 boot 工程

1.  boot 工程需要指定 ES 客户端包版本，不指定版本会隐性依赖顶层
    spring-boot 依 赖管理指定的低版本
2.  boot 工程加入 pamris-channel 的工程依赖

图 4-187 相关依赖包引入 boot 工程 482

Oinone7 天从入门到精通 （二）Step2 在 pamirs-demo-api 中增加入
pamirs-channel-api 的依赖

图 4-188 在 pamirs-demo-api 中增加入 pamirs-channel-api 的依赖
（三）Step3 修改 application-dev.yml

no ne

在 pamirs-demo-boot 的 application-dev.yml 文件中增加配置
pamirs.boot.modules 增加 channel，即在启动模块中增加 channel
模块。同时注意 es 的配置，是否跟 es 的服务 一致：

-O i

图 4-189 修改 application-dev.yml

克

（四）Step4 DemoModule 增加对 FileModule 的依赖

杰

图 4-190 DemoModule 增加对 FileModule 的依赖 （五）Step5 为
ShardingModel 新建一个增强模型 在大数据量的情况下，我们经常会通过 ES
来提升查询速度

图 4-191 为 ShardingModel 新建一个增强模型 （六）Step6
为增强模型增加菜单入口

483

Oinone7 天从入门到精通 图 4-192 为增强模型增加菜单入口 （七）Step7
重启系统看效果

no ne

1.  第一次访问页面会报错，因为针对该增强模型的相关初始化工作还未完成：

图 4-193 首次访问页面报错

克

-O i

2.  进入传输增强模型应用，访问增强模型列表我们会发现一条记录，并点击全量同步
    初始化 ES，并全量 dump 数据：

杰

图 4-194 全量 dump 数据

3.  再次回到 Demo 应用，进入增强模型页面，可以正常访问并进增删改查操作：

图 4-195 再次回到 Demo 应用 对数据进行修改，我们可以看到以下日志 484

Oinone7 天从入门到精通 图 4-196 数据修改后的日志

四、个性化 dump 逻辑

克

-O i

no ne

有时候我们 dump 逻辑是有个性化需求，那么我们可以重写模型的 synchronize
方法， 函数重写特性我们在【面向对象-继承与多态】一文中已经有详细介绍。
（一）Step1 重写 ShardingModelEnhance 模型的 synchronize 方法
下面例子中我们给 ShardingModelEnhance 模型增加一个 nick
字段，在同步搜索引擎的 时候把 name 赋值给 nick 字段。

杰

图 4-197 重写 ShardingModelEnhance 模型的 synchronize 方法 （二）Step2
重启应用看效果

我们修改记录数据，可以看到 nick
字段也自动赋值了。如果针对老数据记录，我们需
要把新增的字段都自动填充，可以进入传输增强模型应用，访问增强模型列表，找到对应的
记录并点击全量同步：

485

Oinone7 天从入门到精通

no ne

图 4-198 重启应用看效果

五、给搜索增加个性化逻辑

杰

克

-O i

如果我们需要在查询方法中增加逻辑，在前面的教程中一般是重写 queryPage
函数，但 对于增强模型我们需要重写的是 search 函数。 （一）Step1 重写
ShardingModelEnhance 模型的 search 方法

图 4-199 重写 ShardingModelEnhance 模型的 search 方法 （二）Step2
重启应用看效果

图 4-200 重启应用看效果

4.2 前端高级特性

486

Oinone7 天从入门到精通 n 4.2.1 组件之生命周期
组件生命周期的意义所在：比如动态创建了「视图、字段」，等它们初始化完成或者发
生了修改后要执行业务逻辑，这个时候只能去自定义当前字段或者视图，体验极差，平台应
该提供一些列的生命周期，允许其他人调用生命周期的 api 去执行对应的逻辑。

一、实现原理 Effect 集合

LifeCycleName

User

FieldEffect

ViewEffect

生命周期集合

ActionEffect

Effect

LifeCycle

Map

1 监听生命周期 2 创建对应的字段生命周期 3 create Effect 4
创建对应的视图生命周期 5 create Effect 6 创建对应的Action生命周期 7
create Effect 8 初始化生命周期实例 9 存储实例

no ne

10 触发了事件「Field、View、Action」对应的生命周期

查询

12 执行

11 找到对应的LifeCycle

当页面销毁时

13 除对应的生命周期

14 清除对应的生命周期

15 清除对应的生命周期

User

FieldEffect

ActionEffect

Effect

LifeCycle

Map

-O i

LifeCycleName

ViewEffect

图 4-201 实现原理

杰

克

当用户通过内部 API
去监听某个生命周期的时候，内部会动态的去创建该生命周期，每
个生命周期都有「唯一标识」，内部会根据「唯一标识」去创建对应的「Effect」，Effect
会根据生命周期的「唯一标识」实例化一个「lifeCycle」，「lifeCycle」创建完成后，会
被存放到「Heart」中，「Heart」是整个生命周期的心脏，当心脏每次跳动的时候（生命周
期被监听触发）都会触发对应的生命周期。

二、生命周期 API API

描述

返回值

View LifeCycle

onViewBeforeCreated

视图创建前

ViewWidget

onViewCreated

视图创建后

ViewWidget

onViewBeforeMount

视图挂载前

ViewWidget

onViewMounted

视图挂载后

ViewWidget

487

Oinone7 天从入门到精通 视图数据发生修改前

ViewWidget

onViewUpdated

视图数据修改后

ViewWidget

onViewBeforeUnmount

视图销毁前

ViewWidget

onViewUnmounted

视图销毁

ViewWidget

onViewSubmit

提交数据

ViewWidget

onViewSubmitStart

数据开始提交

ViewWidget

onViewSubmitSuccess

数据提交成功

ViewWidget

onViewSubmitFailed

数据提交失败

ViewWidget

onViewSubmitEnd

数据提交结束

ViewWidget

-O i

onViewValidateStart

no ne

onViewBeforeUpdate

视图字段校验

ViewWidget

校验成功

ViewWidget

onViewValidateFailed

校验失败

ViewWidget

onViewValidateEnd

校验结束

ViewWidget

杰

克

onViewValidateSuccess

Field LifeCycle

onFieldBeforeCreated

字段创建前

FieldWidget

onFieldCreated

字段创建后

FieldWidget

onFieldBeforeMount

字段挂载前

FieldWidget

onFieldMounted

字段挂载后

FieldWidget

onFieldBeforeUpdate

字段数据发生修改前

FieldWidget

488

Oinone7 天从入门到精通 字段数据修改后

FieldWidget

onFieldBeforeUnmount

字段销毁前

FieldWidget

onFieldUnmounted

字段销毁

FieldWidget

onFieldFocus

字段聚焦

FieldWidget

onFieldChange

字段的值发生了变化

FieldWidget

onFieldBlur

字段失焦

FieldWidget

onFieldValidateStart

字段开始校验

FieldWidget

onFieldValidateSuccess

校验成功

FieldWidget

校验失败

FieldWidget

no ne

onFieldUpdated

-O i

onFieldValidateFailed

onFieldValidateEnd

校验结束

FieldWidget

表 4-42 生命周期 API

克

上面列出的分别是「视图、字段」的生命周期，目前 Action
的生命周期还没有，后续 再补充。

三、第一个 View 组件生命周期的监听（举例）

杰

（一）Step1 新建 registryLifeCycle.ts

新建 registryLifeCycle.ts，监听宠物达人的列表页。'宠物达人
table\_demo\_core' 为视图名，您需要找后端配合

图 4-202 新建 registryLifeCycle.ts （二）Step2 修改 main.ts

全局注册 lifeCycle

489

Oinone7 天从入门到精通

图 4-203 修改 main.ts

no ne

（三）Step3 看效果

图 4-204 实际效果

四、第一个 Filed 组件生命周期的监听（举例） （一）Step1 修改
registryLifeCycle.ts

杰

克

-O i

通过 onFieldValueChange 增加宠物达人搜索视图的
name（达人）字段的值变化进行监 听。 宠物达人 search:name 代表
视图名:字段名

图 4-205 修改 registryLifeCycle.ts （二）Step2 看效果

输入三个 1，执行三次

490

Oinone7 天从入门到精通

图 4-206 输入三个 1，执行三次

no ne

n 4.2.2 框架之 MessageHub 一、MessageHub

请求出现异常时，提供”点对点“的通讯能力

二、何时使用

杰

克

-O i

错误提示是用户体验中特别重要的组成部分，大部分的错误体现在整页级别，字段级别，
按钮级别。友好的错误提示应该是怎么样的呢？我们假设他是这样的； ①
与用户操作精密契合 a. 当字段输入异常时，错误展示在错误框底部 b.
按钮触发服务时异常，错误展示在按钮底部 ② 区分不同的类型 a. 错误 b. 成功
c. 警告 d. 提示 e. 调试 ③ 简洁易懂的错误信息 在 Oinone
平台中，我们怎么做到友好的错误提示呢？接下来介绍我们的 MessageHub，
它为自定义错误提示提供无限的可能。

三、如何使用 （一）订阅

图 4-207 订阅

491

Oinone7 天从入门到精通 （二）销毁

图 4-208 销毁

四、实战

杰

克

-O i

no ne

让我们在前文中自定义表单，加入我们的
messageHub，模拟在表单提交时，后端报错 信息在字段下方给予提示。
（一）Step1 （后端）重写 PetType 的创建函数 重写 PetType
的创建函数，在创建逻辑中通过 MessageHub 返回错误信息，返回错误信
息的同时要设置 paths 信息方便前端处理：

图 4-209 （后端）重写 PetType 的创建函数

（二）Step 2 修改 PetForm.vue

492

杰

克

-O i

no ne

Oinone7 天从入门到精通

图 4-210 修改 PetForm.vue （三）Step3 PetFormViewWidget.ts 493

杰

克

-O i

no ne

Oinone7 天从入门到精通

494

杰

克

-O i

no ne

Oinone7 天从入门到精通

图 4-211 PetFormViewWidget.ts （四）Step4 刷新页面看效果

495

Oinone7 天从入门到精通

图 4-212 刷新页面看效果

n 4.2.3 框架之 SPI 机制 SPI(Service Provider
Interface)服务提供接口，是一套用来被第三方实现或者扩展 的
API，它可以用来启用框架扩展和替换组件，简单来说就是用来解耦，实现组件的自由插
拔，这样我们就能在平台提供的基础组件外扩展新组件或覆盖平台组件。

no ne

目前定义 SPI 组件

ViewWidget

视图组件

ActionWidget

字段组件

-O i

FieldWidget

动作组件

前提知识点

克

表 4-43 目前定义 SPI 组件

杰

l 使用 TypeScript 装饰器(注解)装饰你的代码：
https://juejin.cn/post/6844903876605280269 1. 通过注解定义一种 SPI
接口(Interface)

图 4-213 通过注解定义一种 SPI 接口(Interface) 2. 通过注解注册提供 View
类型接口的一个或多个实现

496

Oinone7 天从入门到精通 图 4-214 通过注解注册提供 View
类型接口的一个或多个实现 3. 视图的 xml 内通过配置来调用已定义的一种 SPI
组件

克

-O i

no ne

图 4-215 视图的 xml 内通过配置来调用已定义的一种 SPI 组件

图 4-216 组件集成示意图

l

杰

当有多个服务提供方时，按以下规则匹配出最符合条件的服务提供方

SPI 匹配规则

SPI 组件没有严格的按匹配选项属性限定，而是一个匹配规则 a. 按 widget
最优先匹配，配置了 widget 等于是指定了需要调用哪个 widget，此时
其他属性直接忽略 b. 按最大匹配原则（匹配到的属性越多优先级越高） c.
按后注册优先原则

n 4.2.4 框架之网络请求-HttpClient Oinone 提供统一的网络请求底座，基于
graphql 二次封装

一、初始化

497

Oinone7 天从入门到精通

图 4-217 初始化

二、HttpClient 详细介绍 （一）获取实例

图 4-218 获取实例

no ne

（二）接口地址

图 4-219 接口地址

-O i

（三）请求头

杰

（四）variables

克

图 4-220 请求头

图 4-221 variables （五）回调

图 4-222 回调 （六）业务使用-query

498

Oinone7 天从入门到精通

图 4-223 业务使用-query

no ne

（七）业务使用-mutate

-O i

图 4-224 业务使用-mutate

三、如何使用 HttpClient （一）初始化

杰

克

在项目目录 src/main.ts 下初始化 httpClient 初始化必须要做的事: a.
设置服务接口链接 b. 设置接口请求回调 （二）业务实战
前文说到自定义新增宠物表单，让我们在这个基础上加入我们的 httpClient; ①
第一步新增 service.ts

图 4-225 新增 service.ts service.ts

499

no ne

Oinone7 天从入门到精通

图 4-226 service.ts

杰

克

-O i

② 第二步业务中使用

500

杰

克

-O i

no ne

Oinone7 天从入门到精通

501

杰

克

-O i

no ne

Oinone7 天从入门到精通

图 4-227 业务中使用

n 4.2.5 框架之网络请求-Request
在中后台业务场景中，大部分的请求时候是可以被枚举的，比如创建、删除、更新、查
询。在上文中，我们讲了 httpClient
如何自定义请求，来实现自己的业务诉求。本文中讲 到的 Request
是离业务更近一步的封装，他提供了开箱即用的 API，比如 insertOne、
updateOne，它是基于 HttpClient 做的二次封装，当你熟悉 Request
时，在中后台的业务场 景中，所有的业务接口自定义将事半功倍。

一、Request 详细介绍 （一）元数据-Model

① 获取模型实例

502

Oinone7 天从入门到精通 图 4-228 获取模型实例 ② 清除所有缓存的模型

图 4-229 清除所有缓存的模型 （二）元数据-module

① 获取应用实例，包含应用入口和菜单

no ne

图 4-230 获取应用实例 ② 查询当前用户所有的应用

（三）query

杰

克

① 分页查询

-O i

图 4-231 查询当前用户所有的应用

图 4-232 分页查询

② 自定义分页查询-可自定义后端接口查询数据

图 4-233 自定义分页查询

503

Oinone7 天从入门到精通 ③ 查询一条-根据 params 匹配出一条数据

图 4-234 根据 params 匹配出一条数据 ④ 自定义查询

no ne

图 4-235 自定义查询 （四）update

克

（五）insert

-O i

图 4-236 update

图 4-237 insert

杰

（六）delete

图 4-238 delete

二、construct ① 构造一条数据-获取初始化的值，一个页面一般只会调一次：

图 4-239 获取初始化的值 ②
构造一条数据-当需要重复获取初始化值时，第一次使用
constructOne，后面的调用使 用 constructMirror： 504

Oinone7 天从入门到精通

图 4-240 后面的调用使用 constructMirror l function 直接调用后端的
function, 一般在特殊的业务场景中使用，比如导入导出等：

no ne

图 4-241 直接调用后端的 function

三、如何使用

-O i

让我们用 Request 里的函数改造 PetForm/service.ts 里的 addPet 方法： ①
request insertOne

httpClient insertOne

杰

②

克

图 4-242 request insertOne

图 4-243 httpClient insertOne

505

Oinone7 天从入门到精通

图 4-244 insertOne 使用示例 可以看到，在使用 request 的 insertOne
时，我们的代码量大大的减少。为了满足业务
的多变性和便捷性，我们提供了两种方式，大家根据自己的场景自由选择。

no ne

n 4.2.6 框架之网络请求-拦截器

在整个 http
的链路中，异常错误对前端来说尤为重要，他作用在很多不同的场景，通
用的比如 500, 502 等;
一个好的软件通常需要在不同的错误场景中做不同的事情。当用户 cookie
失效时，希望能自动跳转到登录页；当用户权限发生变更时，希望能跳转到一个友
好的提示页；那么如何满足这些个性化的诉求呢？接下来让我们一起了解 Oinone
前端网络 请求-拦截器。

-O i

一、入口

杰

克

在 src 目录下 main.ts 中可以看到
VueOioProvider，这是系统功能提供者的注册入口

图 4-245 VueOioProvider

图 4-246 拦截器的申明入口

二、middleware 在项目初始化时使用【CLI 构建初始化前端工程】，在
src/middleware 有拦截器的默 认实现：

506

-O i

no ne

Oinone7 天从入门到精通

三、interceptor

克

图 4-247 在 src/middleware 有拦截器的默认实现

杰

interceptor 在请求返回后触发，interceptor 有两个回调函数，error 和 next
error 参数 • graphQLErrors 处理业务异常 • networkError 处理网络异常 next
• extensions 后端返回扩展参数

图 4-248 后端返回扩展参数

507

Oinone7 天从入门到精通

杰

克

-O i

no ne

四、interceptor error

508

杰

克

-O i

no ne

Oinone7 天从入门到精通

509

no ne

Oinone7 天从入门到精通

杰

克

五、interceptor next

-O i

图 4-249 interceptor error

图 4-250 interceptor next

六、完整代码

510

杰

克

-O i

no ne

Oinone7 天从入门到精通

511

杰

克

-O i

no ne

Oinone7 天从入门到精通

512

杰

克

-O i

no ne

Oinone7 天从入门到精通

？？？图 4-251 完整代码

n 4.2.7 框架之翻译工具 一、翻译 Oinone
目前的默认文案是中文，如果需要使用其他语言，Oinone 也提供一系列的翻译
能力。

二、定义 ①

首先定义文件

513

no ne

Oinone7 天从入门到精通

zh\_cn.ts

③

杰

克

②

-O i

图 4-252 定义文件

图 4-253 zh\_cn.ts

mian.ts 注册

图 4-254 mian.ts 注册

三、Vue 模板使用

514

杰

克

-O i

no ne

Oinone7 天从入门到精通

图 4-255 Vue 模板使用 l

效果 515

Oinone7 天从入门到精通

图 4-256 实际效果

杰

克

-O i

no ne

四、JS 使用-translate

516

-O i

no ne

Oinone7 天从入门到精通

杰

克

图 4-257 JS 使用-translate

图 4-258 实际效果

五、JS 使用-translateValueByKey translateValueByKey 和 translate
的区别是，获取资源的路径不同，translate 从前
端定义中获取对应的翻译，translateValueByKey
是从平台翻译功能中配置得来，建议使用。

图 4-259 JS 使用-translateValueByKey

六、翻译 dslNode 517

Oinone7 天从入门到精通 处理 xml 的国际化

图 4-260 处理 xml 的国际化

4.3 Oinone 的分布式体验 在 Oinone 的体系中分布式比较独特，boot
工程中启动模块中包含就走本地，不包含就
走远程，本文带您体验下分布式部署以及分布式部署需要注意点。
看下面例子之前先把话术统一下：启动或请求 SecondModule 代表启动或请求
pamirs-second-boot 工程，启动或请求 DemoModule 代表启动或请求
pamirs-demo-boot 工
程，并没有严格意义上启动哪个模块之说，只有启动工程包含哪个模块。

no ne

一、构建 SecondModule 模块 （一）Step1 构建模块工程

杰

克

-O i

参考【构建第一个 Module】，利用脚手架工具构建一个
SecondModule，记住需要修改 脚本。 脚本修改如下：

图 4-261 构建一个 SecondModule（） 生产工程如下：

518

Oinone7 天从入门到精通

图 4-262 生产工程

no ne

（二）Step2 调整配置

杰

克

-O i

修改 application-dev.yml 文件 修改 SecondModule 的 application-dev.yml
的内容 ① base 库换成与 DemoModule
一样的配置，配置项为：pamirs.datasource.base

图 4-263 base 库换成与 DemoModule 一样的配置 ② 修改后端 Server
的启动端口号为 9091

图 4-264 修改后端 Server 的启动端口号为 9091 ③ 修改 bootstrap.yml 文件
设置 dubbo 序列化方式为 pamirs，记得 DemoModule 也要改。 519

杰

克

-O i

no ne

Oinone7 天从入门到精通

520

杰

克

-O i

no ne

Oinone7 天从入门到精通

图 4-265 修改 bootstrap.yml 文件

（三）Step3 构建一个 RemoteTestModel

新建 RemoteTestModel 模型，用于远程调用体验

图 4-266 构建一个 RemoteTestMode

521

Oinone7 天从入门到精通 （四）Step4 新增 SecondSessionHook

@Hook(module= SecondModule.MODULE\_MODULE), 规定只有增对 SecondModule
模块访问 的请求该拦截器才会生效，不然其他模块的请求都会被
SecondSessionHook 拦截。

图 4-267 新增 SecondSessionHook

no ne

（五）Step5 新建 RemoteTestModelAction

克

-O i

在 SecondModule 中新建 RemoteTestModelAction，自定义 RemoteTestModel
模型的 queryPage 函数。方便 debug，看看效果：

图 4-268 新建 RemoteTestModelAction

杰

（六）Step6 boot 工程需要引入 Oinone 的 RPC 包

① 父 pom 的依赖管理中先加入 pamirs-distribution-faas 的依赖

图 4-269 父 pom 的依赖管理中先加入 pamirs-distribution-faas 的依赖 ② 在
pamirs-second-boot 中增加入 pamirs-distribution-faas 的依赖

图 4-270 在 pamirs-second-boot 中增加入 pamirs-distribution-faas 的依赖

522

Oinone7 天从入门到精通 ③ 为 SecondApplication 类增加类注解@EnableDubbo

图 4-271 为 SecondApplication 类增加类注解@EnableDubbo （七）Step7 启动
SecondModule

别忘了启动指令要为 INSTALL。参考【DemoModule 的启动说明】 （八）Step8
Second 工程本地 mvn install，方便 DemoModule 包依赖

二、DemoModule 模块准备 （一）Step1 DemoModule 引入 Oinone 的 RPC 包和
Second 的 API 包

-O i

no ne

① 父 pom 的依赖管理中先加入 pamirs-second-api 和
pamirs-distribution-faas 的依赖

克

图 4-272 父 pom 的依赖管理中先加入 pamirs-second-api 和
pamirs-distribution-faas 的 依赖

杰

② 在 pamirs-demo-api 中增加入 pamirs-second-api 的依赖

图 4-273 在 pamirs-demo-api 中增加入 pamirs-second-api 的依赖 ③ 在
pamirs-demo-boot 中增加入 pamirs-distribution-faas 的依赖

图 4-274 在 pamirs-demo-boot 中增加入 pamirs-distribution-faas 的依赖 ④
为 DemoApplication 类增加类注解@EnableDubbo

523

Oinone7 天从入门到精通 图 4-275 为 DemoApplication
类增加类注解@EnableDubbo （二）Step2 修改 DemoModule 定义

修改 DemoModule 的依赖注解，增加 SecondModule.MODULE\_MODULE

图 4-276 修改 DemoModule 定义 （三）Step3 修改 pamirs-demo-boot 的
bootstrap.yml 文件

克

-O i

no ne

参考 SecondModule 修改 dubbo 的序列化方式为 pamirs （四）Step4 修改
pamirs-demo-boot 的 DemoApplication 为依赖模块配置扫描包路径，修改
DemoApplication 增加 second 的扫描包，在日常开
发中小伙伴的应用肯定不是以 pamirs 开头，所以大家别忘了 SpringBoot
的基本配置。在【构 建第一个
Module】一文也提到我们在启动工程中需要配置启动模块和依赖模块的扫描路径。

杰

图 4-277 修改 pamirs-demo-boot 的 DemoApplication

三、分布式部署体验

以上工作准备好以后，我们就可以通过 DemoModule 来远程调用 SecondModule。
① 第一个 Case(前端把请求分别打到 DemoModule、SecondModule)
在日常研发中，不同模块的菜单整合也是非常常见的，比如把 B 模块的菜单挂在
A 模块 中。这个 Case 就是在讲解如何做到跨模块的菜单整合： （一）Step1
修改前端工程的 vue.config.js 利用 node 的 proxy，分别把 DemoCore 转发到
8090 端口，把 SecondCore 转发到 8091 端口，把默认其他模块转发到 8090
端口。localhost 还是 127.0.0.1 跟浏览器地址框输入 保持一致：

524

杰

克

-O i

no ne

Oinone7 天从入门到精通

图 4-278 修改前端工程的 vue.config.js （二）Step2 修改 DemoMenus

增加一个 RemoteTestModel 的管理入口，这里需要指定菜单的 module 为
DemoModule， 不然应用会切换到 SecondModule

图 4-279 修改 DemoMenus （三）Step3 重启前端应用看效果 525

Oinone7 天从入门到精通 1.
点击远程模型菜单，可以正常进行增、删、改、查操作。

no ne

图 4-280 击远程模型菜单

-O i

2.  SecondSessionHook 起作用 “second hook”并打印出来，前端请求没有再进过
    DemoModule 再远程调用 SecondModule，而是直接打到了 SecondModule 上。

②

克

图 4-281 SecondSessionHook 起作用 第二个 Case（跨模块代理，自动走远程）

（一）Step1 新建 RemoteTestModelProxy

杰

在 DemoModule 中新建 RemoteTestModelProxy 代理继承 RemoteTestModel：

图 4-282 新建 RemoteTestModelProxy （二）Step2 修改 DemoMenus

增加一个 RemoteTestModelProxy 的管理入口

图 4-283 增加一个 RemoteTestModelProxy 的管理入口 526

Oinone7 天从入门到精通 （三）Step3 重启看效果 点击菜单：远程代理

no ne

1.  

图 4-284 点击远程代理 2.

在 SecondModule 的 RemoteTestModelAction 中 debug，会发现 DemoModule
会自动调用

杰

克

-O i

RemoteTestModel 模型的 queryPage。

图 4-285 DemoModule 自动调用 RemoteTestModel 模型的 queryPage 3.

但不走 SecondSessionHook

“second
hook”并没有打印出来，为什么？在函数相关特性系列文章中【面向切面拦截器】一文中介绍到“不是前端直接发起的请求不会生效”，可能小伙伴有疑问，我不是
前端点击的吗？是的，但经过 DemoModule 再调用
SecondModule，系统会判定为后端调用。 ③

第三个 Case(远程调用自定义函数)

（一）Step1 新增函数 RemoteTestModelService 和
RemoteTestModelServiceImpl

SecondModule 定义 RemoteTestModelService，用于 DemoModule
的调用。SecondModule 记得再次 mvn install

527

Oinone7 天从入门到精通

杰

克

-O i

no ne

图 4-286 新增函数 RemoteTestModelService

图 4-287 新增函数 RemoteTestModelServiceImpl

（二）Step2 新增 RemoteTestModelProxyAction

1.  新增 RemoteTestModelProxyAction， 并定义 queryPage、 hello、
    remoteTest 等 Action， 方便前端点击测试
2.  引入 RemoteTestModelService，分别调用 queryPage、hello、remoteTest
    方法

528

克

-O i

no ne

Oinone7 天从入门到精通

图 4-288 新增 RemoteTestModelProxyAction

杰

（三）Step3 重启看效果

点击按钮看看效果

图 4-289 点击 remoteTest 按钮看效果 529

Oinone7 天从入门到精通 ④

总结一、二 、三 Case

no ne

把 SecondModule 模块停掉，则上面一、二 、三 Case 都会报错。如果
DemoModule 的 pamirs-demo-boot 中依赖加上 pamirs-second-core，同时
application-dev.yml 文件中 pamirs.boot.modules 加上 second\_core
的配置，则 DemoModule 和 SecondModule 部署在一 起，再把前端 node
请求代理都转发到 DemoModule 模块上。则只需要启动 pamirs-demo-boot
就可以了。这个留给小伙伴们自己实验
分布式不分布式只是部署方式的差异，代码层面没有差异，有了体感以后再去看【Oinone
独特性之单体与分布式的灵活切换】一文可能会有更深的体会 注意点： 1.
编码远程调用服务时要确保入参和服务端定义的一样，可以用平台提供
ArgUtils.convert 进行转换； 2. 部署分布式情况下部署要用 ng
或其他方式进行转发，针对前端发起的请求，根据请 求 url
中带的模块信息转发到对应有启动该模块的 boot 应用中。

4.4 Oinone 的分布式体验进阶

一、模块启动的最小集

-O i

在分布式开发中，每个人基本只负责自己相关的模块开发。所以每个研发就都需要一个
环境，比如一般公司会有（N 个）项目环境、1 个日常环境、1 个预发环境、1
个线上环境。 在整项目环境的时候就特别麻烦，Oinone
的好处是在于每个研发可以通过 boot 工程把需要 涉及的模块都启动在一个 jvm
中进行开发，并不依赖任何环境，在项目开发中，特别方便。
但当公司系统膨胀到一定规模，大到很多人都不知道有哪些模块，或者公司出于安全策略考
虑希望走原有的分布式模式，或者启动速度的原因毕竟模块多了启动的速度也会降下来。本
文就给大家介绍 Oinone 与经典分布式组织模式的兼容性。

杰

克

我们来改造 SecondModule 模块，让该模块的用户权限相关都远程走
DemoModule。 （一）Step1 修改 SecondModule 的启动工程
application-dev.yml 文件 除了 base、second\_core
两个模块保留，其他模块都去除了。

图 4-290 修改 SecondModule 的启动工程 application-dev.yml 文件
（二）Step2 去除 boot 工程的依赖

去除 SecondModule 启动工程的 pom 依赖

530

no ne

Oinone7 天从入门到精通

图 4-291 去除 boot 工程的依赖 （三）Step3 重启 SecondModule

杰

克

-O i

远程模型和远程代理菜单均能访问正常

图 4-292 远程模型和远程代理菜单均能访问正常

（四）Step4 SecondModule 增加对模块依赖

我们让 SecondModule 增加用户和权限模块的依赖，期待效果是：SecondModule
会对用 户和权限的访问都会走 Dome 应用，因为 Demo 模块的启动工程中包含了
user、auth 模块。 1. 修改 pamirs-second-api 的 pom 文件，增加对 user 和
auth 的 api 包依赖

图 4-293 修改 pamirs-second-api 的 pom 文件 531

Oinone7 天从入门到精通 2. 修改 SecondModule 类，增加依赖定义

图 4-294 修改 SecondModule 类 （五）Step5 修改 RemoteTestModel 模型

为 RemoteTestModel 模型增加 user 字段

no ne

图 4-295 为 RemoteTestModel 模型增加 user 字段 （六）Step6
重启系统看效果

克

-O i

1.  mvn install pamirs-second 工程，因为需要让 pamirs-demo
    工程能依赖到最新的 pamirs-second-api 包
2.  重启 pamirs-second 和 pamirs-demo
3.  两个页面都正常

杰

图 4-296 远程模型的代理列表

图 4-297 页面显示正常

二、PmetaOnline 的 NEVER 指令（开发时环境共享）
我们在模块之启动指令一文中介绍过 【-PmetaOnline
指令】，该参数用于设置元数据 在线的方式，如果不使用该参数，则 profile
属性的默认值请参考【服务启动可选项】。 -PmetaOnline 参数可选项为： 1.
NEVER - 不持久化元数据，会将 pamirs.boot.options 中的 updateModule、
reloadMeta 和 updateMeta 属性设置为 false； 2. MODULE -
只注册模块信息，会将 pamirs.boot.options 中的 updateModule 属性设 置为
true，reloadMeta 和 updateMeta 属性设置为 false； 532

Oinone7 天从入门到精通

no ne

3.  ALL - 注册持久化所有元数据，会将 pamirs.boot.options 中的
    updateModule、 reloadMeta 和 updateMeta 属性设置为 true。 Oinone
    的默认模式下元数据都是注册持久化到 DB
    的，但当我们在分布式场景下新开发
    模块或者对已有模块进行本地化开发时，做为开发阶段我们肯定是希望复用原有环境，但不
    对原有环境照成影响。那么-PmetaOnline
    就很有意义。让我们还没有经过开发自测的代码
    产生的元数据仅限于开发本地环境，而不是直接影响整个大的项目环境。 l
    PmetaOnline 指令设置为 NEVER（举例） （一）Step1 为 DemoCore
    新增一个 DevModel 模型

图 4-298 为 DemoCore 新增一个 DevModel 模型 （二）Step2 为 DevModel
模型配置菜单

-O i

图 4-299 为 DevModel 模型配置菜单

杰

克

（三）Step3 启动 Demo 应用时指定-PmetaOnline

图 4-300 启动 Demo 应用时指定-PmetaOnline （四）Step4 重启系统看效果 ①
查看元数据

图 4-301 查看元数据 533

Oinone7 天从入门到精通 ② 菜单与页面能正常操作

克

-O i

no ne

图 4-302 开发模型菜单可正常操作

图 4-303 开发模型详情页面可正常操作

（五）Step5 Never 模式需注意的事项

杰

1.业务库需设定为本地开发库，这样才不会影响公共环境，因为对库表结构的修改还
是会正常进行的

2.如果不小心影响了公共环境，需要对公共环境进行重启恢复
3.系统新产生的元数据（如：例子中的【开发模式】菜单）不受权限管控
三、分布式开发约定 （一）设计约定

1.  跨模块的存储模型间继承，在部署时需要跟依赖模块配置相同数据源。这个涉及模
    块规划问题，比如业务上的 user 扩展模块，需要跟 user 模块一起部署。
2.  跨模块的多对多关系，配置中间表模型，【字段类型之关系与引用】一文中的
    M2M 字段介绍
3.  基础依赖：base
4.  canal 相关参考：【函数之触发与定时】中提到的修改 topic 方案
    （二）编码约定

534

Oinone7 天从入门到精通 1. 跨模块间用 service
来调用，避免直接调用模型的数据管理器（如 new 非本模块 Model().queryPage
等）。结构性代码可以用 Oinone 提供研发辅助工具进行提效 率。 2.
在【构建第一个 Function】一文中有提到，需要在 API 包中声明注解了@Fun
注解 的函数接口，并在接口的方法上加上@Function 注解。

4.5 研发辅助 这里都是一些提升研发效率的小工具。

n 4.5.1 研发辅助之插件-结构性代码

no ne

研发辅助意在 1. 消灭研发过程中的重复性工作提升研发效率，如结构性代码 2.
提供生产示例性代码，如果根据模型生成导入导出、view
自定义配置等经常性开发

一、插件安装

下载插件，解压以后选择与 Idea
版本适合的插件进行安装（下载详情见文末【附件一】）

二、研发辅助之配置式结构性代码生成器

杰

克

-O i

我们在开发过程中为了日后代码易于维护和修改，往往会做工程性的职责划分。
除去 模型外会有： 1. 代理模型和代理模型 Action 来负责前端交互 2.
以面向接口的形式来定义函数，就会有 api 和实现类之分 3.
如果项目有多端，那么如代理模型和代理模型 Action 又要为每一个端构建一份
在大型项目的初始阶段，我们需要手工重复做很多事情，特别麻烦。现在用
Oinone 的 研发辅助插件的结构性代码生成器，就可以避免前面的重复工作 l
插件执行的配置文件

535

杰

克

-O i

no ne

Oinone7 天从入门到精通

图 4-304 插件执行的配置文件

三、研发辅助之多模型结构性代码生成器
是配置式结构性代码生成器的补充，应对开发后期维护中新增模型的场景。它的不同点
在于只要选择模型文件就可以，不需要专门编写 xml
文件。生成的文件默认就在模型所在路 径下。 （一）Step1 菜单栏上找到
Oinone，并点击子菜单：多模型结构性代码生成器

图 4-305 并点击子菜单：多模型结构性代码生成器 536

Oinone7 天从入门到精通 （二）Step2 设置必要的信息

no ne

1.  模型前缀
2.  模型的所属模块
3.  代理模型的模块 这三个信息分别用于构建：

<!-- -->

1)  代理模型的 Model\_Model = 模型前缀.代理模型的模块.代理模型类名
2)  服务的 FUN\_NAMESPACE = 模型前缀.代理模型的模块.服务类名

图 4-306 设置必要的信息

杰

克

-O i

（三）Step3 选择为哪些模型生成对应的结构性代码

图 4-307 选择为哪些模型生成对应的结构性代码

537

Oinone7 天从入门到精通 （四）Step4 代码在模型所在目录

no ne

生成的文件默认就在模型所在路径下，您可以手动拖动到对应的包路径当中去

图 4-307 代码在模型所在目录

n 4.5.2 研发辅助之 SQL 优化

一、发现慢 SQL

克

-O i

Oinone 体系中是不需要针对模型写 SQL
的，默认提供了通用的数据管理器。在带来便 利的情况下，也导致传统的 sql
审查就没办法开展。但是我们可以以技术的手段收集慢 SQL 和限制问题 SQL
执行。 1. 慢 SQL 搜集目的：去发现非原则性问题的慢 SQL，并进行整改； 2.
限制问题 SQL 执行：对应一些不规范的 SQL
系统上直接做限制，如果有特殊情况手 动放开。

杰

这个功能并没有直接加入到 Oinone
的版本中，需要业务自行写插件，插件代码如下（如 下图 4-308
所示）。大家可以根据实际情况进行改造比如： 1. 堆栈入口，例子中只是放了
pamirs，可以根据实际情况改成业务包路径； 2. 对慢 SQL 的定义是 5s 还是
3s，根据实际情况变。

538

杰

克

-O i

no ne

Oinone7 天从入门到精通

539

杰

克

-O i

no ne

Oinone7 天从入门到精通

？？？图 4-308 插件代码

二、限制问题 SQL Oinone 的非法 SQL 校验插件：IllegalSQLInterceptor
目前版本 Oinone 并没有生效该非法 SQL
校验的拦截器，因为这个插件晚于业务加入，
所以为了避免伙伴应用因为插件原因改造就放到下个版本去，后续业务系统升级版本的时候，
需要注意这个点。

540

Oinone7 天从入门到精通 第五章 Oinone 的 CDM

5.1 CDM 的背景介绍

no ne

Oinone CDM 是商业领域的通用模型， 更是结合 Oinone
的技术特性提出的新工程建议， 本章节重点会针对 CDM
的设计背景、原理以及商业领域的基础支撑模型展开介绍。 1. CDM 的背景介绍
2. CDM 的设计原理 3. 基础支撑之用户与客户域 4. 基础支撑之商业关系域 5.
基础支撑之结算域 6. 商业支撑之商品域 7. 商业支撑之库存域 8.
商业支撑之执行域

如果说低代码开发框架输出技术标准， CDM 则是结合 Oinone
技术特性和软件工程设计， 让输出数据标准变成可能。

一、背景介绍 无法照搬的最佳实践

-O i

1.  

杰

克

要了解引入 CDM
的初衷，得从互联网架构的演进开始，了解其过程，就知道为什么说 Oinone 的
CDM 是中台架构的最佳技术实践的核心！我们在【互联架构做为最佳实践为何失
效】一文中介绍过互联网技术发展的四个阶段，特别平台化到中台化的阶段，目的是在一套
规范下让听的见炮火声音的团队自行决定业务系统发展，适用多业务线（或多场景应用）独
立发展。
互联网架构在演进过程中碰到的问题跟企业数字化转型过程中碰到的问题是非常类似：
①
随着企业业务在线化后对系统性能、稳定都提出了更高的要求，而且大部分企业的
内部很多系统相互割裂导致，导致很多重复建设，所以我们需要服务化、平台化。
②
同时没有一个供应商能解决企业所有商业场景问题，又需要多个供应商共同参与，
所以把供应商类类比成各个业务线，在一套规范下让供应商自行决定业务系统发展。
既然跟阿里当初在架构演进过程中碰到的问题非常类似，那么是不是照搬阿里中台架构
方案到企业就好了？当然不是，因为历史原因阿里的中台架构是采用的平台共建模式：“让
业务线研发以平台设计好的规范进来共同开发”，其本质还是平台主导模式，它是有非常大
的历史包袱。我们想象各个供应商的共建一个交易平台或商品平台，那是多么荒唐的事情，
平台化已经足够的复杂了，还让不同背景、不同企业的研发一起共建，最后往往导致企业架
构负载过重，这时对企业来说便不再是赋能而是“内耗”。
那么如果没有历史包袱，我们重新设计，站在上帝视角去看有没有更好的方式呢？当然
有。 2. 借鉴微软的 CDM 这里我们借鉴微软的 CDM 理念，CDM 这个概念最早是
2016 年微软宣布“以 Dynamics 365 的形式改造其 CRM 和
ERP”战略时提出的。微软给它的定义是：用于存储和管理业务实体的
业务数据库，而且是开箱即用的。CDM
不仅仅提供标准实体，它还允许用户建立个性化的实
体，用户可以扩展标准实体也可以增加和标准实体相关的新实体。

541

Oinone7 天从入门到精通

杰

克

-O i

no ne

CDM
可能并不性感，但绝对是非常必要的。它成为了微软的很多产品的基础，是构建了
无数业务领域的原型。同时微软也期望它能成为快速实现数据交换和迁移的标准，这个有点
像菜鸟网络推出的奇门，让所有 TMS、OMS、WMS 都基于一套数据接口 API
进行互通，一套标
准是为了解决一个行业问题，而不是具体某一个企业一个集团的问题。 我们发现
CDM 的理念跟我们想要的“企业级的数据标准”是非常吻合的。但是我们也不
能照搬照抄，虽然微软的 CDM
很好的解决了数据割裂问题，但就模型来说就够大家喝一壶了，
模型库非常庞大而且复杂，学习成本巨高。 3.
数字化时代软件会产生新的技术流派
我们知道传统软件的设计理念：侧重在模型对业务支撑全面性上。优点体现为配置丰富，
缺点模型设计过于复杂，刚开始有前瞻性，但在理解、维护都非常困难，随着业务发展系统
原先的设计逐渐腐化，异常笨重。 而 Oinone 的 CDM
设计理念：侧重在简单、灵活、统一上，体现为在上层应用开发时，
每一业务领域保持独立，模型简单易懂，并结合 Oinone
的低代码开发机制进行快速开发， 灵活应对业务变化。 所以我更想说 Oinone 的
CDM 是微软 CDM 的在原有基础上，与互联网架构结合，利用 Oinone
低代码开发平台特性形成新的工程化建议。Oinone-CDM
不以把模型抽象到极致，支 撑“所有业务可能性”为目标，而是抽象
80%通用的设计，保持模型简单可复用，来解决数
据割裂问题，并保持业务线独立自主性、快速创新的能力。

图 5-1 Oinone-CDM 特性

二、Oinone 的 CDM 本质是创新的工程化建议 引入 CDM
以后系统工程结构会有什么变化，跟大家认知的互联网架构有什么区别。
原本上层的业务线系统，需要调用各个业务平台提供的功能，增加 CDM
以后也就是我们
右的图，每个业务线就像一个独立右边。看上去复杂了，其实对业务线来说更加简单了。
互联网整体平台化带来的问题：
1.业务线每次业务调整都需要给各个平台提需求；
2.业务平台研发需要了解所有业务线的知识再做设计，对研发要求非常高；
3.各个业务域的不同需求相互影响包括系统稳定性、研发对需求响应的及时性。
结合 Oinone 特性提出的新工程建议：
1.一些通用性模块继续以平台化的方式存在，能力完全复用；
2.业务线自建业务平台，保持业务线的独立性和敏捷性； 3.业务线以 CDM
为原型，保证核心数据不割裂，形成一致的数据规范。

542

Oinone7 天从入门到精通

no ne

图 5-2 互联网整体平台化带来的问题 VS 结合 Oinone 特性提出的新工程建议

三、CDM 思路示意图

杰

克

-O i

该示例中 Oinone-CDM
的商品域不仅仅提供标准实体，保证各个业务系统的对商品的通
用需求、简单易懂，在我们星空系列业务产品中如全渠道运营、B2B
交易等系统以此为基础
建立属于自身个性化的实体，可以扩展标准实体也可以增加和标准实体相关的新实体。
带来的好处： 1.
通过多种继承方式，继承后的模型可扩展模型本身、模型行为等，从而解决业务独
立性问题; 2. 通过 CDM 层统一数据模型，从而解决多应用数据割裂问题.

图 5-3 Oinone-CDM 思路示意图

5.2 CDM 之工程模式 一、两种工程模式介绍 Oinone
推荐的两种工程模式都保留互联网特性，如跟业务无关的基础平台还是采用平
台化思路建设。二种侧重点差异如下： 543

Oinone7 天从入门到精通

杰

克

-O i

no ne

第一种：比较适合企业采用多供应商联合开发场景，先以业务区分，各个业务线有独立
的领域平台，最大限度保持不同业务线的独立性，有利于各个业务线独立发展（目前
Oinone
上层星空系列产品采用这种工程模式，因为我们期望的时候帮助企业构建软件生态，必然要
考虑不同供应商联合开发场景）。
第二种：比较接近传统互联网架构，先按平台领域区分，如商品领域：商品平台做总工
程，但里面按业务区分模块分子工程来保持业务相互独立，相对于第一种把领域的代码放一
起，带来好处强化大家思考模型通用性。但不适用于跨公司主体间配合。

图 5-4 Oinone-CDM 的两种工程模式 注意事项： 1. Oinone 兼容传统互联网架构
2. 不管哪种模式，都需要解决 CDM 的维护问题

二、CDM 维护的常见问题： 544

Oinone7 天从入门到精通 Q1：CDM 层缺少模型怎么办？

A1：CDM
层模型是逐步完善和丰富的。如果是特定业务自己需要的模型，这类模型无通
用性。则加到自己的工程中；如果是通用的，则架构组确定是否需要纳入到 CDM。
Q2：CDM 层已有的模型缺少字段怎么办？ A2：CDM
层模型的字段也是逐步完善和丰富的，通用的字段在架构组确定后也会被吸收
进来 Q3：CDM 层不同业务线相互影响怎么办？
A3：扩展字段最好带上自有前缀标志，如果觉得通用则提交架构组走模型缺少字段加入
Q4：CDM 层某模型新增加了的字段，但原先业务线已经加了相同含义字段怎么办？
A4：业务线可以把自己的字段 related 到 CDM 增加的新字段，并做数据迁移

no ne

5.3 基础支撑之用户与客户域 一、三户概念 （一）三户由来

杰

克

-O i

介绍下经典的三户模型，它是电信运营支持系统的基础。三户模型即客户、用户和帐户，
来源于 etom
的模型。这三者之间的关系应该是一个相互关联但又是独立的三个实体，这种
关联只是一个归属和映射的关系，而三个实体本身是相互独立的，分别是体现完全不同的几
个域的信息，客户是体现了社会域的信息，用户体现了业务域的信息，帐户体现的是资金域
的信息。 1. 客户：它是个社会化的概念，一个自然人或一个法人。 2.
用户：它是客户使用运营商开发的一个产品以及基于该产品之上的增值业务时，产
生的一个实体。如果说一个客户使用了多个产品，那么一个客户就会对应好几个用户（即产
品）。 3.
账户：它的概念起源于金融业，只是一个客户在运营商存放资金的实体，目的是为
选择的产品付费。 （二）Oinone 的三户
在原三户模型中【用户】是购买关系产生的产品与客户关系的服务实例，在互联网发展
中用户的概念发生了非常大的变化，【用户】概念变成了：使用者，是指使用电脑或网络服
务的人，通常拥有一个用户账号，并以用户名识别。而且新概念在互联网强调用户数的大背
景下已经被普遍介绍，再去强调电信行业的用户概念就会吃力不讨好。而且不管是企业应用
领域和互联网领域，原用户概念都显得过于复杂和没有必要。也就有了特色的
Oinone 的三 户模型： 1. 客户：它是个社会化的概念，一个自然人或一个法人
2.
用户：使用者，是指使用电脑或网络服务的人，通常拥有一个用户账号，并以用户
名识别 3.
账户：它的概念起源于金融业，只是一个客户在运营商存放资金的实体，目的是为
选择的产品付费

二、Oinone 的客户与用户
三户模型是构建上层应用的基础支撑能力，任何业务行为都跟这里两个实体脱不了干系。
以客户为中心建立商业关系与商业行为主体，以用户为中心构建一致体验与操作行为主体。
在底层设计上二者相互独立并无关联，由上层应用自行作关联绑定，往往在登陆时在

545

Oinone7 天从入门到精通

no ne

Session
的处理逻辑中会根据【用户】去找到对应一个或多个【商业(主体)客户】，Session
的实现可以参考【框架之 Session】一文

图 5-5 Oinone 的客户与用户 （一）客户设计说明

杰

克

-O i

1.  PamirsPartner 作为商业关系与商业行为的主体，派生了两个子类
    PamirsCompany 与 PamirsPerson 分别对应：公司(法人)客户、自然人客户
2.  公司(法人)客户 PamirsCompany 对应多个组织部门 PamirsDepartment，
    公司(法人) 客户 PamirsCompany 对应多个员工 PamirsEmployee
3.  部门 PamirsDepartment 对应一个公司(法人)客户
    PamirsCompany，对应多个员工 PamirsEmployee
4.  员工 PamirsEmployee 对应多个部门
    PamirsDepartment，对应一个或多个公司(法 人)客户
    PamirsCompany，其中有一个主的 （二）用户设计说明
5.  PamirsUser
    作为一致体验与操作行为主体，本身绑定登陆账号，并且可以关联多
    个三方登陆账户 PamirsUserThirdParty （三）客户与用户如何关联（举例）
    l 例子设计：
6.  新建 demo 系统的 PetComany 和 PetEmployee，用 PetEmployee
    去关联用户。
7.  当用户登陆时， 根据用户 Id 找到 PetEmployee， 在根据 PetEmployee
    找到 PetComany， 把 PetComany 放到 Session 中去
8.  修改 PetShop 模型关联一个 PamirsPartner， PamirsPartner 的信息从
    Session 取。 ① Step1 pamirs-demo-api 工程增加依赖，并且 DemoModule
    增加对 BusinessModule 的依 赖

图 5-6 pamirs-demo-api 工程增加依赖 、 @Module.dependencies 中增加
BusinessModule.MODULE\_MODULE

546

Oinone7 天从入门到精通

图 5-7 @Module.dependencies 中增加 BusinessModule.MODULE\_MODULE

no ne

② Step2 新建 PetComany 和 PetEmployee，以及对应的服务

克

-O i

图 5-8 新建 PetEmployee

杰

图 5-9 新建 PetComany

图 5-10 新建 PetEmployee 对应服务

547

no ne

Oinone7 天从入门到精通

-O i

图 5-11 新建 PetEmployee 对应服务

杰

克

图 5-12 新建 PetComany 对应服务

图 5-13 新建 PetComany 对应服务 ③ Step3 Session 中增加 PamirsPartner 对
DemoSession\DemoSessionApi\DemoSessionData\DemoSessionHolder 进行修改，增
加 PetCompany getCompany()相关方法。可以参考【框架之 Session】一文：

548

克

-O i

no ne

Oinone7 天从入门到精通

杰

图 5-14 Session 中增加 PamirsPartner

④ Step4 修改 PetShop 模型，以及重写 PetShop 的默认 create 方法 PetShop
模型增加 partner 字段，修改 openTime 为 readonly=true 的配置，变成带条
件 readonly。scene == 'redirectUpdatePage'表示只有再修改的时候为只读

图 5-15 修改 PetShop 模型 创建 PetShopAction 类重写 PetShop 模型的
create 方法

549

no ne

Oinone7 天从入门到精通

图 5-16 创建 PetShopAction 类重写 PetShop 模型的 create 方法

-O i

⑤ Step5 增加 PetEmployee 和 PetCompany 的管理入口 DemoMenus 增加@UxMenu
注解申明

克

图 5-17 DemoMenus 增加@UxMenu 注解申明

杰

⑥ Step6 重启应用看效果 1)
创建公司与员工，在创建的同时建立公司与员工，员工与用户关联

图 5-17 创建公司与员工

550

Oinone7 天从入门到精通 图 5-18 员工与用户关联

no ne

2)  创建一个宠物店铺 新增 Oinone 的宠物店铺
    003，但不要选择所属主体。点击确定按钮后期望效果是：会 从 session
    中自动获取 admin 关联的
    PetCompany，并填充到宠物店铺的所属主体字段中：

克

-O i

图 5-19 新增 Oinone 的宠物店铺 003

图 5-20 自动获取 admin 关联的 PetCompany

杰

⑦ Step7 注意事项 1) PetEmployee551的 create 方法应该重写，再调用
PamirsEmployeeService551的 create 方法； 2) PetEmployeeQueryServiceImpl
的 queryByUserId 方法实现上也没有考虑一个用户 绑定多个员工的模式； 3)
employeeType551字段默认是不展示的，但是例子中又没有重写 PetEmployee551的
create 方法，所以这个值是空的。但这个字段为空，会导致报错。解决办法有两
个： a. 重写 create，手动给 employeeType 赋值 b.
自定义员工创建页面，拿到公司列表和部门列表两个字段。

551

no ne

Oinone7 天从入门到精通

图 5-21 注意事项

三、客户扩展

-O i

按 CDM
的设计理念，我们不以把模型抽象到极致支撑所有业务可能性为目标，而是抽象
80%通用的设计，保持模型简单可理解。我们只提供了基础模型统一数据存储，以用面向对
象特性来解决多应用模型复用和数据割裂问题。 Oinone-CDM
是商业领域的通用模型，更是结合 Oinone 特性提出的新工程建议。

克

5.4 基础支撑之商业关系域

PamirsPartner 作为商业关系与商业行为的主体，那么 PamirsPartner
间的关系如何描
述，本文将介绍两种常见的设计思路，从思维和实现两方面进行对比，给出
Oinone 为啥选 择关系设计模式的原因。

杰

一、两种设计模式对比 （一）设计模式思路介绍 1.

角色设计模式思路介绍

从产品角度枚举所有商业角色，每个商业角色对应一个派生的商业主体，并把主体间的
关系类型进行整理：

552

no ne

Oinone7 天从入门到精通

关系设计模式思路介绍

克

从产品角度枚举所有商业角色，每个商业角色对应一个派生的主体间商业关系：

杰

2.  

-O i

图 5-22 角色设计模式思路介绍

图 5-23 关系设计模式思路介绍 553

Oinone7 天从入门到精通 （二）设计模式对应实现介绍 1.

角色设计模式实现介绍

杰

克

-O i

no ne

1.不单商业主体需要扩展，关系也要额外维护，可以是字段或是关系表。一般 M2O
和 O2M 字段维护，M2M 关系表维护； 2.创建合同场景中甲方选择【商业主体
A】，乙方必须是【商业主体 A】有关联的经销
商、分销商、零售商、供应商等，则在角色设计模式下就非常麻烦，因为关系都是独立维护
的。

图 5-24 角色设计模式实现介绍 2.

关系设计模式实现介绍

① 只需维护商业关系扩展 ②
同时在设计上收敛了商业关系，统一管理应对不同场景都比较从容

554

no ne

Oinone7 天从入门到精通

图 5-25 关系设计模式实现介绍

二、Oinone 商业关系的默认实现

首先 Oinone 的商业关系选择关系设计模式
其次模型上采用多表继承模式，父模型上维护核心字段，子模型维护个性化字段。

三、客户扩展

克

-O i

按 CDM
的设计理念，我们不以把模型抽象到极致支撑所有业务可能性为目标，而是抽象
80%通用的设计，保持模型简单可理解。我们只提供了基础模型统一数据存储，以用面向对
象特性来解决多应用模型复用和数据割裂问题。 Oinone CDM
是商业领域的通用模型，更是结合 Oinone 特性提出的新工程建议。

5.5 基础支撑之结算域 一、基础介绍

杰

随着企业的业务不断进行数字化改造、业务越来越在线化，给企业财务工作带来几个明
显的变化和挑战： 1. 变化： ①
业务在线后，不同类收费、预售、授信模式的创新层出不穷，需要财务不仅只从事
单一传统的会计核算工作，还需要积极地参与到业务中去。 ②
从事后算账事后报账，变成财务业务一体化信息的实时处理。 2. 挑战： ①
业务系统与财务系统明显割裂，业务部门与财务部门各自采用一套软件处理其数据，
不能及时沟通信息和协同更正信息。 ②
财务系统往往都是单体的传统架构，凭证处理能力无法适应今天企业的不断爆棚的
业务发展。 ③
财务的严谨性与业务的灵活性中间有巨大的鸿沟，导致业务要做一种创新的模式，
财务可能是最大阻碍。
不论是传统软件公司喜欢说的业财一体化还是互联网平台公司喜欢说的结算平台，都是
为了解决以上变化和挑战的。业财一体化主要是从财务部门角度出发进行，在业务支撑上化
被动为主动。结算中心往往是结合财务部门和业务运营部门的需求。如果拿我们下面介绍的，
555

Oinone7 天从入门到精通
计费、账务、会计三个领域来说，业财一体化项目往往只包括账务和会计，结算中心往往包
括：计费、账务、会计。或者说业财一体化弱化了计费，没有纳入企业统一管理，把如何计
价给到了业务系统自行决定或者简单处理只要产生应收应付单据（计费详单）就好了。
结算域的是一个相对比较专业的领域，没有一定背景知识甚至连一些专业名词都很难理
解，更不用说模型设计了，这里我尽快地简单去描述定位而不是描述细节。而且
2.1.9 版本
的结算领域相对还是没有那么完善，这里介绍的是下个版本的内容，所以大家看当前版本的
时候会有一些对不上。

no ne

二、子领域职责

图 5-26 子领域职责 （一）计费 1.

计费的价值

杰

克

-O i

随着企业多业务发展以及融合计费需求，我们需要引入计费模型，对灵活计价模式进行
支持，快速支撑未来可能的计费方式等。 2. 计费的核心设计理念
所有的计算器都继承自虚函数计算器 y=f(x)

图 5-26 计费的核心设计理念

556

Oinone7 天从入门到精通

杰

克

三、模型介绍

-O i

no ne

更灵活多维区间组合，时间维度、计数器维度、其它属性维度计数器区间斜率限定，比
如交易额、空间、使用月份数… 3. 计费的核心功能 ① 通过产品定义运营方案 ②
通过订购产品完成商务合同的签订来决定客户计费策略，或者通过系统产品定义通
用计费策略 ③ 支撑各类产品的模拟计费 ④
以事件驱动，根据事件、产品、订购关系完成产品路由，并实时产生计费详单 ⑤
根据计费科目与账务科目，打通账务进行核销 （二）账务 1. 账务的价值
以账户账本为中心，提供记账、账户管理，以及账务的实时监控与持续对账。如果计费
是对接业务，那么账务的价值是对接财务系统 2. 账务的核心设计理念
不依赖计费，可独立对接，所有业务最终都需要反馈到帐户账本的操作上，并通过账本
明细记录所有操作 3. 账务的核心功能 ①
记账：充值、转账、提现，冻结、解冻，差错处理 ② 账务管理：开户、科目维护
③ 账务查询：对账 （三）会计（暂不在计划内） l 会计的价值
结算平台的会计模块不是严格意义上的会计系统，它主要是衔接其他的财务系统，做凭
证前置处理。在于汇总凭证，产出业务帐，对接到财务总帐系统，缓解财务系统压力。

图 5-27 模型介绍

四、结算基础流程

图 5-28 结算基础流程 557

Oinone7 天从入门到精通 五、客户扩展 按 CDM
的设计理念，我们不以把模型抽象到极致支撑所有业务可能性为目标，而是抽象
80%通用的设计，保持模型简单可理解。我们只提供了基础模型统一数据存储，以用面向对
象特性来解决多应用模型复用和数据割裂问题。 Oinone-CDM
是商业领域的通用模型，更是结合 Oinone 特性提出的新工程建议。

5.6 商业支撑之商品域 一、基础介绍

no ne

当业务在线化后，用于内部管理的产品主数据，叠加一堆销售属性变成了商品被推倒了
前台，成为导购链路中最最重要的信息载体。看似最基础和最简单的商品模块也有很多门道。
主要集中在以下几个方面： 1.
商品的属性如何管理、呈现、参与导购（类目、搜索的过滤条件）； 2.
如何解决固定不变的内部管理需求与基于销售特性长期变化的运营需求之间的矛盾；
3. 在多渠道情况渠道商品，如何映射到实际 sku 进行履约。

杰

克

-O i

二、模型介绍

图 5-29 模型介绍 558

Oinone7 天从入门到精通
1.类目属性，解决“商品的属性如何管理、呈现、参与导购（类目、搜索的过滤条件）”；
2.前后台类目设计，解决“如何解决固定不变的内部管理需求与基于销售特性长期变化
的运营需求之间的矛盾”； 3.销售 Sku 和库存 Sku
设计，解决“在多渠道情况渠道商品，如何映射到实际 sku 进行 履约”。
要把这些问题搞清楚，得先把名词统一下： 领域

名称

Oinone 的定义

说明

举例

SPU(Standard Product Unit)：标准化产品单元。 Product --&gt;Spu

Spu

2.1.9 --&gt; 3.0.0

SPU 是商品信息聚合的最 小单位，是一组可复用、 易检索的标准化信息的

iPhone X 可以确定一个 产品

no ne

集合，该集合描述了一个 产品的特性

商品分类分级管理，以及

平台运营视角

后台类目

后台类目(Category)

规范该类目下公共属性

可以分为普通属性、销售

前台类目

-O i

属性

前台类目(FrontCategory)

比如 类目：3c 数码/手机 销售属性：内存大小、颜 色等 普通属性：分辨率
通过前台类目关联后台

平台导购类目

类目或后台类目属性，用 于满足运营需求

大体上 SPU 处于最上层、Item 属于下一级，而 SKU 属于最低一层。

克

SPU 是平台层面，Item 是商家层面，SKU 是商家的 Item 确定销售属性

SPU
非必须，在平台类交易中，平台方为了规范商家发布商品信息，进行统一运营时需要

渠道商品(Item)

杰

Item

简单来说是：SPU 加上归 属商家、以及商家自有的

商家 A 的 iPhone X

价格与描述 SKU=Stock Keeping Unit （库存保有单位）。
是对每一个产品和服务

Sku

销售 Sku(SaleSku)

商家销售视角

的唯一标示符，该系统的 iPhone X 64G 银色 则是 使用 SKU 的值根于数据管

一个 SKU。

理，使公司能够跟踪系 统，如仓库和零售商店或 产品的库存情况。
在平台类电商，商家都会 有自己独立的店铺主页， 店铺类目

ShopCategory

商家店铺导购类目

商家类目跟前台类目作 用类似，只是局限影响范 围为商家店铺内

559

Oinone7 天从入门到精通 销售 SKU 中会有一个 InvSkuCode 来关联
InventorySku，比如：品牌上在不同渠道（淘宝、
京东、自建电商）中会有不同的销售 SKU，在从渠道同步销售 SKU 会根据外部
code 跟销售领域的 sku 的定义 产品或 库存 Sku

类似，但销售领域是为了 InventorySku

规范购买行为，这里规范

iPhone X 64G 银色

企业内部管理。

组合 Sku

InventorySkuComposition

产品分类

ProductKind

空调有内外机组合而成， 这就是一个组合 sku

指互相关联或相似的产

no ne

品，是按照一定的分类标 准对企业生产经营的全

商家管理视角

部产品进行划分的结果。

商品系列

ItemSeries

一个产品系列内往往包

括多个产品项目。产品系 列的划分标准有产品功

能、消费上的连带性、面

企业内部管理划分

-O i

向的顾客群、分销渠道、 价格范围等

为了反映存货的组成内

容，正确计算产品的生产

StorageKind

杰

克

存货类别

成本以及销售成本，会计 上必须对存货进行科学 地分类，按存货的不同类
别进行核算

表 5-1 各领域定义说明

三、客户扩展

按 CDM
的设计理念，我们不以把模型抽象到极致支撑所有业务可能性为目标，而是抽象
80%通用的设计，保持模型简单可理解。我们只提供了基础模型统一数据存储，以用面向对
象特性来解决多应用模型复用和数据割裂问题。 Oinone-CDM
是商业领域的通用模型，更是结合 Oinone 特性提出的新工程建议。

5.7 商业支撑之库存域
库存的差异会反馈到企业的整个价值链上，所以对库存的设计是至关重要的。

一、基础介绍
我们先抛开仓库中对库存的实操管理和整个流通领域的库存，只围绕企业自身一级的采
销链路上我们可以从管理和销售两个角度去看。
从管理角度上我们会关心：实物库存、在途库存、在产库存、库存批次等等，也就是企
业有多少库存分布在哪里在什么环节。 560

Oinone7 天从入门到精通
从销售角度上我们会关心：可售库存、安全库存等等，也就是企业在特定渠道销售中库
存分配规则。
在商业场景中库存管理一头对接仓库、生成、采购，另一头对接多个销售渠道。它的挑
战在于不同行业不同特征商品都有比较大的差异。比如家具行业卖的生成能力，家电区域化
销售，生鲜拼车销售，服饰一仓销全国。热销的要分配提升体验防止超卖，滞销的要活动拉
流量，普通的要渠道共享最大化可售。库存管理的差异会反馈到企业的整个价值链上，所以
对库存的设计是至关重要的。 库存设计挑战在于： 1.
技术上：库存类似账户账本的设计，需要能追溯库存变化的过程，且库存操作都能
可追溯业务单据。热点数据的并发控制； 2.
业务上：在管理角度上游能跟仓库、采购、生产等进行对接、对账、并为其设置可
售规则，下游能为各个销售渠道设置库存分配与同步规则。

杰

克

-O i

no ne

二、模型介绍

图 5-30 模型介绍 核心设计逻辑：

1.  单据链路：业务单据（外部业务单据+库存业务单据）产生库存指令（库存调整入\
    出库单），再由库存指令操作库存并记录库存流水。
2.  管理链路：基础数据维护仓库、供应商、服务范围与费用。这些数据是订单履约路
    由和可售库存同步的基础。
3.  库存数据：对外跟商品域，通过库存指令进行操作。不同库存各自维护自身库存与
    流水记录，确保可追溯。
4.  如果跟销售渠道对接，还需要扩展可售库存逻辑规则以及同步规则。比如 oms
    类似 的应用。

三、客户扩展

561

Oinone7 天从入门到精通 按 CDM
的设计理念，我们不以把模型抽象到极致支撑所有业务可能性为目标，而是抽象
80%通用的设计，保持模型简单可理解。我们只提供了基础模型统一数据存储，以用面向对
象特性来解决多应用模型复用和数据割裂问题。 Oinone-CDM
是商业领域的通用模型，更是结合 Oinone 特性提出的新工程建议。

5.8 商业支撑之执行域 一、基础介绍

杰

克

-O i

no ne

执行域包括两个核心一是订单的产生，二是订单的履约。往往品牌商既有自营渠道（包
括 2c、2b）、又有第三方渠道。那么有两种设计思路： 1.
把第三方渠道的订单当作自有渠道的订单产生一种特殊方式，开放订单创建接口，
并统一履约： ① 好处：简单，在 3
方渠道不多、且自有渠道单一，并且逻辑相识时系统结构会简单 ② 坏处： 1) 当
3 方渠道的履约方式、库存分配方式、逆向逻辑等有差异时，会让自有渠道
参杂很多不相干的逻辑引入不必要的复杂度； 2)
自有渠道不够独立和纯粹，自有渠道多样化时难以支撑。 2.
把商家自营渠道假设为特殊的第三方渠道，再建立统一的订单管理系统来对接渠道
订单，并完成履约： ① 好处：交易与履约逻辑分离，对未来发展有扩展性 ②
坏处：引入一定复杂度 我们采用的是第二套方案，整体结构简易图如下（如图
5-31 所示）

图 5-31 方案整体结构简易图

二、模型介绍

562

杰

克

-O i

no ne

Oinone7 天从入门到精通

图 5-32 模型介绍

核心设计逻辑：

1.  首先我们看到上图交易域和履约域有很多相同父模型的子模型，交易域和履约域的
    父模型在 CDM 的在 himalaya-trade 里。履约域看 oms（libra）对
    himalaya-trade 扩展，交易域看 b2c（leo）和 b2b（aries）对对
    himalaya-trade 扩展。libra、 leo、aries
    是我们对上层业务产品的命名，取自黄道十二星座；
2.  交易域是多商家平台视角设计，有自身渠道必要的履约相关信息，完成自闭环；
3.  履约域是从单一商家对接多渠道视角设计，有渠道交易订单同步后完成履约发货相
    关设计，完成自闭环；
4.  履约域的合单拆单发货设计，渠道订单只能合单为履约单不可拆，履约单可以拆单
    发货不可合。用 m2o 和 o2m 的组合设计来降低难度，而非采用两个 m2m
    的设计。

563

Oinone7 天从入门到精通 第六章 Oinone 的通用能力

-O i

6.1 文件与导入导出

no ne

通用能力是指一些跟具体业务场景无关， 但是业务支撑中必不可少的功能。
比如: 权限、文件导入导出、工作流、 异构系统集成、国际化等等。Oinone
的通用能力本质上 也是一个个独立的应用 (application=true 的模块)或模块，
可以独立部署也可以跟业 务模块部署在一起 。
通用能力模块如何与业务模块相互影响? 1. 利用 Oinone 函数的 hook
特性影响到业务模块， 所以大家在正常开发业务代码的 时候并不需要关心； 2.
利用 Oinone 函数的扩展点特性， 为业务层扩展提供支持 。 本章节重点介绍
Oinone 提供的一些企业级通用能力： 1. 文件导入导出 2. 国际化 3. 集成 4.
工作流 5. 权限

杰

克

导入导出在一定程度上是企业级软件和效率工具（office 工具）的桥梁
文件的上传下载以及业务数据的导入导出是企业级软件一个比较常规的需求，甚至是巨
量的需求。业务有管理需要一般都伴随有导入导出需求，导入导出在一定程度上是企业级软
件和效率工具（office 工具）的桥梁。Oinone
的文件模块就提供了通用的导入导出实现方
案，以简单、一致、可扩展为目标，简单是快速入门，一致是用户操作感知一致、可扩展是
满足用户最大化的自定义需求。 下图为文件导入导出的实现示意图（如下图 6-1
所示），大家可以做一个整体了解:

图 6-1 文件导入导出实现示意图

一、基础能力 （一）准备工作

1.  pamirs-demo-api 的 pom 文件中引入 pamirs-file2-api 包依赖

564

Oinone7 天从入门到精通

图 6-2 pamirs-demo-api 的 pom 文件中引入 pamirs-file2-api 包依赖 2.
DemoModule 增加对 FileModule 的依赖

图 6-3 DemoModule 增加对 FileModule 的依赖

no ne

3.  pamirs-demo-boot 的 pom 文件中引入 pamirs-file2-core 包依赖

图 6-4 pamirs-demo-boot 的 pom 文件中引入 pamirs-file2-core 包依赖

-O i

4.  pamirs-demo-boot 的 application-dev.yml 文件中增加配置
    pamirs.boot.modules 增 加 file，即在启动模块中增加 file 模块

克

图 6-5 pamirs-demo-boot 的 application-dev.yml 文件中增加配置

杰

5.  pamirs-demo-boot 的 application-dev.yml 文件中增加 oss
    的配置。更多有关文件相 关配置参见【模块之 yml 文件结构详解】一文

图 6-6 pamirs-demo-boot 的 application-dev.yml 文件中增加 oss 的配置
（二）文件上传
文件上传下载是常用功能，也是导入导出功能的基础。接下的例子，我们来看看
Oinone 是如何玩转文件上传的功能的。 ① Step1 修改 PetTalent 模型

565

Oinone7 天从入门到精通 为 PetTalent 模型增加一个字段
imgUrls，用于保存上传后的文件地址。同时定义 Form
视图的时候改字段的前端展示 widget 为“Upload”：

图 6-7 PetTalent 模型 ②

Step2 修改 PetTalent 的 Form 视图

no ne

因为前面教程中为 PetTalent 的 Form
视图写了自定义视图，所以这里需要手工加上字
段配置，不然展示不出来，同时也要加上
widget="Upload"的配置，因为自定义视图不会再 去读字段上定义的
UxWidget，字段上的 UxWidget 只对默认视图生效。

图 6-8 修改 PetTalent 的 Form 视图 Step3 重启看效果

-O i

③

克

图 6-9 重启看效果

（三）默认导入导出功能

杰

因为前面我们在 Demo 的启动工程中加入对 pamirs-file2-core 的 jar
包依赖同时启动 模块列表中也增加了 file
模块，所以所有的默认表格页面都出现了默认的导入导出按钮。

图 6-10 所有的默认表格页面均出现默认的导入导出按钮
但是我们发现宠物达人的表格就没有出现导入导出按钮，首先我们自定义了表格视图，
而且在学习自定义 Action 的时候修改了表格视图的 Action
的填充方式为手工指定。

566

Oinone7 天从入门到精通

图 6-11 宠物达人的表格没有导入导出按钮 ①

Step1 修改 PetTalent 的 Table 视图

no ne

修改 PetTalent 的自定义 Table 视图， 把表格视图的 Action
的填充方式改为自动填充，
或者根据【平台默认前端动作】增加导入、导出两个前端动作

克

-O i

图 6-12 修改 PetTalent 的自定义 Table 视图

图 6-13 增加导入、导出两个前端动作

Step2 重启看效果

杰

②

图 6-14 重启看效果 ③

Step3 注意点

a.  系统生成的导入模版以默认的 Form 视图为准
b.  系统生成的导出模版以默认的 Table 视图为准
c.  有自定义导入导出模版后，默认模版会失效

二、自定义导入导出模版与逻辑 （一）数据的导出（举例一）

1.  通常我们只需定义一个导出模版 567

Oinone7 天从入门到精通

-O i

no ne

2.  默认导出方法是调用模型的 queryPage
    函数（即在日常开发中我们经常会自定义模 型的 queryPage
    函数），为了跟页面查询效果保持一致，默认导出方式实现中手工 生效了
    hook，所以类似数据权限的 hook 都会生效，与页面查询逻辑一致。
3.  如果不一致可以实现 ExcelExportFetchDataExtPoint
    扩展点来完成，在举例二中 介绍 ① Step1 新建 PetTalentExportTemplate
    新建 PetTalentExportTemplate 类实现 ExcelTemplateInit 接口。

<!-- -->

1)  实现 ExcelTemplateInit 接口，系统会自动调用 generator
    方法，并注册该方法返
    回的模版定义列表，例子中定义了一个导出模版“宠物达人导出”
2)  关联对象为集合，petShops\[\*\].shopName
3)  关联对象为模型，creater.name

Step2 重启看效果

1)  点击宠物达人菜单进入宠物达人列表页，选择记录点击导出按钮。导出规则为

<!-- -->

a.  如果勾选列表记录行，则只导出勾选记录
b.  如果没有勾选，则根据查询条件进行导出

杰

②

克

图 6-15 新建 PetTalentExportTemplate

图 6-16 宠物达人列表页选择导出 2)
在导出弹出框中选择导出模版，点击导出按钮提示成功，则表示导出任务被正常创
建

568

Oinone7 天从入门到精通

图 6-17 选择导出模版

no ne

3)  切换换模块，进入文件应用，点击导出任务菜单查看导出任务情况。分别对应三种
    情况：

<!-- -->

a.  Table 视图中带来条件但查询结果没有数据，则会报错
b.  Table 视图中带来条件或无条件但查询结果有数据，则会成功
c.  Table 视图中勾选了数据行，则只导出勾选数据行对应数据

图 6-18 查看导出任务情况

-O i

（二）数据的导出（举例二）

杰

克

如果您有特殊需求，请实现 ExcelExportFetchDataExtPoint
扩展点来完成，用这种模
式请自行控制数据权限，小心小心再小心。因为数据权限是通过 hook
机制来完成控制，在
【面向切面-拦截器】一文中有说明拦截器只有在前端请求时才会默认生效，如果后端代码
自行调用需要生效 hook 机制需要根据【函数之元位指令】一文手动去生效。
下面例子中为了复用了 ExcelExportSameQueryPageTemplate 的逻辑主要是 hook
的机制， ExcelExportSameQueryPageTemplate 手工生效了 hook，例子中继承了
ExcelExportSameQueryPageTemplate 类，只做返回结果的后置处理。 ① Step1
修改 PetTalentExportTemplate

569

no ne

Oinone7 天从入门到精通

②

Step2 重启看效果

-O i

图 6-19 修改 PetTalentExportTemplate

杰

克

相同的操作，发现导出文件内容被特定修改过

图 6-20 导出文件内容被特定修改过 （三）数据的导入（举例一） ①

Step1 创建 PetTalentImportTemplate

新建 PetTalentImportTemplate 类实现 ExcelImportDataExtPoint 和
ExcelTemplateInit 接口。 1) 实现 ExcelTemplateInit 接口，系统会自动调用
generator 方法，并注册该方法返
回的模版定义列表，例子中定义了一个导入模版“宠物达人导入” a. 通过
ExcelCellDefinition 自定义单元可选值，并在 addColumn 时绑定
如：.addColumn("petTalentSex",sexExcelCellDefinition) b. 通过
addUnique，设置导入时的唯一 key，相同 key 同时相连行会进行合并操 作 570

Oinone7 天从入门到精通

杰

克

-O i

no ne

2)  实现 ExcelImportDataExtPoint 的 importData
    扩展点，实现自定义的导入逻辑

<!-- -->

a.  声明扩展点的生效规则：@ExtPoint.Implement(expression =
    "importContext.definitionContext.Model == "" +
    PetTalent.Model\_Model+"" && importContext.definitionContext.name ==
    "" +TEMPLATE\_NAME+""" ) 。可以用表达式的上下文就是方法入参
b.  记录错误：importTask.addTaskMessage(TaskMessageLevelEnum.ERROR,"达人
    名称不能为空")。
c.  importData 方法返回 true，代表继续下一行的导入。返回 false
    则表示中断 导入

571

-O i

no ne

Oinone7 天从入门到精通

Step2 重启看效果

1)  点击宠物达人菜单进入宠物达人列表页面，点击导入。
2)  在导入弹出框中选择导入模版后点击下载模版，并提按模版填写数据。
3)  在导入弹出框中选择点击上传按钮，上传填写好的文件，并点击导入按钮

杰

②

克

图 6-21 创建 PetTalentImportTemplate

图 6-22 导入数据

572

Oinone7 天从入门到精通

图 6-23 按照模版填写数据

克

-O i

no ne

4)  列表页增加对应数据行，点击详情可以看到所有相关数据

图 6-24 点击详情可看到所有相关数据

杰

这个例子中用了 ExcelHelper
这个简单工具类来定义模版，基本能满足日常需求。复杂 的可以直接用
WorkbookDefinitionBuilder 来完成。 （四）导入导出的更多配置项 ①

基础设计

以 POI 和 EasyExcel 共有的 Excel 处理能力为基础进行设计。 1) 以 Workbook
为核心的模板定义 2) 支持多个 Sheet 定义。 3)
支持【固定表头】形式的模板定义。（陆续支持【固定格式】和【混合格式】）
4) 支持三个维度的定义方式：表头定义（列定义），行定义，单元格定义。 5)
支持单元格样式、字体样式等 Excel 样式定义。 6) 支持合并单元格。 7)
支持数字、字符串、时间、日期、公式等 Excel 的数据处理能力。 8)
支持直接存数据库和获取导入数据两种方式。 ② Excel 功能
模板定义，使用数据初始化或页面操作的方式创建 Excel 模板。

573

Oinone7 天从入门到精通
导出任务的创建，页面选择导出模板、导出条件后，点击确定后，创建导出任务。导出
方式为：异步，在导出任务页面查看导出任务，并允许多次下载。
导入任务的创建，页面选择模板，并点击下载后，获取对应 Excel
模板。按照指定规则 （平台默认规则或业务自定义规则）填写完成后，上传
Excel 文件进行异步导入操作。 1) Excel 工作簿（ExcelWorkbookDefinition）
属性

类型

名称

必填

name

String

名称

是

默认值

说明

Excel 工作簿的定 义名称 导出时使用的文件

filename

String

文件名

否

名， 不指定则默认使 用名称作为文件名

sheetList

Enum

Office 版本

否

List<ExcelSheetDefinition> 工作表定义 （JSONArray）

AUTO

no ne

version

是

列表

OfficeVersionEnum 对多个 Sheet 进行 定义

表 6-1 Excel 工作簿（ExcelWorkbookDefinition）

属性

String

名称

必填

默认值

blockDefini List<ExcelBlockDefinition
tionList

>

未指定工作表名称 时，默认使用模型的

工作表名称

否

tion&gt;

uniqueDefin List<ExcelUniqueDefinitio
itions

n>

显示名称，未绑定模 型生成时，默认使用 「Sheet + \${index}」
作为工作表名称

区块列表

mergeRangeL List<ExcelCellRangeDefini 单元格合并范
ist

说明

指定工作表名称，当

杰

name

类型

-O
i

Excel 工作表（ExcelSheetDefinition）

克

2)

围

是

至少一个区块
工作表的合并范围相

否

对于 A1 单元格行列
索引，绝对定义
全局模型唯一定义，

唯一定义

否

当区块中未定义时，
使用该定义

表 6-2 Excel 工作表（ExcelSheetDefinition）
3)

Excel 区块（ExcelBlockDefinition）

574

Oinone7 天从入门到精通
属性

类型

名称

必填

默认值

说明

设计区域是区块的唯
designRegio
n

ExcelCellRangeDefinition

设计区域

一标识，不允许重叠。

是

定义时应示意扩展方
向，如下图所示。

analysisTyp
e

Enum

解析类型

是

FIXED_HEADE ExcelAnalysisTypeE
R

num
将样式覆盖变为样式
层叠；单个工作表有

headerList

rowList
bindingMode

否

样式

List<ExcelHeaderDefinitio
n>

false

表头定义

否

List<ExcelRowDefinition>

行定义

否

String

绑定模型

是

杰 tion&gt;

共同定义一个 Sheet 的样式 【固定表头】类型下， 至少一行，不显示的
表头行使用配置行定 义。 【固定格式】类型下， 至少一行。
绑定任意模型，允许 使用类的全限定名。 区块内的单元格合并
范围相对与区块起始 行列索引。当合并范

mergeRangeL List<ExcelCellRangeDefini 单元格合并范
ist

列样式 < 行样式 <
单元格样式三个属性

克

l

Boolean

no
ne

ingStyle

效；优先级顺序为：

是否使用层叠

-O
i

usingCascad

围

围指定到最后一行的
否

表头定义时，属于相
对定义，即扩展时会
自动填充合并样式。
否则与工作表合并相
同。

uniqueDefin List<ExcelUniqueDefinitio
itions

n>

唯一定义

默认使用模型定义的

否

unique 属性

表 6-3 Excel 区块（ExcelBlockDefinition） 4)

Excel 行（ExcelRowDefinition） 属性

cellList

类型

名称

List<ExcelCellDefinition> 单元格列表

必填

默认值

说明

否

575

Oinone7 天从入门到精通 style

ExcelStyleDefinition

样式

否

行样式

表 6-4 Excel 行（ExcelRowDefinition） 5)

Excel 表头（ExcelHeaderDefinition 继承 ExcelRowDefinition） 属性

类型

cellList

名称

必填

List<ExcelCellDefinition> 单元格列表

样式

否

direction

Enum

排列方向

否

mn isFrozen

应用范围

否

Boolean

是否配置表头

否

Boolean

自动列宽

否

Boolean

-O i

autoSizeColu

行样式

HORIZONTAL ExcelDirectionEnum

no ne

ExcelStyleDefinition

isConfig

是否冻结

说明

否

style

selectRange ExcelCellRangeDefinition

默认值

true

否

仅起始属性有效

多行表头需使用配置 表头进行定义 Excel 冻结功能

6)  

克

表 6-5 Excel 表头（ExcelHeaderDefinition 继承 ExcelRowDefinition） Excel
单元格范围（ExcelCellRangeDefinition） 类型

杰

属性

名称

必填

beginRowIndex

Integer

起始行索引

否

endRowIndex

Integer

结束行索引

否

beginColumnIndex

Integer

起始列索引

否

endColumnIndex

Integer

结束列索引

否

fixedBeginRowIndex

Boolean

固定起始行索引

否

fixedEndRowIndex

Boolean

固定结束行索引

否

fixedBeginColumnIndex

Boolean

固定起始列索引

否

默认值

说明

576

Oinone7 天从入门到精通 fixedEndColumnIndex

Boolean

固定结束列索引

否

表 6-6 Excel 单元格范围（ExcelCellRangeDefinition） 7)

Excel 单元格（ExcelCellDefinition） 属性

类型

名称

必填

默认值

说明

当且仅当单元格在表 头中有效；多行表头 field

String

属性

需使用配置表头进行

否

定义；多个配置表头 定义属性时，仅首个

value

String

type

Enum

no ne

属性定义生效； 值

否

值类型

否

Boolean

克

isStatic

-O i

formatContextString String（JSONObject） 格式化上下文

style

ExcelStyleDefinition

是否是静态值

样式

STRING

否

ExcelValueTypeEnum 针对不同类型的值设 置不同的参数内容 （类型待定）
静态值在数据解析时

否

false

将使用配置值，不读 取单元格的值

否

单元格样式

8)  

杰

表 6-7 Excel 单元格（ExcelCellDefinition）

Excel 单元格样式（ExcelStyleDefinition） 属性

类型

名称

必填

默认值

Enum

水平对齐

否

GENERAL

说明

ExcelHorizontalAlignm horizontalAlignment

entEnum ExcelVerticalAlignmen verticalAlignment

Enum

垂直对齐

否 tEnum

fillBorderStyle

Enum

全边框样式

否

NONE

ExcelBorderStyleEnum

topBorderStyle

Enum

上边框样式

否

ExcelBorderStyleEnum

rightBorderStyle

Enum

右边框样式

否

ExcelBorderStyleEnum

577

Oinone7 天从入门到精通 bottomBorderStyle

Enum

下边框样式

否

ExcelBorderStyleEnum

leftBorderStyle

Enum

左边框样式

否

ExcelBorderStyleEnum

wrapText

Boolean

是否自动换行

否

字体

否

true

ExcelTypefaceDefini typefaceDefinition tion

width

Integer

宽

否

首列样式中有效

height

Integer

高

否

首列样式中有效

Excel 字体（ExcelTypefaceDefinition） 属性

类型

typeface

Enum

名称

必填

字体

否

默认值

说明

ExcelTypefaceEnum

-O i

9)  

no ne

表 6-8 Excel 单元格样式（ExcelStyleDefinition）

表 6-9 Excel 字体（ExcelTypefaceDefinition） （五）注意事项

杰

克

如果是在分布式模式下，启动工程中没有加入 File 模块，则需要手工调用
ExcelTemplateInitHelper.init 方法。

6.2 集成平台

企业在数字化转型过程中内外部集成是一个必然需求、也是趋势。
集成的诉求主要来自两个方面：1.企业的数字化改造是由外而内逐步进行的（内部异构
集成）、2.企业数字化方向是朝越来越开放的方向发展（外部平台、工具集成）。总的来说
企业在数字化转型过程中内外部集成是一个必然需求、也是趋势。所以我们不能简单地去理
解做个 API 对接就结束了，而是要统一规划构建成企业的集成门户对 API
定义，安全、控制、 记录等做全方位管理。Oinone
在下个版本规则中也纳入了基于集成平台之上做产品化配置 的需求。

一、概述 pamirs-eip
为平台提供企业集成门户的相关功能，如请求外部接口使用的【集成接口】
和对外开放被其他系统请求调用的【开放接口】功能。在请求外部接口时，还支持了多个接
口调用（路由定义）、分页控制（paging）、增量控制（incremental）等功能。

二、准备工作 （一）Step1 POM 与模块依赖

pamirs-demo-api 和 pamirs-second-api 的 pom 文件中引入 pamirs-eip2-api
包依赖： 578

Oinone7 天从入门到精通

图 6-25pamirs-demo-api 和 pamirs-second-api 的 pom 文件中引入
pamirs-eip2-api 包依赖 DemoModule 和 SecondModule 增加对 EipModule
的依赖：

图 6-26 DemoModule 和 SecondModule 增加对 EipModule 的依赖

no ne

pamirs-demo-boot 和 pamirs-second-boot 工程的 pom 文件中引入
pamirs-eip2-core 包依赖：

图 6-27 引入 pamirs-eip2-core 包依赖 （二）Step2 yaml 配置文件参考

克

-O i

pamirs-demo-boot 和 pamirs-second-boot 工程的 application-dev.yml
文件中增加配 置 pamirs.boot.modules 增加 eip，即在启动模块中增加 eip
模块：

图 6-28 在启动模块中增加 eip 模块

杰

pamirs-demo-boot 和 pamirs-second-boot 工程的 application-dev.yml
文件中增加 eip 模块的数据源与路由配置：

579

no ne

Oinone7 天从入门到精通

图 6-29 增加 eip 模块的数据源与路由配置

-O i

pamirs-demo-boot 工程的 application-dev.yml 文件中修改 eip 的配置：

克

图 6-30 pamirs-demo-boot 工程的 application-dev.yml 文件中修改 eip
的配置

杰

pamirs-second-boot 工程的 application-dev.yml 文件中修改 eip 的配置：

图 6-31 amirs-second-boot 工程的 application-dev.yml 文件中修改 eip
的配置 注： 580

Oinone7 天从入门到精通 hosts 配置在远程调用时不能使用
127.0.0.1，可配置为 0.0.0.0 进行自动识别。若自
动识别仍无法访问，请准确配置其他已知的可访问 IP 地址。
aes-key：用下面代码生成 l

附录：AES Key 生成

pro.shushi.pamirs.core.common.EncryptHelper 加解密帮助类，默认支持
AES、RSA 类型的数据加解密方法，也可自定义其他类型的加解密方法。

图 6-32 AES Key 生成 （三）Step3 在 pamirs-second-api 新建一个
SessionTenantApi 实现类

克

-O i

no ne

只要在我们公共的 jar 包中构建类似 DemoSessionTenant
类就可以了，之所以要构建 SessionTenantApi 实现类是因为 EIP
是以租户信息做路由的。所以这里我们写死返回一个 “pamirs”租户就好了。
记得要重新 mvn install second 工程，再刷新 demo 工程

杰

图 6-33 新建一个 SessionTenantApi 实现类

三、开放接口（举例）

（一）Step1 用于演示的模型定义

图 6-34 用于演示的模型定义

581

Oinone7 天从入门到精通

图 6-35 用于演示的返回结果对象 （二）Step2 用于演示的接口定义

克

-O i

no ne

① estOpenApiModelService 接口定义了内部访问函数 queryById ②
TestOpenApiModelServiceImpl 实现 TestOpenApiModelService
接口，并定义了两个开 放接口： a. queryById4Open 函数用@Open
进行注解，请求路径是：openapi/pamirs/方法
名?tenant=pamirs，返回对象结构为函数返回值类型的 JSON 格式； b.
queryById4OpenError 函数用@Open(config = TestEipConfig.class,path =
"error")进行注解，请求路径为：openapi/pamirs/error?tenant=pamirs，返回对象结
构为函数返回值类型的 JSON 格式； c. config = TestEipConfig.class
设置通用配置类，可以在 TestEipConfig 增加
@Open.Advanced。优先级低于方法上的注解。TestEipConfig
见【集成接口举例的集成
配置模型定义】。配置模型在开放接口定义中非必须的，在集成接口定义中时是必须；
d. 更多注解配置见【Eip 注解说明】

杰

图 6-36 定义内部访问函数 queryByI

582

no ne

Oinone7 天从入门到精通

？？？图 6-37 实现 TestOpenApiModelService 接口

克

请求方法：POST 请求参数格式：

-O i

（三）Step3 用于演示的请求协议

图 6-38 请求参数格式

杰

成功响应格式：

图 6-39 成功响应格式 异常响应格式：

583

Oinone7 天从入门到精通 图 6-40 异常响应格式 （四）Step4 初始化 EIP

杰

克

-O i

no ne

构建 SecondModuleBizInit584实现 InstallDataInit, UpgradeDataInit,
ReloadDataInit 接口，调用 Eip 注解模式的初始化方法：
EipResolver.resolver(SecondModule.MODULE\_MODULE,null)

图 6-41 初始化 EIP （五）Step5 重启看效果

Second 模块重新 mvn install 重启 pamris-second-boot 工程 请求地址一：
http://localhost:8094/openapi/pamirs/queryById4Open?tenant=pamirs

584

Oinone7 天从入门到精通

图 6-42 地址一重启 pamris-second-boot 工程 返回结果：

图 6-43 返回结果

no ne

请求地址二：http://localhost:8094/openapi/pamirs/error?tenant=pamirs

-O i

图 6-44 地址二重启 pamris-second-boot 工程 返回结果：

克

图 6-45 返回结果

四、集成接口（举例）

杰

下面的例子我们将用集成接口调用开放接口，集成接口配置在 Demo 模块
（一）Step1 用于演示的集成配置模型定义

1.配置模型必须继承 IEipAnnotationSingletonConfig 接口 2.自定义 construct
函数，达到修改配置时可以自动刷新对应的集成接口和开放接口 3.host
为服务端：域名+端口，如 www.oinone.top:80 4.shcema 为请求协议：http 或
https 5.类上可以增加@Open.Advanced 和@Integrate.Advanced
配置达到通用配置的作用， 优先级低于方法上的注解

585

no ne

Oinone7 天从入门到精通

杰

克

-O i

图 6-46 用于演示的集成配置模型定义 （二）Step2 用于演示的接口定义 1.
TestIntegrateService 接口定义了内部访问函数 callQueryById、
callQueryByData、 callQueryByIdError； 2. TestIntegrateServiceImpl 实现
TestIntegrateService 接口，并把方法定义为集成 接口： ① config =
TestEipConfig.class 设置通用配置类，可以在 TestEipConfig 增
加@Integrate.Advanced。优先级低于方法上的注解。它在集成接口定义中时是必
须。 ② @Integrate.Advanced(path=""),集成接口最终请求地址：
TestEipConfig.schema+"://"+TestEipConfig.host+path ③
方法体返回空就可以，实际执行时候该方法被拦截并不会执行 ④
@Integrate.ConvertParam 1）请求从方法入参数会以参数名为 key
放在上下文中，
@Integrate.ConvertParam(inParam="data.id",outParam="id")代表把参数 名为
data 的 id 属性值，放到上下文 key 为 id 上。 2）url 和 head
的参数转化参见【paramConverter 的特殊转换】 ⑤ finalResultKey
是指最终的请求参数 key，会从上下文中找对应的 key 值作为 请求参数 ⑥
更多注解配置见【Eip 注解说明】

586

Oinone7 天从入门到精通

克

-O i

no ne

图 6-47 TestIntegrateService 接口定义内部访问函数

杰

图 6-48 TestIntegrateServiceImpl 实现 TestIntegrateService 接口
（三）Step3 新建 TestEipAction

587

克

-O i

no ne

Oinone7 天从入门到精通

杰

图 6-49 新建 TestEipAction

（四）Step4 构建测试入口

图 6-50 构建测试入口 （五）Step5 初始化 Eip

在 DemoModuleBizInit 类中增加私有方法 initEip，并在
init、reload、upgrade 中调 用该私有化：

图 6-51 初始化 Eip （六）Step6 重启看效果 588

Oinone7 天从入门到精通 1.
点击集成测试菜单，点击新增按钮，配置集成接口信息

图 6-52 配置集成接口信息

no ne

2.  点击集成测试菜单，依次点击三个方法

图 6-53 点击集成测试菜单

克

-O i

3.  模块切换进入集成接口，点击日志菜单。比对请求不同点 ① 设置
    finalResultKey 的表达从接口上下文中取最终对应的 value 作为请求参数，
    不然会传全部接口上下文过去 ②
    callQueryByIdError，集成接口和对应的开放接口对结果认知差别

<!-- -->

a.  开放接口返回异常信息
b.  集成接口没有对返回信息作判定，直接当成功。集成接口如何判定对方返还的
    是错误，请见【自定义异常判定】

五、自定义异常判定（举例） （一）Step1 新建异常判定函数

杰

新建异常判定处理类 TestExceptionPredictFunction，实现
IEipExceptionPredict 接 口。从
context.getInterfaceContextValue(DEFAULT\_ERROR\_CODE\_KEY)中获取成功与否的
值，并进行判断：

589

Oinone7 天从入门到精通

克

-O i

no ne

图 6-54 新建异常判定函数 （二）Step2 修改 TestIntegrateServiceImpl 类
修改 TestIntegrateServiceImpl 的 callQueryByIdError 函数的注解，增加
@Integrate.ExceptionProcessor 注解： 1. errorCode ="success",
从返回结果中拿键值为“success”的值，作为接口上下 文对应键值为
IEipContext.DEFAULT\_ERROR\_CODE\_KEY 的值 2. exceptionPredictFun
指定函数名 3. exceptionPredictNamespace 指定函数命名空间

杰

图 6-55 修改 TestIntegrateServiceImpl 类

（三）Step3 重启看效果

1.点击集成测试菜单，点击调用集成接口 callQueryByIdError
2.模块切换进入集成接口，点击日志菜单。集成接口是否成功调用判定为 false

图 6-56 重启看效果

六、自定义安全策略（AccessToken） 开发接口提供默认三种实现方式，例子采用
DEFAULT\_NO\_ENCRYPT\_AUTHENTICATION\_PROCESSOR\_FUN

590

Oinone7 天从入门到精通 1.DEFAULT\_AUTHENTICATION\_PROCESSOR\_FUN：根据
EipApplication 配置的加密类型进 行加解密处理的认证

2.DEFAULT\_NO\_ENCRYPT\_AUTHENTICATION\_PROCESSOR\_FUN：不进行加解密处理的认证。
3.DEFAULT\_MD5\_SIGNATURE\_AUTHENTICATION\_PROCESSOR\_FUN：使用 MD5
简单验签的认

杰

克

-O i

no ne

证。 （一）Step1 给开放接口加上认证处理配置

591

Oinone7 天从入门到精通

杰

克

-O i

no ne

图 6-57 给开放接口加上认证处理配置 （二）Step2 修改
TestEipAction，增加返回结果判断

图 6-58 修改 TestEipAction （三）Step3 重启看效果

期待效果，因为开放接口增加了安全相关校验，集成接口这边并没有调整，所以都会抛
错：

592

Oinone7 天从入门到精通

杰

克

-O i

no ne

图 6-59 重启看效果 （四）Step4 为集成接口定义 auth 处理类 ① Step4\_1
修改 TestEipConfig 增加了 appkey 和 appSecret
两个字段，用于存储开放接口的 appkey 和 appSecret。大
家注意我们是用集成接口去访问开放接口，大家可以要想象成两个应用。
站在开放接口角度，但凡需要访问开放接口，就需要先申请 appkey 和
appSecret，并 通过 appkey 和 appSecret 来换取 accessToken，再用
accessToken 来请求。
站在集成接口角度，我们需要访问对方的接口，必须遵循对方接口安全规范。

图 6-60 修改 TestEipConfig ② Step4\_2 修改 TestIntegrateService 和
TestIntegrateServiceImpl 1) 定义和实现 fetchOinoneAccessToken 2)
修改集成注解增加 auth 处理器

图 6-61 定义和实现 fetchOinoneAccessToken

593

杰

克

-O i

no ne

Oinone7 天从入门到精通

图 6-62 修改集成注解增加 auth 处理器 594

Oinone7 天从入门到精通 ③ Step4\_3 新建 TestAuthFunction

杰

克

-O i

no ne

1)  获取 TestEipConfig 的配置信息
2)  先从缓存中拿 accessToken

<!-- -->

a.  拿到直接放到请求头中
b.  拿不到调用对方接口获取 accessToken（这里对方接口也就是我们自己的开放
    平台的接口）获取 accessToken

图 6-63 新建 TestAuthFunction ④ Step4\_4 修改 TestEipAction 借用
TestEipConfig 模型的列表页提供一个新增 EipApplication 的入口：

595

no ne

Oinone7 天从入门到精通

图 6-64 修改 TestEipAction （五）Step5 重启看效果

杰

克

-O i

① 点击集成测试菜单，点击创建一个集成应用按钮，数据库查看创建出来的
EipApplication 记录和 EipAuthentication 记录

图 6-65 点击创建一个集成应用按钮

图 6-66 数据库查看创建出来的 EipApplication 记录和 EipAuthentication
记录 ② 点击集成测试菜单，编辑记录，填写 appkey 和 appSecret

596

Oinone7 天从入门到精通

no ne

图 6-67 编辑记录

图 6-68 填写 appkey 和 appSecret

杰

克

-O i

③ 点击集成测试菜单，依次点击恢复原有的效果，只有调用集成接口
callQueryByIdError
报错其他不再报错了，也可以进入集成接口模块的日志菜单查看请求日志

图 6-69 点击集成测试菜单

七、自定义安全策略（AccessToken+加密） 例子采用
DEFAULT\_AUTHENTICATION\_PROCESSOR\_FUN 安全策略，根据 EipApplication
配置的加密类型进行加解密处理的认证。安全模式：accessToken+加密
当开放接口采用 DEFAULT\_AUTHENTICATION\_PROCESSOR\_FUN
的策略，需要外部调用方请
求参数为{result:"加密后的请求体内容"}的结构，result
的值为加密后的请求体内容。 （一）Step1 更改开放接口认证方式 认证方式换成
DEFAULT\_AUTHENTICATION\_PROCESSOR\_FUN，
@Open.Advanced(authenticationProcessorFun=
EipFunctionConstant.DEFAULT\_AUTHENTICATION\_PROCESSOR\_FUN)
小伙伴们可以把@Open.Advanced(authenticationProcessorFun)的配置挪到
TestEipConfig 中去，这样就不用为每个接口配置了，自己动手吧。

597

克

-O i

no ne

Oinone7 天从入门到精通

杰

图 6-70 更改开放接口认证方式

（二）Step2 重启看效果

期待效果，因为开放接口修改了安全相关校验，集成接口这边并没有调整，所以都会抛
错：

图 6-71 集成接口未调整所以都会抛错 （三）Step3 为集成接口定义新的 auth
处理类 ①

Step3\_1 修改 TestEipConfig

598

Oinone7 天从入门到精通 增加两个字段 encryptType 和
publicKey，这里加密类型为 RSA，我们为集成接口申请 的 EipApplication
没有指定加密类型，默认 RSA。Oinone 的开放接口总共支持两种：RSA、 AES

图 6-72 增加两个字段 encryptType 和 publicKey

克

-O i

no ne

Step3\_2 新建 TestInOutConvertFunction

杰

②

599

Oinone7 天从入门到精通

杰

克

-O i

no ne

新建 TestInOutConvertFunction 实现 IEipInOutConverter 接口

图 6-73 新建 TestInOutConvertFunction ③ Step3\_3 修改
TestIntegrateServiceImpl 为集成方法增加 inOutConverter 的注解

600

杰

克

-O i

no ne

Oinone7 天从入门到精通

图 6-74 为集成方法增加 inOutConverter 的注解 （四）Step4 重启看效果

1.  点击集成测试菜单，点击创建一个集成应用按钮，数据库查看创建出来的
    EipApplication 记录和 EipAuthentication 记录，为记录填写 publicKey：

601

Oinone7 天从入门到精通

no ne

图 6-75 点击集成测试菜单

-O i

图 6-76 为记录填写 publicKey

杰

克

2.  再次点击集成测试菜单，依次点击恢复原有的效果，只有调用集成接口
    callQueryByIdError
    报错其他不再报错了，也可以进入集成接口模块的日志菜单查看请求 日志：

图 6-77 只有调用集成接口 callQueryByIdError 报错其他不再报错

八、自定义安全策略（AccessToken+签名） 例子采用
DEFAULT\_MD5\_SIGNATURE\_AUTHENTICATION\_PROCESSOR\_FUN 签名支持：md5 和
hmac 签名方式和签名摘要：请求方指定，在请求体中设置
signatureMethod、signature （一）Step1 更改开放接口认证方式 认证方式换成
DEFAULT\_MD5\_SIGNATURE\_AUTHENTICATION\_PROCESSOR\_FUN，
@Open.Advanced(authenticationProcessorFun=
EipFunctionConstant.DEFAULT\_MD5\_SIGNATURE\_AUTHENTICATION\_PROCESSOR\_FUN)

602

克

-O i

no ne

Oinone7 天从入门到精通

图 6-78 更改开放接口认证方式

（二）Step2 重启看效果

杰

期待效果，因为开放接口修改了安全相关校验，集成接口这边并没有调整，所以都会抛
错：

图 6-79 重启看效果 （三）Step3 为集成接口定义新的 auth 处理类 ①

Step3\_1 新建 SignUtil

新建 SignUtil 签名工具类

603

杰

克

-O i

no ne

Oinone7 天从入门到精通

图 6-80 新建 SignUtil 签名工具类 604

Oinone7 天从入门到精通 ②

Step3\_2 新建 TestMd5InOutConvertFunction

杰

克

-O i

no ne

1)  跟加密一样，必须在所有内容都处理完成后进行处理，要不然参数个数对不上的。
2)  例子中新增一种设置 Header 的方法，exchange.getMessage().setHeader
    前面， 在前面我们学习 AccessToken 的时候用的方法是：
    context.putInterfaceContextValue(IEipContext.HEADER\_PARAMS\_KEY+".accessToke
    n"

图 6-81 新建 TestMd5InOutConvertFunction ③

Step3\_3 修改 TestIntegrateServiceImpl

更换 inOutConverter 的注解为 TestMd5InOutConvertFunction

605

杰

克

-O i

no ne

Oinone7 天从入门到精通

图 6-82 更换 inOutConverter 的注解为 TestMd5InOutConvertFunction
（四）Step4 重启看效果

点击集成测试菜单，依次点击恢复原有的效果，只有调用集成接口
callQueryByIdError
报错其他不再报错了，也可以进入集成接口模块的日志菜单查看请求日志：

606

Oinone7 天从入门到精通

图 6-83 重启看效果

九、自定义序列化方式 （一）Step1 新增一个 xml 的开放接口

-O i

no ne

为 TestOpenApiModelServiceImpl 新增一个方法
queryById4ReturnXml，使用@Open 注 解，路径配置为 xml。同时记得重启
second 应用，发布这个 openApi：

克

图 6-84 为 TestOpenApiModelServiceImpl 新增一个方法 queryById4ReturnXml
（二）Step2 Demo 工程引入 dom4j 的依赖包

杰

在总工程中修改 pom.xml 增加对 dom4j 的依赖管理

图 6-85 在总工程中修改 pom.xml 增加对 dom4j 的依赖管理 在
pamirs-demo-core 工程中修改 pom.xml 增加对 dom4j 的依赖

图 6-86 在 pamirs-demo-core 工程中修改 pom.xml 增加对 dom4j 的依赖
（三）Step3 自定义序列化函数 TestSerializableFunction

新建 TestSerializableFunction 实现 IEipSerializable<SuperMap>接口:

607

杰

克

-O i

no ne

Oinone7 天从入门到精通

608

杰

克

-O i

no ne

Oinone7 天从入门到精通

609

no ne

Oinone7 天从入门到精通

图 6-87 自定义序列化函数 TestSerializableFunction （四）Step4
新增一个异常判定类

杰

克

-O i

新增 TestXmlExceptionPredictFunction
异常判定类，因为原来的异常判断类配置在了
TestEipConfig，所以所有方法都会默认使用 TestEipConfig
类上定义的异常判断类。

图 6-88 新增一个异常判定类 （五）Step5 修改 TestIntegrateService 和
TestIntegrateServiceImpl

TestIntegrateService 增加方法定义

610

Oinone7 天从入门到精通 图 6-89 TestIntegrateService 增加方法定义

杰

克

-O i

no ne

TestIntegrateServiceImpl 实现 callQueryReturnXml
并定义为集成接口，同时配置自 定义序列化函数：

图 6-90 TestIntegrateServiceImpl 实现 callQueryReturnXml （六）Step6
增加测试入口

修改 TestEipAction 类增加一个 callQueryByXml 的 Action 定义，调用
testIntegrateService 集成接口的 callQueryReturnXml 方法:

611

Oinone7 天从入门到精通

图 6-91 修改 TestEipAction 类增加一个 callQueryByXml 的 Action 定义

no ne

（七）Step7 重启看效果

十、Eip 注解说明 （一）开放接口注解

-O i

图 6-92 重启看效果

杰

克

Open ├── name 显示名称 ├── config 配置类 ├── path 路径 ├── Advanced
更多配置 │ ├── httpMethod 请求方法，默认：post │ ├── inOutConverterFun
输入输出转换器函数名称 │ ├── inOutConverterNamespace
输入输出转换器函数命名空间 │ ├── authenticationProcessorFun
认证处理器函数名称 │ ├── authenticationProcessorNamespace
认证处理器函数命名空间 │ ├── serializableFun 序列化函数名称 │ ├──
serializableNamespace 序列化函数命名空间 │ ├── deserializationFun
反序列化函数名称 │ └── deserializationNamespace 反序列化函数命名空间
（二）集成接口注解 Integrate ├── name 显示名称 ├── config 配置类 ├──
Advanced 更多配置 │ ├── host 请求域名+端口 │ ├── path 请求路径 以“/”开头
612

Oinone7 天从入门到精通

杰

克

-O i

no ne

│ ├── schema 请求协议 http 或者 https │ └── httpMethod 请求方法，默认
post ├── ExceptionProcessor 异常配置 │ ├── exceptionPredictFun
异常判定函数名 │ ├── exceptionPredictNamespace 异常判定函数命名空间 │
├── errorMsg 异常判定 Msg 的键值 │ └── errorCode 异常判定 errorCode
的键值 ├── RequestProcessor 请求处理配置 │ ├── finalResultKey
请求的最终结果键值 │ ├── inOutConverterFun 输入输出转换器函数名称 │ ├──
inOutConverterNamespace 输入输出转换器函数命名空间 │ ├──
paramConverterCallbackFun 参数转换回调函数名称 │ ├──
paramConverterCallbackNamespace 参数转换回调函数命名空间 │ ├──
authenticationProcessorFun 认证处理器函数名称 │ ├──
authenticationProcessorNamespace 认证处理器函数命名空间 │ ├──
serializableFun 序列化函数名称 │ ├── serializableNamespace
序列化函数命名空间 │ ├── deserializationFun 反序列化函数名称 │ ├──
deserializationNamespace 反序列化函数命名空间 │ └── convertParams
参数转化集合 │ └── ConvertParam 参数转化 │ ├── inParam 输入参数的键值 │
└── outParam 输出参数的键值 ├── ResponseProcessor 请求处理配置 │ ├──
finalResultKey 响应的最终结果键值 │ ├── inOutConverterFun
输入输出转换器函数名称 │ ├── inOutConverterNamespace
输入输出转换器函数命名空间 │ ├── paramConverterCallbackFun
参数转换回调函数名称 │ ├── paramConverterCallbackNamespace
参数转换回调函数命名空间 │ ├── authenticationProcessorFun
认证处理器函数名称 │ ├── authenticationProcessorNamespace
认证处理器函数命名空间 │ ├── serializableFun 序列化函数名称 │ ├──
serializableNamespace 序列化函数命名空间 │ ├── deserializationFun
反序列化函数名称 │ ├── deserializationNamespace 反序列化函数命名空间 │
└── convertParams 参数转化集合 │ └── ConvertParam 参数转化 │ ├── inParam
输入参数的键值 │ └── outParam 输出参数的键值

十一、Eip 处理函数说明 Eip 处理函数

作用

需实现接口

说明

613

Oinone7 天从入门到精通 inOutConverter 输入输出转换器

inOutConverter

函数

IEipInOutConverter

核心处理请求体的 构造或响应体的构 造 如果自定义 paramConverter，
会让默认

参数转换回调函

paramConverter

数

IEipParamConverter

ConvertParam 配 置的（inParam， outParam）转化失 效了，需要自行处 理

序列化函数

IEipSerializable<SuperMap>

-O i

serializable

no ne

authenticationProcessor 认证处理器函数
IEipAuthenticationProcessor<SuperMap>

反序列化函数

异常判定函数

杰

exceptionProcessor

IEipDeserialization<SuperMap>

克

deserialization

序列化方法将任意 对象转换为上下文 承载对象 目前这个意义不
大，因为如果设置 了 finalResultKey， 就会不走反序列 化。现在都是通过
inoutconverter 处理的。

IEipExceptionPredict<SuperMap>

表 6-10 Eip 处理函数说明

（一）paramConverter 的特殊转换 paramConverter 的特殊转换

IEipContext.URL\_QUERY\_P

convertParams={

URL\_QUERY\_PAR

ARAMS\_KEY.xxx

@Integrate.ConvertParam(inParam="id",outParam=IEipConte

AMS\_KEY

是请求参数，会拼接在 url

xt.URL\_QUERY\_PARAMS\_KEY+".id")

的问号后面

}

614

Oinone7 天从入门到精通 HEADER\_PARAMS

IEipContext.HEADER\_PARA MS\_KEY.xxx

\_KEY

convertParams={ @Integrate.ConvertParam(inParam="id",outParam=IEipConte
xt.HEADER\_PARAMS\_KEY+".id")

是 http 请求头参数

}

表 6-11 paramConverter 的特殊转换

克

-O i

no ne

（二）调用流程

杰

图 6-93 请求调用流程

615

no ne

Oinone7 天从入门到精通

6.3 数据审计

-O i

图 6-94 响应调用流程

在业务应用中我们经常需要为一些核心数据的变更做审计追踪，记录字段的前后变化、
操作
IP、操作人、操作地址等等。数据审计模块为此提供了支撑和统一管理。它在成熟的
企业的核心业务系统中，需求是比较旺盛的。接下来我们开始学习下数据审计模块.

克

一、准备工作

杰

1.  pamirs-demo-core 的 pom 文件中引入 pamirs-data-audit-api 包依赖：

图 6-95 引入 pamirs-data-audit-api 包依赖

2.  pamirs-demo-boot 的 pom 文件中引入 pamirs-data-audit-core 和
    pamirs-third-party-map-core
    包依赖，数据审计会记录操作人的地址信息，所以也依赖了
    pamirs-third-party-map-core：

图 6-96 引入 pamirs-data-audit-core 和 pamirs-third-party-map-core
包依赖

616

Oinone7 天从入门到精通 3. pamirs-demo-boot 的 application-dev.yml
文件中增加配置 pamirs.boot.modules 增加 data\_audit 和
third\_party\_map，即在启动模块中增加 data\_audit 和 third\_party\_map
模 块：

图 6-97 在启动模块中增加 data\_audit 和 third\_party\_map 模块

no ne

4.  为 third\_party\_map 模块增加高德接口 api，下面
    e439dda234467b07709f28b57f0a9bd5 换成自己的 key：

图 6-98 e439dda234467b07709f28b57f0a9bd5 换成自己的 key

二、数据审计

杰

克

-O i

l 注解式（举例） （一）Step1 新增 PetTalentDataAudit 数据审计定义类

图 6-99 新增 PetTalentDataAudit 数据审计定义类 （二）Step2 修改
PetTalentAction 的 update 方法

做审计日志埋点:手工调用
OperationLogBuilder.newInstance().record()方法。需要
注意的是这里需要把原有记录的数据值先查出来做对比：

617

no ne

Oinone7 天从入门到精通

图 6-100 修改 PetTalentAction 的 update 方法 （三）Step3 重启看效果

克

-O i

修改宠物达人记录对应的字段，然后进入审计模块查看日志：

杰

图 6-101 修改宠物达人记录对应的字段

图 6-102 进入审计模块查看日志

6.4 国际化之多语言
多语言是国际化中大家最常面对的问题，我们需要对应用的页面结构元素进行翻译，也
需要对系统内容进行翻译比如：菜单、数据字典等，甚至还会业务数据进行翻译。但不管什
么翻译需求，我们在实现上基本可以归类为前端翻译和后端翻译。前端翻译顾名思义是在前
618

Oinone7 天从入门到精通
端根据用户选择语言对内容进行翻译，反之就是后端翻译。本文会带着大家了解
Oinone 的 前端翻译与后端翻译。

一、准备工作 1. pamirs-demo-boot 的 pom 文件中引入 pamirs-translate
包依赖：

图 6-103 pom 文件中引入 pamirs-translate 包依赖

no ne

2.  pamirs-demo-boot 的 application-dev.yml 文件中增加配置
    pamirs.boot.modules 增加 translate：

图 6-104 增加 translate

二、后端翻译（使用）

-O i

这里通过对菜单的翻译来带大家了解翻译模块 （一）Step1 新增翻译记录
切换应用到 translate 模块，点击新增翻译。

源术语为：商店 翻译值为：shop 状态为：激活

杰

1)  2)  3)  

克

1.选择新增翻译生效模块 2.选择翻译的模型为：菜单模型
3.源语言选择中文，目标选择 English 4.添加翻译项目：

图 6-105 新增翻译记录

619

Oinone7 天从入门到精通 （二）Step2 查看效果

应用切换到 Demo 模块，在右上角切换语言至英语

图 6-106 右上角切换语言至英语

三、后端翻译（自定义模型的翻译）

克

-O i

no ne

在前面菜单的翻译中，似乎我们什么都没做就可以正常通过翻译模块完成多语言的切换
了。是不是真如我们想象的一样，当然不是。是因为 Menu 模型的 displayName
字段加上 @Field(translate = true)注解。 （一）Step1 为 PetType 模型的
name 字段增加翻译注解

图 6-107 为 PetType 模型的 name 字段增加翻译注解 （二）Step2
重启应用查看效果

杰

1.切换应用到 translate 模块，点击新增翻译

图 6-108 点击新增翻译

620

Oinone7 天从入门到精通 2.切换应用到 Demo 模块，切换中英文，查看效果

图 6-109 切换中英文查看效果

四、前端翻译

杰

克

-O i

no ne

还记得我们前端【第一个自定义动作】吗？会弹出“Oinone 第一个自定义
Action，啥 也没干”，我们要对它进行翻译。 （一）Step1 修改前端
DoNothingActionWidget.ts ① import translateValueByKey ② 提示语用
translateValueByKey 加上翻译 const confirmRs =
executeConfirm(translateValueByKey('Oinone 第一个自定义 Action，啥也没干
')||'Oinone 第一个自定义 Action，啥也没干');
前端更多翻译工具请见【前端高级特性-框架之翻译工具】

图 6-110 修改前端 DoNothingActionWidget.ts （二）Step2 新增翻译记录 621

Oinone7 天从入门到精通

no ne

前端翻译的翻译记录对应的模型可以随意找一个放。但要注意几点： ①
不要找有字读配置 translate = true 的模型，因为会影响后端翻译性能。 ②
最好统一到一个模型中，便于后续管理。这里大家可以自定义一个无有业务访问且
本身无需要翻译的模型来挂载，避免性能损失：

图 6-111 新增翻译记录

克

-O i

（三）Step3 刷新远程资源生成前端语言文件

图 6-112 刷新远程资源生成前端语言文件

（四）Step4 新增或修改.env

杰

前端在项目根目录下新增或修改.env，可以参考.env.example 文件。通过.env
文件为 前端配置 oss 文件路径，针对 I18N\_OSS\_URL
配置项。真实前端访问翻译语言文件的路径规
则为：http://bucket.downloadUrl/mainDir/租户/translate/模块/语言文件。 ①
yaml 文件中 oss 配置的文件路径：
http://pamirs.oss-cn-hangzhou.aliyuncs.com/upload/demo/ ②
租户/translate/模块/语言文件，前端会自动根据上下文组织：

图 6-113 针对 I18N\_OSS\_URL 配置项 （五）Step5 重启前端应用看效果

对语言进行中英文切换，进入宠狗达人页面，点击第一个自定义
Action，查看前端翻 译效果： 622

Oinone7 天从入门到精通

no ne

图 6-114 查看翻译效果

图 6-115 查看翻译效果

6.5 权限体系

一、整体介绍

克

-O i

做好企业级软件，首先得过权限这一关。 在企业的 IT
部门沟通中，权限是避免不了。自嘲下在我们刚出来创业时，为了收获客
户对我们技术能力的信任，每每与跟客户沟通时都会说我们是阿里出来的，但在权限设计这
个环节不那么灵验，反而被打上了不懂 B
端权限设计的标签，会问很多问题。我就很奇怪难
道大厂就没有内部管理系统了？大厂只有 C 端交易，没有 B
端交易？但从侧面说明权限不简
单还特别重要。做好企业级软件，首先得过权限这一关。

杰

1.  对于平台运行来说，权限是必须，但我们的 auth 模块不是必须的，auth
    模块只是 我们提供的一种默认实现，客户可以根据平台的 spi
    机制进行替换。auth 模块利 用了平台的 Hook
    特性做到与业务无关，在我们开发上层应用的时，是不用感知它 的存在的。
2.  auth 模块涉及：功能权限、数据权限

<!-- -->

1)  数据权限：行权限和列权限。备注：数据权限的控制只能用于存储模型 ①
    表级权限：表达的语义是：是否该表可读/写（修改和新增） ②
    列权限：表达的语义是：是否该列可读/写（修改和新增） ③
    行权限：表达的语义是：是否对该行可读/写（修改）/删除
2)  功 能 权 限 ： 表 达 的 语 义 是 ServerAction/Function 是 否 可 执
    行 / 展 示 ， viewAction 是否可展示，菜单是否可以显示
3)  范围说明： ① 配置多个权限项的时候，取并集 ②
    配置多个角色的时候，取并集

<!-- -->

3.  模型设计

623

Oinone7 天从入门到精通

no ne

图 6-116 模型设计

二、产品体验 （一）Step1 创建角色

克

-O i

通过 App Finder 切换至权限应用，点击新增按钮创建一个名为 Oinone 的角色

杰

图 6-117 创建一个名为 Oinone 的角色

图 6-118 角色创建完成 （二）Step2 创建数据权限项

在权限项列表菜单，点击创建按钮，新增一个名为宠物达人数据权限项，同时宠物达人
的数据权限设置为只能查看性别为男的记录。 配置说明：

1.名称：代表该项配置的权限的名字（必填）（必须是全系统唯一）
2.权限模型：选择需要拦截的数据所在的表，即为模型，可以搜索使用
3.描述：对该权限项的描述 4.权限条件的配置： ①
满足全部：对条件一和条件二要同时满足的数据才能被看见 624

Oinone7 天从入门到精通 ②
满足任一：对条件一和条件二要任意满足的数据都能被看见

no ne

5.读权限：对该数据是否有读取的权限 6.写权限：对该数据是否有修改的权限
7.删除权限：对该条件内的数据是否有删除的权限

图 6-119 创建数据权限项 （三）Step3 为角色配置权限

杰

克

-O i

1.  编辑 Oinone 角色，只开通 OinoneDemo 工程应用

图 6-120 编辑 Oinone 角色，只开通 OinoneDemo 工程应用 2.
选中数据权限选项卡点击添加按钮，勾选宠物达人数据权限项点击确定按钮

625

Oinone7 天从入门到精通

no ne

图 6-121 勾选宠物达人数据权限项点击确定按钮 3.
整体点击保存，回到列表页记得点击权限生效按钮

-O i

图 6-122 回到列表页记得点击权限生效按钮 （四）Step4 新建用户绑定角色

杰

克

切换到用户中心模块，点击创建按钮填写必要信息，并在角色选中 Oinone
权限组。

图 6-123 新建用户绑定角色 退出 admin 用户，用 Oinone 登陆，权限效果：

1.只能看见 demo 模块 2.Oinone 登陆只能看到性别为男的宠物达人记录

626

Oinone7 天从入门到精通

图 6-124 用 Oinone 登陆

Oinone 用户登陆

no ne

admin 用户登陆

克

-O i

因为宠物达人的页面没有把性别字段放出来，我们看下数据库数据

图 6-125 admin 用户登陆与 Oinone 用户登陆对比

杰

三、auth 模块扩展

在日常项目开发中，难免会碰到一些针对权限管理的特殊需求，或是为提升性能做的特
殊逻辑。接下来我给大家介绍 auth 模块扩展性。 （一）权限全局配置
对所有权限角色都做限制，而且不想让用户感知，可以实现 PermissionFunApi
接口， API 接口实现的配置方式：只能用于支持全局的数据权限配置。

1.  实现接口 PermissionFunApi
2.  将实现托管给 SpringAOP
3.  接口的具体实现看下图的代码

627

Oinone7 天从入门到精通

no ne

图 6-126 实现接口 PermissionFunApi

杰

克

-O i

图 6-127 第一个自定义 Action

图 6-128 添加达人数据 （二）不参与权限控制

如果某一接口不想做权限控制，则可以在启动工程的 application-dev.yml
文件中配置 不需要权限过滤的接口：

图 6-129 配置代码

628

Oinone7 天从入门到精通
换一个没有配置宠物达人权限的用户（除管理员以外）进入系统，则也可以看到数据。
注意：权限全局控制还是生效的。 （三）API

1.  获取当前用户对该模型的行权限

图 6-130 获取当前用户对该模型的行权限

no ne

返回值为:

图 6-131 返回值

杰

克

-O i

用法 ：
场景：前端发起的请求都会经过权限拦截，后端代码逻辑发起的数据请求都是不经过任
何权限的过滤，但是某些特殊情况需要在后端代码逻辑发起的数据请求也带上权限过滤
入参：请求的模型 出参：Result 数据结构中 data
会存储一段字符串，该字符串为 Rsql 将该 Rsql 追加到 wrapper 中

图 6-132 将 Rsql 追加到 wrapper 中

6.6 消息
在我们系统研发过程中经常需要发送短信、邮件、站内信等，笔者在本文给大家介绍下
如何使用 Oinone 的消息模块。

一、准备工作
如果通过我们工程脚手架工具生成的则已经引入了无需做更多的配置，如果不是则需要
按以下步骤先配置依赖和增加启动模块。 1. pamirs-demo-boot 的 pom
文件中引入 pamirs-message-core 包依赖：

629

Oinone7 天从入门到精通

图 6-133 引入 pamirs-message-core 包依赖 2. pamirs-demo-boot 的
application-dev.yml 文件中增加配置 pamirs.boot.modules 增加
message，即在启动应用中增加 message 模块：

no ne

图 6-134 pamirs.boot.modules 增加 message

二、消息参数设置

-O i

发送邮件和短信需要设置对应的发送邮箱服务器和短信云，短信目前默认阿里云短信。
我们通过代码示例来完成对应邮箱和短信的参数设置 （一）Step1 增加
pamirs-message-api 依赖 pamirs-demo-core 的 pom 文件中引入
pamirs-message-api 包依赖：

克

图 6-135 引入 pamirs-message-api 包依赖 （二）Step2 消息参数设置

杰

请自行替换邮箱服务器和短信通道的账号信息

630

杰

克

-O i

no ne

Oinone7 天从入门到精通

图 6-136 消息参数设置 631

Oinone7 天从入门到精通 三、消息发送举例

no ne

该例子以各种站内信、邮件、短信方式发送宠物商品库存记录信息为例，构建宠物商品
库存信息发送服务并在宠物商品库存模型的表格页面创建发送入口。 （一）Step1
创建宠物商品库存信息发送服务接口 在 Api 工程新建
PetItemInventoryMessageService 接口，并定义发送站内信、邮件、 短信的三个
Function：

图 6-137 在 Api 工程新建 PetItemInventoryMessageService 接口 （二）Step2
发送站内信

杰

克

-O i

在 Core 工程新建 PetItemInventoryMessageService 接口的实现类

632

杰

克

-O i

no ne

Oinone7 天从入门到精通

633

杰

克

-O i

no ne

Oinone7 天从入门到精通

图 6-138 在 Core 工程新建 PetItemInventoryMessageService 接口的实现类
（三）Step3 为宠物商品库存模型的表格页面新增发送入口

把以下代码复制到 PetItemInventroyAction 类中

634

-O i

no ne

Oinone7 天从入门到精通

图 6-139 把下代码复制到 PetItemInventroyAction 类中

克

（四）Step4 重启看效果

杰

请分别点击发送邮件、发送短信、发送站内信测试效果，自行测试效果

图 6-140 自行测试效果

635

Oinone7 天从入门到精通 第七章 Oinone 的设计器们
设计器转为非专业研发设计，在 Oinone 3.0
版本中已经完成元数据完整在线化，真正
做到低无一体。对于设计器的定位我们开篇就介绍过，它是 LCDP
的产品化呈现，是冰山露 在外面大家看得到的，核心还是在 LCDP
本身。本章先带大家目睹下设计器的一些产品页面， 如果您想体验，可以在
Oinone 官网（https://www.oinone.top）注册，不过需要先联系工
作人员或合作伙伴获取邀请码。 1. 设计器总览 2. 实战训练（积分发放） 3.
实战训练（全员营销为例） 4. Oinone 的低无一体

no ne

7.1 设计器总览

一、模型设计器

-O i

设计器转为非专业研发设计，在 Oinone3.0
版本中已经完成元数据完整在线化，真正做
到低无一体。对于设计器的定位我们开篇就介绍过，它是 LCDP
的产品化呈现，是冰山露在 外面大家看得到的，核心还是在 LCDP
本身。我们先目睹下设计器的一些产品页面，如您有 想体验，可以在 Oinone
官网：https://www.oinone.top/注册。

杰

克

Oinone
以模型为驱动，当有模型、数据字典、数据编码等设计功能，我们就可以完整
地定义产品数据模型，模型设计器整体呈现区别于普通 ER
图，以当前模型为核心视角展开，
可以点击关联模型切换主视角。这样的好处在于突出当前设计，聚焦设计本身。同时模型上
预留了几个核心入口如：分类管理、继承拓扑图、页面设计、逻辑设计等。另外我们在体验
上区分了专家模式和经典模式，顾名思义，专家模式的功能会更加丰富，对专业知识的要求
也会更高。一般是业务无关的设计如：索引设置等调优行为。

图 7-1 模型设计器-系统模型

636

Oinone7 天从入门到精通

杰

克

-O i

no ne

图 7-2 模型设计器-添加字段

图 7-3 模型设计器-创建模型

图 7-4 模型设计器-系统字典 637

Oinone7 天从入门到精通

克

-O i

no ne

图 7-5 模型设计器-自定义编码

图 7-6 模型设计器-编辑数据编码

二、逻辑设计器

杰

从图灵完备的角度上说，要支持功能越完备，使用越复杂。我们优先从图灵完备的角度
出发，所以我们第一版逻辑设计器相对比较复杂，第二版本规划中会类似模型设计器推出专
家版和经典版。

图 7-7 逻辑设计器-逻辑设计 638

Oinone7 天从入门到精通

图 7-8 逻辑设计器-逻辑运行

no ne

三、界面设计器

杰

克

-O i

界面设计器第一版会先支撑后端页面在线自定义，后边将陆续推出前端页面、多端能力。
为了支持多端和 2C
页面的设计，我们对前后端协议做了比较大的改造。目前设计器已经支
持完全基于 V3 的前后端协议。

图 7-9 界面设计器-页面视图

图 7-10 页面设计器-组件库 639

Oinone7 天从入门到精通 四、数据可视化

no ne

数据可视化支持从内部系统模型获取数据内容后，根据业务需求自定义图表，目的是为
企业提供更高效的数据分析工具。
与市场同类产品相比，我们的数据可视化产品：不需要前置维护数据源、进行数据转换；
可智取业务系统模型，系统自动解析选择的模型、接口、表格中的字段后进行数据分析；降
低对数据分析人员研发能力要求的同时，也提升了数据分析的效率。

杰

克

-O i

图 7-11 数据可视化-图表编辑

图 7-12 数据可视化-图表自定义

五、流程设计器 Oinone
流程设计器为业务流程和审批流程提供了可自动执行的流程模型：通过定义流
转过程中的各个动作、规则，以此实现流程自动化。在 Oinone
流程设计器中，流程可以跨
应用设计，不同应用的模型之间可以通过同一流程执行。

640

Oinone7 天从入门到精通

克

-O i

no ne

图 7-13 流程设计器-首页视图

杰

图 7-14 流程设计器-流程设计

图 7-15 流程设计器-节点设置 641

Oinone7 天从入门到精通 7.2 实战训练（积分发放） 一、前言
当我们碰到一个全新的场景，除了写代码以外也可以通过设计器来完成，大致步骤如下：
1. 分析业务场景，规划对应的模型并通过模型设计器进行配置 2.
通过界面设计器，设计出必要管理页面 3. 通过流程设计器，设计对应业务流程
4. 通过数据可视化，设计相应的数据看板

二、场景说明

杰

克

-O i

no ne

本节通过例子完成一个积分成本分摊的业务场景
积分支出：谁受益谁支出原则+导购手动确认原则，通过门店应用的积分规则，来实现
自动化+手动积分形式实现 l 案例背景
某家具企业经营多种家具类型，不同系列不同品类分事业部经营。 注：
独立门店：只能售卖本事业部下的商品；
融合门店：可以售卖多事业部下的商品；
需求：需要建立一套积分规则，遵循谁受益谁支出原则+导购手动确认原则；通过门店
应用的积分规则，来实现自动化+手动积分。

图 7-16 企业组织架构 l

场景一

导购 a 邀请老客户 c 通过裂变分享新客户 x 在独立门店 1
下单。系统根据独立门店 1 的积分规则，自动发放积分给老客户 c 和新客户
x，积分由国一事业部承担。 642

Oinone7 天从入门到精通

l

no ne

图 7-17 场景一 场景二

克

-O i

融合门店 1 导购 b 邀请老客户 d 裂变分享新客户 y
在融合门店下单。该订单可能涉及多 个事业部，由导购 b
手动选择最大量值的积分规则进行发放。

l

场景三

杰

图 7-18 场景二

独立门店 1 的导购 a 邀请老客户 c 裂变分享新客户 z 在独立门店 2
下单。系统根据独立 门店 2 的积分规则，来计算积分值，自动发放老客户 c
和新客户 z 的积分，积分由国二事业 部。

643

Oinone7 天从入门到精通 图 7-19 场景三

三、实战训练 （一）Step1 分析业务场景规划对应模型
本场景下涉及基础对象模型包括：事业部、门店、导购、会员等

1.事业部：它是积分成本的载体
2.门店：类型分为独立门店和融合门店，独立门店必须隶属于一个事业部，同时配置
默认积分发放规则，融合门店可能属于多个事业部当发生积分发放时，需要店员手
工选择成本事业部和积分发放规则

3.导购员：导购员必须隶属于一个门店等
4.会员：消费者需要记录它隶属导购员，以及是由哪个会员推荐过来的等
涉及业务对象模型包括：积分发放规则，积分发放记录，邀请下单记录

1.积分发放规则：会员积分发放规则，对应邀请老客的积分发放规则等
2.积分发放记录：本次发放积分、本次发放积分规则、发放对象(会员)、成本事业部、

no ne

关联门店、关联导购、关联老客（可空）、关联下单记录编码等

3.邀请下单记录：导购、下单会员、下单门店、商品信息、下单金额等

杰

克

-O i

对应模型如下：

图 7-20 分析业务场景规划对应模型

（二）Step2 利用模型设计器设计模型

我们建模型的时候应用选择全员营销，本次实战逻辑放到全员营销应用下，目前
Oinone 的 apps
还未开放新建应用或模块的入口，后续开放可以新建一个新的应用并把逻辑放到独
立的应用下： 模型

设计器呈现

自定义字段列表

关系字段说明

与门店建立 o2m 绑定关 事业部

事业部负责人(文本) 门店列表(o2m)

系,绑定时选择双向绑 定，双向绑定意思是在 事业部这边建立 o2m 到
门店的关系字段，在门

说明

关系字段需要在有对方 模型的情况下再建，比 如事业部中的门店列表
则是再后面追加新增的

644

Oinone7 天从入门到精通 店那边建立 m2o 的关系 字段

导购列表(o2m)

分别与事业部、导购、

门店类型：需要先建对 积分发放规则建立 m2o、 默认积分发规则(m2o)
应的数据字典 o2m、m2o 关系 门店类型(枚举)

门店

no ne

事业部(m2o)

1.  

绑定用户(m2o) 导购

门店(m2o)

与门店建立 m2o 关系

-O i

是否离职(布尔型)

克

会员累计积分(浮点 数)

会员

推荐客户(m2o)

杰

所属于导购员(m2o)

积分发放 规则

是否为新客(布尔型)

绑定用户，用 于后续业务流程设计中 的填写规则

2.  

打马赛克的忽 略，其他场景测试用

1.  

会员 m2o 的字 段是自关联用于存储推

与导购、会员建立 m2o 荐会员 关系

2.  

打马赛克的忽 略，其他场景测试用

推荐客户发放比例(浮 点数) 发放倍数(整数)

645

Oinone7 天从入门到精通 最终发放积分(浮点

1.  

数)

会员有两个

关联积分规则(m2o)

m2o，分别用户记录发放

事件编码(文本)

会员和发放会员的推荐

推荐导购员(m2o) 积分发放

推荐会员(m2o)

记录

关系门店(m2o) 成本事业部(m2o)

与积分发放规则、导购

会员也就是老客

2.  

员、会员、门店、事业 部建立 m2o 关系

事件编码用户 维护触发本次积分发放 记录产生的源头单据编

会员(m2o)

码如：邀请下单记录的

成本事业部名称（文

编码

本） 会员名称（文本） 成本事业部(m2o)

1.  

(m2o)

no ne

选择积分发放规则

与成本事业部、积分发

下单门店(m2o)

放规则、下单门店、会

记录

购买商品(文本)

员、导购等建立 m2o 的

下单金额(整数)

关系

成本事业部、 积分发放规则是业务流 程中自动计算回填的数 据

-O i

导购(m2o)

店、导购属于必要信息

2.  

邀请下单

会员(m2o)

会员、下单门

表 7-1 利用模型设计器设计模型

（三）Step3 利用界面设计器，设计出必要的管理页面

杰

克

以事业部为例，构建管理页面。其他模型依次按例子建立管理页面： 1.
进入界面设计器，应用选择全员营销，模型选择事业部，点击添加页面下的直接创建

图 7-21 点击直接创建 2.
设置页面标题、模型（自动带上可切换）、业务类型（运营管理后续会扩展其他类型）、
视图类型（表单）后点击确认按钮进入事业部表单设计页面

646

no ne

Oinone7 天从入门到精通

杰

克

-O i

图 7-22 页面设置 3. 进入页面设计器，对事业部表单页面进行设计： ①
左侧为物料区：分为组件、模型。 1)
【组件】选项卡下为通用物料区，我们可以为页面增加对应布局、字段（如同
在模型设计器增加字段）、动作、数据、多媒体等等 2)
【模型】选项卡下为页面对应模型的自定义字段、系统字段、以及模型已有动 作
② 中间是设计区域 ③
右侧为属性面板，在设计区域选择中组件会显示对应组件的可配置参数

图 7-23 对事业部表单页面进行设计 4.
在左侧【组件】选项卡下，拖入布局组件【分组】，并设置组件【标题属性】为基础信
息：

647

Oinone7 天从入门到精通

图 7-24 设置组件【标题属性】为基础信息

-O i

no ne

5.  在左侧【组件】选项卡下，再次拖入布局组件【分组】，并设置组件【标题属性】为门
    店列表：

克

图 7-25 设置组件【标题属性】为门店列表

杰

6.  在左侧【模型】选项卡下，分别把自定义字段中的【事业部负责人】和系统字段中的【名
    称】拖入【基础信息】分组，把自定义字段中的【门店列表】字段拖入门店列表分组：

图 7-26 把自定义字段中的【门店列表】字段拖入门店列表分组 7.
在设计区域切换【门店列表】展示组件为【表格】：

648

Oinone7 天从入门到精通

图 7-27 在设计区域切换【门店列表】展示组件为【表格】

-O i

no ne

8.  此时【门店列表】展示形式变成了表格形式，选中【门店列表】组件，会发现左侧【模
    型】选项卡下的当前模型切换成了【门店】，同时我们在右属性面板区置空其【标题属
    性】：

克

图 7-28 在右属性面板区置空其【标题属性】

杰

9.  设计区选中【门店列表】的表格组件，分别把自定义字段中的【默认积分发规则】、【门
    店类型】、【导购列表】和系统字段中的【名称】拖入【门店列表】表格组件的表格字
    段设计区：

图 7-29 将【名称】拖入【门店列表】表格组件的表格字段设计区 649

Oinone7 天从入门到精通

no ne

10. 设计区选中【门店列表】的表格组件的【创建】按钮，点击【打开弹窗】设计关系字段
    【门店】的新增页面：

图 7-30 点击【打开弹窗】设计关系字段【门店】的新增页面

杰

克

-O i

11. 分别把自定义字段中的【默认积分发规则】、【门店类型】和系统字段中的【名称】拖
    入门店的新增页面设计区：

图 7-31 新页面设计区

12. 选中弹出框中【取消】取消按钮，设置其【按钮样式】属性为【次要按钮】

650

Oinone7 天从入门到精通

no ne

图 7-32 设置【按钮样式】属性为【次要按钮】 13. 关闭弹出框，回到主设计区

图 7-33 关闭弹出框回到主设计区

杰

克

-O i

14. 设计区选中【门店列表】的表格组件的【删除】按钮，设置其【按钮样式】属性为【次
    要按钮】，【二次确认】属性打开

图 7-34 【二次确认】属性打开 15.
设计区选中【门店列表】的表格组件中操作列的【编辑】按钮，点击【打开弹窗】设计
关系字段【门店】的编辑页面： a.
分别把自定义字段中的【默认积分发规则】、【门店类型】和系统字段中的【名称】
拖入门店的新增页面设计区。 b.
选中弹出框中【取消】取消按钮，设置其【按钮样式】属性为【次要按钮】 c.
把门店类型展示组件切换为【单选框】 d. 关闭弹出框

651

Oinone7 天从入门到精通

图 7-35 设计关系字段【门店】的编辑页面

克

-O i

no ne

16. 设计区选择非【门店列表】组件如基础信息，模型切换为主模型【事业部】，在左侧【模
    型】选项卡下，把动作分类下的提交类型【创建】动作拖入中间设计区的动作区：

杰

图 7-36 将【创建】动作拖入中间设计区的动作区

17. 选择中展示名为【确定】的创建动作按钮，在右侧属性面板中设置：是否隐藏属性为【条
    件隐藏】，隐藏条件为【id 非空】

图 7-37 将隐藏条件设置为【id 非空】 652

Oinone7 天从入门到精通

no ne

18. 在左侧【模型】选项卡下，把动作分类下的提交类型【更新】动作拖入中间设计区的动
    作区：

图 7-38 将【更新】动作拖入中间设计区的动作区

杰

克

-O i

19. 选择中展示名为【确定】的更新动作按钮，在右侧属性面板中设置：是否隐藏属性为【条
    件隐藏】，隐藏条件为【id
    为空】。之所以同时拖入【创建】和【更新】动作并都命
    名为确认，是期望这个页面同时可以做为新增页面也可以做为编辑页面，只不过要通过
    条件隐藏来设置按钮的出现规则：

图 7-39 通过条件隐藏来设置按钮的出现规则 20.
在左侧【组件】选项卡下，把动作分类下的【客户端动作】拖入中间设计区的动作区

653

Oinone7 天从入门到精通

图 7-40 将【客户端动作】拖入中间设计区的动作区

克

-O i

no ne

21. 选择设计区【客户端动作】，在右侧属性面板中设置：动作名称为【返回】，客户端行
    为为【返回上一个页面】并点击保存：

杰

图 7-41 设计区【客户端动作】

22. 选择设计区【返回】动作，在右侧属性面板中设置：按钮样式为【返回】，【二次确认】
    属性打开并设置提示文字【返回页面操作将不被保存】，可以点击预览二次确认看效果：

图 7-42 可点击预览二次确认看效果 654

Oinone7 天从入门到精通

no ne

23. 点击【发布】按钮，页面成功发布，每发布一次会有一个例子版本，可以通过历史版本
    进行恢复：

图 7-43 点击发布按钮，页面即可发布成功

杰

克

-O i

24. 点击右上角历史版本图标，进入历史版本查看页面

图 7-44 可进入历史版本查看页面 25.
在历史版本页面可以选择对应历史版本记录，并通过【恢复此版本】来完成页面的历史
版本切换

图 7-45 可选择对应历史版本记录并切换 655

Oinone7 天从入门到精通

no ne

26. 接下来我们为事业部模型创建表格管理页面，入口同编辑页面。设置页面标题、模型（自
    动带上可切换）、业务类型（运营管理后续会扩展其他类型）、视图类型（表格）后点
    击确认按钮进入事业部表格设计页面：

图 7-46 为事业部模型创建表格管理页面

杰

克

-O i

27. 进入页面设计器，对事业部表格页面进行设计：

图 7-47 对事业部表格页面进行设计

28. 在左侧【模型】选项卡下，分别把自定义字段中的【事业部负责人】和系统字段中的【名
    称】拖入表格组件的表格字段设计区

图 7-48 分别把【事业部负责人】和【名称】拖入表格字段设计区

656

Oinone7 天从入门到精通

no ne

29. 在左侧【组件】选项卡下，把动作分类下的【跳转动作】拖入中间设计区的动作区，并
    在右侧属性面板中设置动作名称为【新增】，数据控制类型为【不进行数据处理】，打
    开方式为【当前窗口打开】，动作跳转页面为【事业部编辑】页面，并点击保存：

图 7-49 数据控制类型为【不进行数据处理】

杰

克

-O i

30. 在左侧【组件】选项卡下，把动作分类下的【跳转动作】拖入中间设计区的行内动作区，
    并在右侧属性面板中设置动作名称为【编辑】，数据控制类型为【处理单条数据】，打
    开方式为【当前窗口打开】，动作跳转页面为【事业部编辑】页面，并点击保存

图 7-50 数据控制类型为【处理单条数据】 31.
在左侧【模型】选项卡下，把动作分类下的【删除】拖入中间设计区的动作区，并在右
侧属性面板中设置动作名称为【删除】，按钮样式为【次要按钮】，【二次确认】属性
打开

657

Oinone7 天从入门到精通

no ne

图 7-51 把动作分类下的【删除】拖入中间设计区的动作区

克

-O i

32. 点击右上角【显示母版】进入页面最终展示形式，点击添加菜单项，并在输入框中输入
    【事业部管理】

杰

图 7-52 点击右上角【显示母版】进入页面最终展示形式

33. 点击菜单右侧设置图标，选择【绑定已有页面】，进行菜单与页面的绑定操作：

图 7-53 进行菜单与页面的绑定操作 658

Oinone7 天从入门到精通

no ne

34. 在绑定页面中，模型选择【事业部】，视图选择【事业部管理】，点击确认按钮提交：

图 7-54 绑定页面设置

杰

克

-O i

35. 拖动【事业部管理】菜单到【积分管理】父菜单下：

图 7-55 拖动【事业部管理】菜单到【积分管理】父菜单下

36. 最后别忘了点击右上角【发布】按钮对【事业部管理】表格页面进行发布，回到界面设
    计器首页查看刚刚建好的两个页面：

图 7-56 回到界面设计器首页查看刚刚建好的两个页面 659

Oinone7 天从入门到精通 37.
以事业部为例分别对门店、导购、会员、积分发放规则、积分发放记录、邀请下单记录
等模型进行页面设计，这里不再累赘，请按照自身学习需要，尝试进行界面设计。
（四）Step4 通过流程设计器，设计对应业务流程

杰

克

-O i

no ne

我们先来整理下核心流程即：邀请下单流程：

图 7-57 邀请下单流程 ①

Step4.1 创建导购邀请下单记录触发流程

1.  进入流程设计器，点击【创建】按钮

660

Oinone7 天从入门到精通
注意：流程中需要获取【关系字段】的除关联字段(一般为
ID)以外的字段需要通过【数
据获取】节点单独获取【关系字段】的对象数据。所以在流程设计中经常会用到【数据获取】
节点

no ne

图 7-58 进入流程设计器，点击【创建】按钮

杰

克

-O i

2.  左上角编辑流程名称为【导购邀请下单触发流程】，点击第一个【触发】节点，触发方
    式选择模型触发，模型选择【导购邀请下单】，触发场景选择【新增数据时】，点击该
    节点的【保存】按钮

图 7-59 左上角编辑流程名称为【导购邀请下单触发流程】及其他设置 3.
点击流程图节点间的【+】图标选择增加【获取数据】节点，或者拖动左侧物料区【获
取数据】到特定的【+】图标

图 7-60 点击流程图节点间的【+】图标选择增加【获取数据】节点

661

Oinone7 天从入门到精通

图 7-61 拖动左侧物料区【获取数据】到特定的【+】图标

克

-O i

no ne

4.  点击【获取数据】，在右侧属性面板中设置【获取数据条数】为单条，选择模型为【导
    购】，点击【筛选条件】的【{X}】图标，进行数据获取的条件设置：

图 7-62 进行数据获取的条件设置

杰

5.  选择条件字段为【ID】条件操作符为【等于】，条件为变量的导购字段的
    ID。当上下
    文只有一个变量时默认不需要选择，这里默认的是【触发\[导购邀请下单记录\]】，设置
    好以后点击确认，回到属性面板设置【未获取到数据时执行方式】为【终止流程】，并
    点击节点【保持】按钮：

图 7-63 筛选条件设置 662

Oinone7 天从入门到精通

-O i

no ne

6.  再增加一个【获取数据】节点，在右侧属性面板中设置 ①
    【获取数据条数】为单条，选择模型为【会员】 ②
    点击【筛选条件】的【{X}】图标，进行数据获取的条件设置，选择条件字段为【ID】
    条件操作符为【等于】，条件为变量【导购邀请下单记录】的会员关系字段的
    ID 字段。
    因为上下文中存在多个变量时需要选择对应变量，跟获取导购数据有点区别，在获取导
    购数据时，上下文中只有此次【导购邀请下单记录】所以不需要选择对应变量，设置好
    以后点击【确认】按钮 ③
    回到属性面板设置【未获取到数据时执行方式】为【终止流程】 ④
    最后点击节点【保持】按钮。

克

图 7-64 增加一个【获取数据】节点，在右侧属性面板中设置

杰

7.  新增【条件分支】，分别对分支 1 和分支 2
    进行条件设置，条件为：【获取数据\[会员\]】
    的关系字段【所属导购员】的【ID】字段一个设置【为空】，一个设置【非空】

图 7-65 新增条件分支并进行相应设置

663

Oinone7 天从入门到精通

no ne

图 7-66 节点规则表达式设置

杰

克

-O i

8.  在【条件分支】的【获取数据\[会员\]】的关系字段【所属导购员】的【ID】字段【为空】
    的分支流程中，增加【更新数据】节点，在右侧属性面板中： ①
    【更新模型】选择【获取数据\[会员\]】 ② 【字段列表】点击【创建】按钮

<!-- -->

1)  字段选择 更新【所属导购员】的【ID】
2)  表达式设置为：【获取数据\[导购\]】的【ID】，点击【确认】按钮。
    最终完成对【获取数据\[会员\]】的关系字段【所属导购员】的【ID】字段等于【获取数
    据\[导购\]】的【ID】字段的设置，最后点击节点【保持】按钮。

图 7-67 创建字段和表达式

9.  再增加一个【获取数据】节点，在右侧属性面板中设置： ①
    【获取数据条数】为单条，选择模型为【门店】 ②
    点击【筛选条件】的【{X}】图标，进行数据获取的条件设置，选择条件字段为【ID】
    条件操作符为【等于】，条件为变量【导购邀请下单记录】的关系字段【下单门店】的【ID】
    字段。设置好以后点击【确认】按钮 ③
    回到属性面板设置【未获取到数据时执行方式】为【终止流程】 ④
    最后点击节点【保持】按钮。

664

Oinone7 天从入门到精通

no ne

图 7-68 增加【获取数据】节点，在右侧属性面板中设置

杰

克

-O i

10. 新增【条件分支】，分别对分支 1 和分支 2
    进行条件设置，条件为：【获取数据\[门店\]】
    的【门店类型】字段一个设置为【独立门店】，一个设置【融合门店】。这里条件值没
    有选择上下文变量，而是选择了选项。选项即字段对应的枚举值，在这个例子中【门店
    类型】字段类型为数据字典：

图 7-69 设置节点规则表达式

图 7-70 流程设计 665

Oinone7 天从入门到精通

杰

克

-O i

no ne

11. 在【条件分支】的【获取数据\[门店\]】的【门店类型】字段等于【独立门店】的分支流
    程中，增加【更新数据】节点，在右侧属性面板中

<!-- -->

(1) 【更新模型】选择【触发\[导购邀请下单\]】
(2) 【字段列表】点击【创建】按钮

<!-- -->

1)  字段选择 更新【成本事业部】的【ID】
2)  表达式设置为：【获取数据\[门店\]】的关系字段【事业部】的【ID】字段，点
    击【确认】按钮。

<!-- -->

(3) 【字段列表】点击【创建】按钮

<!-- -->

1)  字段选择 更新【选择积分发放规则】的【ID】
2)  表达式设置为：【获取数据\[门店\]】的关系字段【默认积分发放规则】的【ID】
    字段，点击【确认】按钮。 最终完成的【触发\[导购邀请下单\]】更新设置

<!-- -->

(1) 【触发\[导购邀请下单\]】的关系字段【成本事业部】的【ID】字段等于【获取数据
    \[门店\]】的关系字段【事业部】的【ID】字段
(2) 【触发\[导购邀请下单\]】的关系字段【选择积分发放规则】的【ID】字段等于【获
    取数据\[门店\]】的关系字段【默认积分发放规则】的【ID】字段
(3) 最后点击节点【保持】按钮。

图 7-71 成本事业部 ID 字段设置

图 7-72 积分发放规则字段设置 666

Oinone7 天从入门到精通

no ne

图 7-73 点击节点【保持】按钮

杰

克

-O i

12. 在【条件分支】的【获取数据\[门店\]】的【门店类型】字段等于【融合门店】的分支流
    程中，增加【填写】节点，在右侧属性面板中：

<!-- -->

(1) 【填写模型】选择模型为【触发\[导购邀请下单\]】
(2) 【选择视图】选择【流程中邀请下单】,这里需要专门为流程增加一个表单页面，
    因为正常的【导购邀请下单】的表单不需要填写积分发放规则和成本部门
(3) 填写人，选择导购的【绑定用户】，同时加上角色为【超级管理员】方便测试
(4) 数据权限除了【积分发放规则】和【成本部门】需要编辑外，其他都为查看

图 7-74 加上角色为【超级管理员】方便测试

667

no ne

Oinone7 天从入门到精通

杰

克

-O i

图 7-75 绑定用户多对一

图 7-76
数据权限除了【积分发放规则】和【成本部门】需要编辑外，其他都为查看 13.
再增加一个【获取数据】节点，在右侧属性面板中设置 (1)
【获取数据条数】为单条，选择模型为【积分发放规则】 (2)
点击【筛选条件】的【{X}】图标，进行数据获取的条件设置，选择条件字段为【ID】
条件操作符为【等于】，条件为变量【触发\[导购邀请下单\]】的关系字段【选择积
分发放规则】的【ID】字段。设置好以后点击【确认】按钮 (3)
回到属性面板设置【未获取到数据时执行方式】为【终止流程】 (4)
最后点击节点【保持】按钮
再增加一个【获取数据】节点，在右侧属性面板中设设置： (1)
【获取数据条数】为单条，选择模型为【事业部】 (2)
点击【筛选条件】的【{X}】图标，进行数据获取的条件设置，选择条件字段为【ID】
条件操作符为【等于】，条件为变量【触发\[导购邀请下单\]】的关系字段【成本事
业部】的【ID】字段。设置好以后点击【确认】按钮 668

Oinone7 天从入门到精通

杰

克

-O i

no ne

(3) 回到属性面板设置【未获取到数据时执行方式】为【终止流程】
(4) 最后点击节点【保持】按钮。

<!-- -->

14. 增加【新增数据】节点，在右侧属性面板中设置

<!-- -->

(1) 【新增模型】选择模型为【积分发放记录】
(2) 【新增数据的节点】设置为【节点执行完即时增加业务数据】
(3) 【新增数据】点击【创建】按钮

<!-- -->

1)  字段选择【最终发放积分】
2)  表达式设置为：【触发\[导购邀请下单\]】的【下单金额】字段【乘以】【获取
    数据\[积分发放规则\]】的【发放倍数】字段，点击【确认】按钮。

<!-- -->

(4) 【新增数据】点击【创建】按钮

<!-- -->

1)  字段选择关系字段【积分发放规则】的【ID】
2)  表达式设置为：【获取数据\[积分发放规则\]】的【ID】字段，点击【确认】按
    钮。

<!-- -->

(5) 【新增数据】点击【创建】按钮

<!-- -->

1)  字段选择【事件编码】
2)  表达式设置为：【触发\[导购邀请下单\]】的【编码】字段，点击【确认】按钮。

<!-- -->

(6) 【新增数据】点击【创建】按钮

<!-- -->

1)  字段选择关系字段【推荐导购员】的【ID】
2)  表达式设置为：【获取数据\[导购\]】的【ID】字段，点击【确认】按钮。

<!-- -->

(7) 【新增数据】点击【创建】按钮

<!-- -->

1)  字段选择关系字段【推荐会员】的【ID】
2)  表达式设置为：【获取数据\[会员\]】的关系字段【推荐客户】的【ID】字段，
    点击【确认】按钮。

<!-- -->

(8) 【新增数据】点击【创建】按钮

<!-- -->

1)  字段选择关系字段【关系门店】的【ID】
2)  表达式设置为：【获取数据\[门店\]】的【ID】字段，点击【确认】按钮。

<!-- -->

(9) 【新增数据】点击【创建】按钮

<!-- -->

1)  字段选择关系字段【成本事业部】的【ID】
2)  表达式设置为：【触发\[导购邀请下单\]】的关系字段【成本事业部】的【ID】
    字段，点击【确认】按钮。 (10)【新增数据】点击【创建】按钮
3)  字段选择关系字段【会员】的【ID】
4)  表达式设置为：【获取数据\[会员\]】的【ID】字段，点击【确认】按钮。
    (11)【新增数据】点击【创建】按钮 -- 为数据分析预留字段
5)  字段选择【成本事业部名称】
6)  表达式设置为：【获取数据\[事业部\]】的【名称】字段，点击【确认】按钮。
    (12)【新增数据】点击【创建】按钮 -- 为数据分析预留字段
7)  字段选择【会员名称】
8)  表达式设置为：【获取数据\[会员\]】的【名称】字段，点击【确认】按钮。
    (13)最终完成的【新增数据\[积分发放记录\]】新增设置，最后点击节点【保持】按钮。

669

Oinone7 天从入门到精通

克

-O i

no ne

图 7-77 字段表达式设置

杰

图 7-78 关联积分规则 ID 字段及表达式设置

图 7-79 事件编码字段及表达式设置 670

Oinone7 天从入门到精通

克

-O i

no ne

图 7-80 推荐导购员 ID 字段及表达式设置

杰

图 7-81 推荐会员 ID 字段及表达式设置

图 7-82 关系门店 ID 字段及表达式设置 671

Oinone7 天从入门到精通

克

-O i

no ne

图 7-83 成本事业部 ID 字段及表达式设置

杰

图 7-84 会员 ID 字段及表达式设置

图 7-85 名称事业部名称字段及表达式设置 672

no ne

Oinone7 天从入门到精通

杰

克

-O i

图 7-86 会员名称字段及表达式设置

图 7-87 流程新增数据设置

15. 新增【子流程节点】，这里之所以设置为子流程，就跟上面我们业务流程图中画的一样，
    【导购邀请下单触发流程】已经完成，会员积分累加从业务上来说是独立的，不影响【导
    购邀请下单触发流程】。我们在右侧属性面板中设置

<!-- -->

(1) 【选择模型】设置为【新增数据\[积分发放记录\]】
(2) 【选择子流程】设置为【创建新的子流程】，并设置子流程名称为【会员积分累加
    子流程】
(3) 【子流程执行方式】设置为【子流程和后续节点同时进行】
(4) 最后点击节点【保持】按钮

673

Oinone7 天从入门到精通

②

no ne

图 7-88 子流程模型设置 Step4.2 创建积分发放记录子流程：积分累积子流程

杰

克

-O i

16. 点击子流程的跳转图标，跳转到子流程的设计页面。子流程的触发模型由主流程指定，
    无法更改：

图 7-89 点击子流程的跳转图标

图 7-90 子流程设计 674

Oinone7 天从入门到精通

no ne

图 7-91 子流程触发设置

杰

克

-O i

17. 新增【条件分支】，分别对分支 1 和分支 2
    进行条件设置，条件为：【触发\[积分发放
    记录\]】的【最终发放积分】字段一个设置为小于等于 100，一个设置大于
    100。这里条
    件值没有选择上下文变量，而是选择了数值，因为【最终发放积分】字段为数字的普通
    类型，所以可以直接填数字：

图 7-92 节点规则表达式设置

675

Oinone7 天从入门到精通

-O i

no ne

图 7-93 流程设计 18.
在【条件分支】的【触发\[积分发放记录\]】的【最终发放积分】字段一个设置为大于
100 的分支流程中，增加【审批】节点，在右侧属性面板中： (1)
【审批模型】选择模型为【触发\[积分发放记录\]】 (2)
【审批人】选择角色为【超级管理员】 (3) 【数据】权限全部设置为【查看】
(4) 其他配置项默认，需要了解更多请移至 Oinone 官网或联系官方工作人员 (5)
最后点击节点【保持】按钮。

图 7-94 审批模型属性设置

杰

克

19. 再增加一个【获取数据】节点，在右侧属性面板中设置：

<!-- -->

(1) 【获取数据条数】为单条，选择模型为【会员】
(2) 点击【筛选条件】的【{X}】图标，进行数据获取的条件设置，选择条件字段为【ID】
    条件操作符为【等于】，条件为变量的关系字段【会员】的【ID】字段。设置好以
    后点击【确认】按钮。当上下文只有一个变量时默认不需要选择，这里默认的是【触
    发\[积分发放记录\]】
(3) 回到属性面板设置【未获取到数据时执行方式】为【终止流程】
(4) 最后点击节点【保持】按钮。

676

Oinone7 天从入门到精通

-O i

no ne

图 7-95 筛选条件设置 20. 增加【更新数据】节点，在右侧属性面板中 (1)
【更新模型】选择【获取数据\[会员\]】 (2) 【字段列表】点击【创建】按钮 1)
字段选择 更新【会员累计积分】字段 2)
表达式设置为：【获取数据\[会员\]】的【会员累计积分】字段【加上】【触发
\[积分发放记录\]】的【最终发放积分】字段，点击【确认】按钮。
最终完成的【触发\[导购邀请下单\]】更新设置 (3)
【获取数据\[会员\]】的【会员累计积分】字段等于自身【加上】【触发\[积分发放
记录\]】的【最终发放积分】字段 (4) 最后点击节点【保持】按钮。

杰

克

图 7-96 字段表达式设置

图 7-97 自定义设置 21. 新增【条件分支】，分别对分支 1 和分支 2
进行条件设置，条件为：【获取数据\[会员\]】
的关系字段【推荐客户】的【ID】字段一个设置为【为空】，一个设置为【非空】。

677

no ne

Oinone7 天从入门到精通

图 7-98 分支条件设置

杰

克

-O i

22. 在【条件分支】的【获取数据\[会员\]】的关系字段【推荐客户】的【ID】字段非空，增
    加【获取数据】节点，在右侧属性面板中 ①
    【获取数据条数】为单条，选择模型为【积分发放规则】 ②
    点击【筛选条件】的【{X}】图标，进行数据获取的条件设置，选择条件字段为【ID】
    条件操作符为【等于】，条件为变量【触发\[积分发放记录\]】的关系字段【关联积分规则】
    的【ID】字段。设置好以后点击【确认】按钮。 ③
    回到属性面板设置【未获取到数据时执行方式】为【终止流程】 ④
    最后点击节点【保持】按钮。

图 7-99 筛选条件设置 23.
在【条件分支】的【获取数据\[会员\]】的关系字段【推荐客户】的【ID】字段非空，增
加【获取数据】节点，在右侧属性面板中 ①
【获取数据条数】为单条，选择模型为【会员】

678

Oinone7 天从入门到精通

no ne

②
点击【筛选条件】的【{X}】图标，进行数据获取的条件设置，选择条件字段为【ID】
条件操作符为【等于】，条件为变量【获取数据\[会员\]】的关系字段【推荐客户】的【ID】
字段。设置好以后点击【确认】按钮。 ③
回到属性面板设置【未获取到数据时执行方式】为【终止流程】 ④
最后点击节点【保持】按钮。 ⑤ 编辑节点名字为【推荐客户】

-O i

图 7-100 【推荐客户】操作设置

杰

克

24. 在【条件分支】的【获取数据\[会员\]】的关系字段【推荐客户】的【ID】字段非空，增
    加【新增数据】节点，在右侧属性面板中

<!-- -->

(1) 【新增模型】选择模型为【积分发放记录】
(2) 【新增数据的节点】设置为【节点执行完即时增加业务数据】
(3) 【新增数据】点击【创建】按钮

<!-- -->

1)  字段选择【最终发放积分】
2)  表达式设置为：【触发\[积分发放记录\]】的【最终发放积分】字段【乘以】【获
    取数据\[积分发放规则\]】的【推荐客户发放比例】字段，点击【确认】按钮。

<!-- -->

(4) 【新增数据】点击【创建】按钮

<!-- -->

1)  字段选择关系字段【积分发放规则】的【ID】
2)  表达式设置为：【获取数据\[积分发放规则\]】的【ID】字段，点击【确认】按
    钮。

<!-- -->

(5) 【新增数据】点击【创建】按钮

<!-- -->

1)  字段选择【事件编码】
2)  表达式设置为：【触发\[积分发放记录\]】的【事件编码】字段，点击【确认】
    按钮。

<!-- -->

(6) 【新增数据】点击【创建】按钮

<!-- -->

1)  字段选择关系字段【推荐导购员】的【ID】
2)  表达式设置为：【触发\[积分发放记录\]】关系字段【推荐导购员】的【ID】，
    点击【确认】按钮。

<!-- -->

(7) 【新增数据】点击【创建】按钮

<!-- -->

1)  字段选择关系字段【关系门店】的【ID】 679

Oinone7 天从入门到精通

杰

克

-O i

no ne

2)  表达式设置为：【触发\[积分发放记录\]】的关系字段【关系门店】的【ID】，
    点击【确认】按钮。

<!-- -->

(8) 【新增数据】点击【创建】按钮

<!-- -->

1)  字段选择关系字段【成本事业部】的【ID】
2)  表达式设置为：【触发\[积分发放记录\]】的关系字段【成本事业部】的【ID】
    字段，点击【确认】按钮。

<!-- -->

(9) 【新增数据】点击【创建】按钮

<!-- -->

1)  字段选择关系字段【会员】的【ID】
2)  表达式设置为：【推荐客户\[会员\]】的【ID】字段，点击【确认】按钮。

<!-- -->

(10) 【新增数据】点击【创建】按钮 -- 为数据分析预留字段

<!-- -->

1)  字段选择【成本事业部名称】
2)  表达式设置为：【触发\[积分发放记录\]】的【成本事业部名称】字段，点击【确
    认】按钮。

<!-- -->

(11) 【新增数据】点击【创建】按钮 -- 为数据分析预留字段

<!-- -->

1)  字段选择【会员名称】
2)  表达式设置为：【推荐客户\[会员\]】的【名称】字段，点击【确认】按钮。

<!-- -->

(12) 最终完成的【新增数据\[积分发放记录\]】新增设置，最后点击节点【保持】按
    钮。

图 7-101 字段表达式设置

680

Oinone7 天从入门到精通

no ne

图 7-102 关联积分规则 ID 字段及表达式设置

杰

克

-O i

图 7-103 事件编码字段及表达式设置

图 7-104 推荐导购员 ID 字段及表达式设置

681

Oinone7 天从入门到精通

no ne

图 7-105 关系门店 ID 字段及表达式设置

杰

克

-O i

图 7-106 成本事业部 ID 字段及表达式设置

图 7-107 会员 ID 字段及表达式设置

682

Oinone7 天从入门到精通

no ne

图 7-108 成本事业部名称字段及表达式设置

图 7-109 会员名称字段及表达式设置

杰

克

-O i

25. 增加【更新数据】节点，在右侧属性面板中

<!-- -->

(1) 【更新模型】选择【推荐客户\[会员\]】
(2) 【字段列表】点击【创建】按钮

<!-- -->

1)  字段选择 更新【会员累计积分】字段
2)  表达式设置为：【推荐客户\[会员\]】的【会员累计积分】字段【加上】【新增
    \[积分发放记录\]】的【最终发放积分】字段，点击【确认】按钮。
    最终完成的【触发\[导购邀请下单\]】更新设置:

<!-- -->

(3) 【推荐客户\[会员\]】的【会员累计积分】字段等于自身【加上】【新增\[积分发放
    记录\]】的【最终发放积分】字段
(4) 最后点击节点【保持】按钮。

图 7-110 字段表达式设置

683

Oinone7 天从入门到精通

③

no ne

图 7-111 更新数据自定义

Step4.3 两个流程确保都保持并发布过

克

-O i

流程列表页查看流程状态图标

杰

图 7-112 流程列表页查看流程状态图标

（五）Step5 基础数据管理

流程前提：基础数据通过管理页面已经建好，后面看实战效果的基础数据为：

1.事业部：国一事业部、国二事业部 2.门店：国一独立门店
01（绑定：国一事业部，积分发放规则：正常发放）、国二独 立门店
01（绑定：国二事业部，积分发放规则：双倍发放）、融合门店 01

3.导购员：国一独立门店导购-cpc（绑定：国一独立门店
01）、国二独立门店导购温振（绑定：国二独立门店
01）、融合门店导购-梦瑶（绑定：融合门店 01）

4.会员：会员 1001（导购绑定：融合门店导购-梦瑶）、会员
1002（导购绑定：国二 独立门店导购-温振、推荐会员绑定：会员 1001）、会员
1003（导购绑定：未绑定、 推荐会员绑定：会员 1001）、

5.积分发放规则：双倍发放（发放倍数：2、推荐客户发放比例：0.5）、正常发放（发
放倍数：1、推荐客户发放比例：0.2） （六）Step6 走业务流程，看效果 ①
Step6.1 用例设计 1 新建【导购邀请下单记录】如下： 684

Oinone7 天从入门到精通 1. 2. 3. 4. 5. 6.

门店选择：国一独立门店 01 导购选择：国一独立门店导购-cpc 会员选择：会员
1003 商品填写：测试商品 1001 下单金额：12 事件编码：O1001

期望结果：

1.【会员 1003】的【所属于导购员】字段更新为：【国一独立门店导购-cpc】
2.【会员 1003】的【会员累计积分】字段在原有值上增加【12】 3.【会员
1001】的【会员累计积分】字段在原有值上增加【2.4】
4.新增两条【积分发放记录】 最终发放积 关联积分规

关系门店

会员 1003

会员 1001

国一独立门 店 01 国一独立门 店 01

事件编码

分

则

12

正常发放

O1001

2.4

正常发放

O1001

推荐导购员 成本事业部

no ne

会员

国一独立门 店导购-cpc

国一独立门 店导购-cpc

国一事业部

推荐会员

会员 1001

国一事业部

克

-O i

表 7-2 国一独立门店 01 会员记录表

杰

图 7-113 【会员
1003】的【所属于导购员】字段更新为【国一独立门店导购-cpc】

图 7-114 新增两条【积分发放记录】

②

Step6.2 用例设计 2

新建【导购邀请下单记录】如下：

1.门店选择：融合门店 01 2.导购选择：融合门店导购-梦瑶 3.会员选择：会员
1001 4.商品填写：测试商品 1002 685

Oinone7 天从入门到精通 5.下单金额：12 6.事件编码：O1002 期望结果：

1.出现填写节点，【选择积分发放规则】：双倍发放，【成本事业部】：国二事业部
2.【会员 1001】的【会员累计积分】字段在原有值上增加【24】
3.新增一条【积分发放记录】 会员

最终发放积 关联积分规

关系门店

会员 1001 融合门店 01

分

则

24

双倍发放

事件编码

O1002

推荐导购员 成本事业部

融合门店导 购-梦瑶

推荐会员

国二事业部

-O i

no ne

表 7-3 会员 1001 信息表

图 7-115 新增一条会员 1001 的【积分发放记录】

③

Step6.3 用例设计 3

克

新建【导购邀请下单记录】如下：

杰

1.门店选择：国二独立门店 01 2.导购选择：国二独立门店导购-温振
3.会员选择：会员 1002 4.商品填写：测试商品 1003 5.下单金额：60 6.
事件编码：O1003 期望结果：

1.出现审批，审批通过 2.【会员
1002】的【会员累计积分】字段在原有值上增加【120】 3.【会员
1001】的【会员累计积分】字段在原有值上增加【60】
4.新增两条【积分发放记录】 会员

会员 1002

会员 1001

关系门店

国二独立门 店 01 国二独立门 店 01

最终发放积 关联积分规

事件编码

分

则

120

双倍发放

O1003

60

双倍发放

O1003

推荐导购员 成本事业部

国二独立门 店导购-温振 国二独立门 店导购-温振

国二事业部

推荐会员

会员 1001

国二事业部

表 7-4 国二独立门店 01 会员记录表 686

Oinone7 天从入门到精通

图 7-116 新增两条【积分发放记录】 ④

Step6.4 用例设计 4 新建【导购邀请下单记录】如下：

no ne

1.门店选择：国一独立门店 01 2.导购选择：国二独立门店导购-温振
3.会员选择：会员 1002 4.商品填写：测试商品 1003 5.下单金额：60 6.
事件编码：O1004 期望结果：

会员 1002

会员 1001

最终发放积 关联积分规

关系门店

国一独立门 店 01

国一独立门 店 01

分

则

60

正常发放

克

会员

-O i

1.  【会员 1002】的【会员累计积分】字段在原有值上增加【60】
2.  【会员 1001】的【会员累计积分】字段在原有值上增加【12】
3.  新增两条【积分发放记录】

12

正常发放

事件编码

O1004

O1004

推荐导购员 成本事业部

国二独立门 店导购-温振 国二独立门 店导购-温振

国一事业部

推荐会员

会员 1001

国一事业部

杰

表 7-5 国一独立门店 01 会员记录表

图 7-117 新增两条积分发放记录 （七）Step7
通过数据可视化，设计相应的数据看板 ①

Step7.1 事业部积分发放分析

1.  进入数据可视化【图表】设计页，点击创建一级分组，在分组栏中会多出一行，并填入
    积分发放综合分析

687

Oinone7 天从入门到精通

图 7-118 数据可视化【图表】设计页

-O i

no ne

2.  鼠标放到一级分组上会出现增加二级分组和删除入口，点击图标“+”，创建两个二级
    分组分别为：积分发放分析和订单下单分析：

克

图 7-119 创建两个二级分组：积分发放分析和订单下单分析

杰

3.  选中二级分组【积分发放分析】出现【添加图标】操作入口，点击添加图表

图 7-120 选中二级分组【积分发放分析】出现【添加图标】操作入口 4.
在创建图表弹出框中 ① 【图表标题】填入【事业部积分成本分析】 ②
【模型】选择【积分发放记录】 ③
【方法】选择【根据条件分页查询记录列表和总数】 ④
最后点击节点【确定】按钮

688

Oinone7 天从入门到精通

图 7-121 事业部部积分成本分析图表弹出框

克

-O i

no ne

5.  上一步点击【确定】按钮后自动进入【事业部积分成本分析】图表设计页面。
    ① 【维度】选择【成本事业部名称】 ② 【数值】选择【最终发放积分】 ③
    点击右上角【保存】，并点击左上角【&lt;
    事业部积分成本分析】返回图表管理入口

杰

图 7-122 【事业部积分成本分析】图表设计页面

图 7-123 【事业部积分成本分析】图表设计页面 689

Oinone7 天从入门到精通 6.
点击右上角【发布】按钮，即完成一个图表的开发：

图 7-124 待发布图表

②

杰

克

-O i

no ne

7.  当有业务数据的时候展示：

图 7-125 有业务数据时展示

Step7.2 会员积分分析

1.  选中二级分组【积分发放分析】出现【添加图标】操作入口，点击添加图表。在创建图
    表弹出框中： ① 【图表标题】填入【会员累计获取积分分析】 ②
    【模型】选择【积分发放记录】 ③
    【方法】选择【根据条件分页查询记录列表和总数】 ④
    最后点击节点【确定】按钮

690

Oinone7 天从入门到精通

图 7-126 会员累计获取积分分析图表弹出框

杰

克

-O i

no ne

2.  进入【会员累计获取积分分析】图表设计页面。 ①
    【维度】选择【会员名称】 ② 【数值】选择【最终发放积分】 ③
    【对比】选择【成本事业部名称】 ④
    点击右上角【保存】，并点击左上角【&lt;
    会员累计获取积分分析】返回图表管理入 口

图 7-127 【会员累计获取积分分析】图表设计页面 3.
点击右上角【发布】按钮，即完成该图表的开发

691

Oinone7 天从入门到精通

③

Step7.3 商品下单金额分析

no ne

图 7-128 点击右上角【发布】按钮，即完成该图表的开发

杰

克

-O i

1.  选中二级分组【订单下单分析】出现【添加图标】操作入口，点击添加图表。在创建图
    表弹出框中 ① 【图表标题】填入【商品购买金额分析】 ②
    【模型】选择【导购邀请下单】 ③
    【方法】选择【根据条件分页查询记录列表和总数】 ④
    最后点击节点【确定】按钮

图 7-129 商品购买金额分析分析图表弹出框 2.
进入【商品购买金额分析】图表设计页面。 ① 图表形式切换为【饼图】 ②
【维度】选择【购买商品】 ③ 【数值】选择【下单金额】 ④ 右侧属性面板设置
1) 【展示标签】为【开启】 692

Oinone7 天从入门到精通 a. 勾选【购买商品】 2) 【展示图例】为【开启】 a.
勾选【购买商品】 b. 勾选【数值】 ⑤
点击右上角【保存】，并点击左上角【&lt;
会员累计获取积分分析】返回图表管理入

no ne

口

-O i

图 7-130 【商品购买金额分析】图表设计页面

杰

克

3.  点击右上角【发布】按钮，即完成该图表的开发

图 7-131 点击右上角【发布】按钮，即完成该图表的开发 ④

Step7.4 设计综合分析报表

1.  进入数据可视化【报表】设计页，点击创建一、二级分组，分别为【积分分析报表】、
    【积分综合报表】，选中二级分组【积分综合报表】出现【添加图标】操作入口，在分组栏
    中会多出一行，并填入积分发放综合分析：

693

Oinone7 天从入门到精通

图 7-132 进入数据可视化【报表】设计页

-O i

no ne

2.  选中二级分组【积分发放综合分析】，点击右上角【选择图表】，把上面建的三张图表
    都选上：

杰

克

图 7-133 点击右上角【选择图表】

图 7-134 把上面建的三张图表都选上 3.
选完图表后，拖动图表大小和所在位置即完成了报表的设计，最后别完了点击【发布】
按钮：

694

Oinone7 天从入门到精通

克

-O i

no ne

图 7-135 报表设计

⑤

杰

图 7-136 可拖动图表大小和所在位置

Step7.5 把报表挂载到页面上并邦上菜单

简单描述：新建名为【积分综合分析页】的页面，选择模型【积分发放记录】，页面类
型设置为【详情】，并在左侧【组件】选项卡下找到【报表】组件，拖入到设计器区并在其
属性面板中选择展示报表。新建菜单【积分数据分析】并绑定已有页面【积分综合分析页】，
最后点击【发布】按钮。

695

no ne

Oinone7 天从入门到精通

图 7-137 新建菜单【积分数据分析】并绑定已有页面

7.3 实战训练（全员营销为例）

一、场景说明

-O i

n 7.3.1 去除资源上传大小限制

二、实战训练

克

全员营销标准软件产品对于视频上传限制为
35M,该大小适合管理短视频类的素材。该
软件产品的使用方为营销部门，营销部门不仅管理短视频素材，也负责管理电商商品的视频
素材、公司团建的素材等，且不少素材的内存都远大于 35M。
业务需求：将全员营销中的内容中心扩展成营销部门的内容统一管理中心，管理营销部
门工作范围内的所有内容素材，且不受 35M 的限制。

杰

新增一个资源管理页面，替换原来的资源管理，并构建新的上传行为。
（一）Step1 通过界面设计器，设计出必要管理页面 1.
进入界面设计器，应用选择全员营销，模型通过搜索【素材】选择【Gemini
素材】， 点击添加页面下的直接创建：

图 7-138 选择【Gemini 素材】 2.
设置页面标题、模型（自动带上可切换）、业务类型（运营管理后续会扩展其他类型）、
视图类型（表格）后点击确认按钮进入【内容中心-新素材管理】设计页面：

696

no ne

Oinone7 天从入门到精通

图 7-139 页面信息设置

杰

克

-O i

3.  进入页面设计器，对【内容中心-新素材管理】表格页面进行设计： ①
    左侧为物料区：分为组件、模型。

<!-- -->

1)  【组件】选项卡下为通用物料区，我们可以为页面增加对应布局、字段（如同
    在模型设计器增加字段）、动作、数据、多媒体等等
2)  【模型】选项卡下为页面对应模型的自定义字段、系统字段、以及模型已有动
    作 ② 中间是设计区域 ③
    右侧为属性面板，在设计区域选择中组件会显示对应组件的可配置参数

图 7-140 对【内容中心-新素材管理】表格页面进行设计 4.
在左侧【模型】选项卡下，分别把系统字段中的【素材名称】、【素材链接】、【素材
来源】、【素材类型】、【更新时间】、【创建时间】等字段拖入设计区域的表格区。

697

Oinone7 天从入门到精通

no ne

图 7-141 将相应字段拖入设计区域的表格区

克

-O i

5.  设置字段在表格中的展示组件，在设计区域切换【素材链接】展示组件为【超链接】。

图 7-142 设置字段在表格中的展示组件

杰

6.  设置字段在表格中的展示组件的属性，在设计区域选中【素材名称】，在右侧属性面板
    中设置【标题】为【内容名称】。

图 7-143 设置字段在表格中展示组件的属性 7.
设置字段在表格中的展示组件的属性，在设计区域选中【创建时间】，在右侧属性面板
中设置【标题】为【上传时间】。

698

Oinone7 天从入门到精通

图 7-144 设置【标题】为【上传时间】

杰

克

-O i

no ne

8.  在左侧【模型】选项卡下，把动作分类下的提交类型【下载】和【删除】动作拖入中间
    设计区的动作区，并选择【删除】按钮，在右侧属性面板中设置【按钮样式】为【次要
    按钮】。

图 7-145 设置【按钮样式】为【次要按钮】

9.  在左侧【组件】选项卡下，把动作分类下的【跳转动作】拖入中间设计区的动作区，并
    在右侧属性面板中设置动作名称为【上传素材】，数据控制类型为【不进行数据处理】，
    打开方式为【弹窗打开】，【弹出内容】为【创建新页面】，【弹窗模型】通过搜索【素
    材】选择【Gemini 素材代理-上传】，并点击保存。

699

Oinone7 天从入门到精通

克

-O i

no ne

图 7-146 右侧属性面板中设置动作名称为【上传素材】

杰

图 7-147 设置【按钮样式】为【次要按钮】

10. 设计区选中【上传素材】按钮，点击【打开弹窗】设计【素材上传】的操作页面，此时
    会发现左侧【模型】选项卡下的当前模型切换成了【Gemini
    素材代理-上传】： ①
    分别把系统字段中的【上传素材链接列表】拖入【Gemini
    素材代理-上传】的弹窗 页面设计区。 ②
    选中【上传素材链接列表】切换展示组件为【文件上传】 ③
    选中【上传素材链接列表】并在右侧属性面板中

<!-- -->

1)  设置【校验】分组下，设置【最大上传文件体积】为空，即不设置
2)  设置【校验】分组下，设置【限制上传文件类型】为打开，并勾选【图片】和
    【视频】
3)  设置【交互】分组下的宽度属性为【1】

700

Oinone7 天从入门到精通

no ne

图 7-148 设计【素材上传】的操作页面

杰

克

-O i

11. 在左侧【模型】选项卡下，把动作分类下的提交类型【上传素材】动作拖入中间设计区
    的动作区。

图 7-149 把动作分类下的提交类型【上传素材】动作拖入中间设计区的动作区
12.
在左侧【组件】选项卡下，把动作分类下的【客户端动作】类型拖入中间设计区的动作
区，选中并在右侧属性面板中设置【动作名称】为返回，设置【客户端行为】为【关闭
弹窗】，点击【保存】按钮来完成动作的基础设置。

701

Oinone7 天从入门到精通

no ne

图 7-150 将【客户端动作】类型拖入中间设计区的动作区

杰

克

-O i

13. 选中【返回】按钮、并在右侧属性面板中设置【按钮样式】为【次要按钮】

图 7-151 设置【按钮样式】为【次要按钮】

14. 关闭弹窗返回主模型设计区

图 7-152 关闭弹窗返回主模型设计区 702

Oinone7 天从入门到精通

no ne

15. 点击右上角【显示母版】进入页面最终展示形式，点击添加菜单项，并在输入框中输入
    【新内容中心】

杰

克

-O i

图 7-153 点击右上角【显示母版】可进入页面最终展示形式

图 7-154 点击添加菜单项并在输入框中输入【新内容中心】

16. 点击菜单右侧设置图标，选择【绑定已有页面】，进行菜单与页面的绑定操作。

703

no ne

Oinone7 天从入门到精通

图 7-155 选择【绑定已有页面】

杰

克

-O i

17. 在绑定页面中，模型选择【Gemini
    素材】，视图选择【内容中心-新素材管理】，点击 确认按钮提交。

图 7-156 绑定页面选择

18. 最后别忘了点击右上角【发布】按钮对【内容中心-新素材管理】表格页面进行发布，
    回到界面设计器首页查看刚刚建好的表格页面 （二）Step2
    测试完成以后隐藏原【内容中心】菜单

19. 进入【界面设计器】管理页面，通过点击【设计图标】进入任一页面的设计页面。

704

Oinone7 天从入门到精通

图 7-157 点击【设计图标】可进入任一页面的设计页面

克

-O i

no ne

2.  点击右上角【显示母版】进入页面最终展示形式，找菜单【内容中心】点击菜单右侧设
    置图标，选择【隐藏菜单】，因为【内容中心】菜单是标准产品自带菜单，只能进行隐
    藏操作，无法进行如绑定页面和调整菜单顺序。

杰

图 7-158 选择【隐藏菜单】

（三）Step3 回到全员营销应用，刷新页面体验效果

整个实战训练就到此结束，若想了解更多细节可移至 Oinone 官网：
https://oinone.top/ 或联系 Oinone 官方工作人员。

n 7.3.2 原业务加审批流程 一、场景说明
场景描述：全员营销标准产品的功能并未有任务发放的审批流，在实际执行中，当营销
专员配置好任务后，需部门领导对整个活动如该任务内容、形式、参与人员进行审批。
业务需求：在发布任务这个流程中增加审批节点。

二、实战训练 （一）Step1 原业务分析

1.  点击菜单【任务中心】通过 URL 上的 Model 参数找到对应模型编码为
    【gemini.biz.GeminiTaskProxy】

705

Oinone7 天从入门到精通

图 7-159 找到对应模型编码为【gemini.biz.GeminiTaskProxy】

克

-O i

no ne

2.  进入模型设计器主页面，应用选择【全员营销】、选择【系统模型】、通过搜索关键字
    【任务】选择【Gemini
    任务代理】，展示方式从图模式切换到表单模式，对比【模型 编码】。

杰

图 7-160 通过搜索关键字【任务】选择【Gemini 任务代理】

图 7-161 模型信息编辑 3.
但目前模型为代理模型，代理模型是用于代理存储模型的数据管理器能力，同时又可以
扩展出非存储数据信息的交互功能的模型。因为在代理模型中新增的字段都是非存储字

706

Oinone7 天从入门到精通

no ne

段，所以如果要增加【审核状态】的字段一定以要在存储模型增加。其父模型的查看有
两种方式： ① 表单模式下可以直接看父模型 ②
在图模式和表单模式下点击继承关系

图 7-162 可继续展开看继承路径

杰

克

-O i

4.  点击【Gemini 任务】，进入【Gemini
    任务】的模型设计界面，可以看出该模型所在模
    块为【全员营销核心业务】，从【系统字段】中找到【任务状态】字段，点击查看字段
    详情，我们可以看到【业务类型】为数据字典，字典类型为【任务状态】。

图 7-163 编辑字段 5.
在模型设计器的管理页面上方点击【数字字典】选项卡，模块选择为【全员营销核心业
务】，选择【系统字典】就可以查看到【任务状态】数字字典。

707

Oinone7 天从入门到精通

克

-O i

no ne

图 7-164 选择【系统字典】可查看【任务状态】数字字典

杰

图 7-165 数据字典详情

6.  总结如下： ① 给【Gemini
    任务】模型增加一个【任务审批状态】，记录审批状态 ②
    在任务创建的时候，修改【任务状态】为【关闭】确保任务未审批通过的时，用户
    无法操作该任务。 ③ 审批通过后，恢复【任务状态】为【初始化】 ④
    我们先来整理下核心流程即：任务审批流程。

708

杰

克

-O i

no ne

Oinone7 天从入门到精通

图 7-166 任务审批流程 （二）Step2 利用模型设计器设计模型

1.  在模型设计器的管理页面上方点击【数字字典】选项卡，模块选择为【全员营销核
    心业务】，点击添加【数据字典】按钮，设置对应数据项： ①
    设置【字典名称】为【审批状态】 ② 设置【字典项类型】为【文本】 ③
    通过【添加数据字典项】按钮增加对应数据字典项，如审核中、审核失败、审核成
    功

709

no ne

Oinone7 天从入门到精通

图 7-167 点击添加【数据字典】按钮，设置对应数据项

杰

克

-O i

2.  在模型设计器的管理页面上方点击【模型】选项卡，模块选择为【全员营销核心业
    务】，选择【系统模型】、搜索任务选择【Gemini 任务】，点击添加字段。

图 7-168 搜索任务选择【Gemini 任务】 3. ① ② ③

为模型【Gemini 任务】添加字段 设置【字段名称】为【任务审批状态】
设置【字段业务类型】为数据字典，并选择关联数据字典为【任务审批状态】
最后点击【创建】按钮完成操作

710

no ne

Oinone7 天从入门到精通

杰

克

-O i

图 7-169 字段设置

图 7-170 设置【字段业务类型】为数据字典

4.  回到【Gemini
    任务】设计区，我们可以看到在模型的【自定义字段】选项卡下方
    多了一个【任务审批状态】字段。

711

no ne

Oinone7 天从入门到精通

图 7-171 模型的【自定义字段】选项卡下方多了一个【任务审批状态】字段
（三）Step3 利用界面设计器，设计出必要的审核页面

杰

克

-O i

1.  进入界面设计器，应用选择全员营销，模型选择【Gemini
    任务】，点击添加页面下 的直接创建；
2.  设置页面标题、模型（自动带上可切换）、业务类型（运营管理后续会扩展其他类
    型）、视图类型（表单）后点击确认按钮进入【Gemini
    任务】表单设计页面；

图 7-172 在界面设计器中进行页面创建 3. 进入页面设计器，对【Gemini
任务】表单页面进行设计： ① 左侧为物料区：分为组件、模型 1)
【组件】选项卡下为通用物料区，我们可以为页面增加对应布局、字段（如同
在模型设计器增加字段）、动作、数据、多媒体等等 2)
【模型】选项卡下为页面对应模型的自定义字段、系统字段、以及模型已有动 作
712

Oinone7 天从入门到精通

-O i

no ne

② 中间是设计区域 ③
右侧为属性面板，在设计区域选择中组件会显示对应组件的可配置参数 4.
在左侧【组件】选项卡下，拖入布局组件【分组】，并设置组件【标题属性】为基
础信息； 5.
在左侧【模型】选项卡下，分别系统字段中的【任务标题】、【任务开始时间】、
【任务结束时间】、【视频标题】、【视频风格】、【任务描述】拖入【基础信息】分组，
并点击【任务描述】，在右侧属性面板的【交互】分组中设置宽度为
1。最后别忘了点击【发 布】按钮完成页面的发布。

图 7-173 对【Gemini 任务】表单页面进行设计 （四）Step4
通过流程设计器，设计对应业务流程

杰

克

1.  进入流程设计器，点击【创建】按钮
    注意：流程中需要获取【关系字段】的除关联字段(一般为
    ID)以外的字段需要通过【数
    据获取】节点单独获取【关系字段】的对象数据。所以在流程设计中经常会用到【数据获取】
    节点。

图 7-174 进入流程设计器，创建对应业务流程 2.
左上角编辑流程名称为【任务审批流程】，点击第一个【触发】节点，触发方式选择模
型触发，模型选择【Gemini
任务】，触发场景选择【新增或更新数据时】，【筛选条
件】设置为【任务审批状态】为空或【任务审批状态】等于【审核中】，点击该节点的
【保存】按钮。

713

Oinone7 天从入门到精通

-O i

no ne

图 7-175 左上角编辑流程名称为【任务审批流程】

克

图 7-176 流程筛选条件设置

杰

3.  点击流程图节点间的【+】图标选择增加【获取数据】节点，或者拖动左侧物料区【获
    取数据】到特定的【+】图标。

图 7-177 点击流程图节点间的【+】图标选择增加【获取数据】节点

714

Oinone7 天从入门到精通

图 7-178 拖动左侧物料区【获取数据】到特定的【+】图标

克

-O i

no ne

4.  点击【获取数据】，在右侧属性面板中设置【获取数据条数】为多条，选择模型为【Gemini
    用户任务实例】，点击【筛选条件】的【{X}】图标，进行数据获取的条件设置。

图 7-179 进行数据获取的条件设置

杰

5.  选择条件字段为【任务
    ID】条件操作符为【等于】，条件为变量的导购字段的 ID。当
    上下文只有一个变量时默认不需要选择，这里默认的是【模型触发：\[Gemini
    任务\]】，
    设置好以后点击确认，回到属性面板设置【未获取到数据时执行方式】为【终止流程】，
    并点击节点【保持】按钮。

715

no ne

Oinone7 天从入门到精通

图 7-180 筛选条件设置

杰

克

-O i

6.  增加【更新数据】节点，在右侧属性面板中： ①
    【更新模型】选择【模型触发：\[Gemini 任务\]】 ②
    【字段列表】点击【创建】按钮

<!-- -->

1)  字段选择 更新【任务状态】字段
2)  表达式设置为：【已关闭】 ③ 【字段列表】点击【创建】按钮
3)  字段选择 更新【任务审核状态】字段
4)  表达式设置为：【审核中】 最终完成的【模型触发：\[Gemini
    任务\]】更新设置： ① 【模型触发：\[Gemini
    任务\]】的【任务状态】字段等于数字字典的【已关闭】，
    任务审核状态为【审核中】 ② 最后点击节点【保持】按钮

图 7-181 字段表达式设置

716

Oinone7 天从入门到精通

图 7-182 【更新数据】节点设置

杰

克

-O i

no ne

7.  再增加【更新数据】节点，在右侧属性面板中： ①
    【更新模型】选择【获取数据\[Gemini 用户任务实例\]】 ②
    【字段列表】点击【创建】按钮

<!-- -->

1)  字段选择 更新【任务状态】字段
2)  表达式设置为：【已关闭】 最终完成的【获取数据\[Gemini
    用户任务实例\]】更新设置： ① 【获取数据\[Gemini
    用户任务实例\]】的【任务状态】字段等于数字字典的【已关 闭】 ②
    最后点击节点【保持】按钮。

图 7-183 再增加【更新数据】节点 8. 增加【审批】节点，在右侧属性面板中：
① 【审批模型】选择模型为【模型触发：\[Gemini 任务\]】 ②
【选择视图】选择前面新建的页面【流程中的任务编辑页】 ③
【审批人】选择角色为【超级管理员】 ④ 【数据】权限全部设置为【查看】 ⑤
其他配置项默认，需要了解更多请查看产品使用手册 ⑥
最后点击节点【保持】按钮。

717

Oinone7 天从入门到精通

no ne

图 7-184 增加【审批】节点

杰

克

-O i

9.  新增【审核分支】，在【通过】分支中增加两个数据更新节点，跟审核前的两个数据更
    新节点对应： ① 【模型触发：\[Gemini
    任务\]】的【任务状态】字段等于数字字典的【初始化】，
    任务审核状态为【审核通过】 ② 【获取数据\[Gemini
    用户任务实例\]】的【任务状态】字段等于数字字典的【初始 化】

图 7-185 新增【审核分支】节点

718

Oinone7 天从入门到精通

no ne

图 7-186 【获取数据\[Gemini 用户任务实例\]】相应设置 10.
流程确保保持并发布过，点击右上角【发布流程】完成流程的保存与发布。
（五）Step5 检验效果

-O i

1.  创建任务后，任务状态为【关闭】状态，任务列表中的任务状态为多个状态的计算
    值；
2.  审核通过后，任务状态为【进行中】状态，任务列表中的任务状态为多个状态的计
    算值。

一、基础介绍

克

7.4 Oinone 的低无一体

杰

前面我们学习了基于低代码开发平台进行快速开发，以及通过 Oinone
的设计器进行零
代码开发两种模式。当然低无一体不是简单地说两种模式还指：低无两种模式可以融合。
1.
在做核心产品的时候以低代码开发为主，以无代码为辅助。见低代码开发的基础入
门篇中【设计器的结合】一文； 2.
在做实施或临时性需求则是以无代码为主，以低代码为辅助。
本文主要介绍第二种模式，它是 www.oinone.top 官网在 SaaS
模式下的专有特性。满足
客户安装标品后通过设计器进行适应性修改后，但对于一些特殊场景还是需要通过代码进行
完善或开发. 在该模式下，我们提供了 jar
模式和代码托管两种模式，客户只要选择需要进行代码开 发的模块，点击生产
SDK，下载扩展工程模版，按 Oinone 低代码开发平台规范进行研发，
后上传扩展工程即可。

719

no ne

Oinone7 天从入门到精通

图 7-187 按照 Oinone 低代码开发平台规范进行研发

二、操作手册

杰

克

-O i

低无一体这个模块是连接无代码设计器的桥梁，可以为一个模块或应用设计低代码的逻
辑，可以在界面设计器或流程设计器中使用低代码的逻辑。 1.选择模块
首先需要在下拉单选中选择需要低代码的模块或应用。 •
下拉选中只展示在「应用中心」中已安装的模块或应用，可前往「应用中心」安装
后继续低代码操作。 •
选择模块中不展示系统的基础模块或应用，因为这些模块或应用无法自定义模型。
2.模块信息
模块信息展示的是选择模块的基础信息：模块名称、模块编码、模块作者、模块版本、
包的前缀、工程模板下载地址，下载地址仅在上传 jar 包模式时候用到。
3.低无一体操作 低无一体支持了两种使用模式：上传 jar
包模式、源码托管模式。 •
上传控制工程或创建研发分支动作完成会生成一条数据，可以对单条数据进行部署、
卸载、修改、删除。 3.1 上传 jar 包模式 在这个模式下，需要做四步动作： ①
生成 SDK，点击按钮之后，会把模块的当前模型状态打成一个 SDK 包，SDK
最新生 成时间更新。当模型变更但未生成 SDK
时，使用低无一体就会出错，请重新生成 SDK 并修改 扩展工程。生成 SDK
通常需要 1 分钟左右，若第一次使用低无一体模块，可能需要更长时间，
请耐心等待。 ② 下载扩展工程模板，点击按钮之后，会将 SDK
包和工程模板生成一个下载链接，复 制模块信息中的卸载地址打开即可下载。 ③
技术人员在工程模板的基础上写低代码逻辑。 ④
上传扩展工程，点击按钮展开弹窗，在弹窗中设置标签、备注，并将最终的 jar
包上传，完成上传之后表格中就会新增一条数据。

720

Oinone7 天从入门到精通

no ne

图 7-188 上传 jar 包模式下，按照步骤完成相应操作

杰

克

-O i

⑤ 上传 jar 包模式下，模板工程中代码需要注意的点参考下图：

图 7-189 模板工程中代码需要注意的点

3.2 源码托管模式

在这个模式下，需要做三步动作： ① 生成
SDK，点击按钮之后，会把模块的当前模型状态打成一个 SDK 包，SDK 最新生
成时间更新。当模型变更但未生成 SDK 时，使用低无一体就会出错，请重新生成
SDK 并修改 扩展工程。生成 SDK 通常需要 1
分钟左右，若第一次使用低无一体模块，可能需要更长时间， 请耐心等待。 ②
创建研发分支，点击按钮展开弹窗。首次创建时需要设置 git 账号名称、git
账号
邮箱来创建一个账号，另外在弹窗中设置分支名称、标签、备注，完成创建后表格中就会新
增一条数据。 ③ 通过表格中的 Gitlab 地址，技术人员写低代码逻辑。

721

no ne

Oinone7 天从入门到精通

图 7-190 源码托管模式下，按照步骤完成响应操作 3.3 行内操作

杰

克

-O i

①
部署：工程状态为未部署、部署失败、已卸载时展示行内的部署按钮，点击之后进
行部署，工程状态变为部署中。部署过程大致需要 5-10
分钟，请耐心等待。部署完成之后，
会生成一个新的模块：“原模块名称”扩展工程。 ②
卸载：工程状态为已部署时展示行内的卸载按钮，点击之后会卸载这个已部署的工
程，工程状态变为已卸载。同一模块只能有一个已部署的工程（与选择的模式无关），若需
要使用新的工程请先卸载已部署的工程。 ③
修改：行内操作修改按钮始终展示，只允许修改标签、备注。 ④
删除：工程状态为未部署、部署失败、已卸载时展示行内的删除按钮，点击之后删
除这一条工程记录。 3.4 部署效果
低无一体部署成功之后，可以进入对应模块的模型页面中使用提交动作来使用低代码逻
辑，也可以在流程设计器中的引用逻辑节点中使用低代码逻辑。

722

Oinone7 天从入门到精通 【附件一】下载说明

章节说明

下载内容

安装 jdk 1.8

下载地址

https://www.oracle.com/java/technologies /downloads/\#java8l

安装 mysql 8.0.26

https://dev.mysql.com/downloads/mysql/

安装 idea 社区版

https://www.jetbrains.com/idea/download

2020.2.4

/other.html 请移至 Oinone 官网

根据各自 Idea 版本下

https://www.oinone.top/对应页面下载或 载对应插件，下载文件

no ne

安装 idea 插件

备注

联系 Oinone 官方客服

后去除.txt 后缀

https://sourceforge.net/projects/git-osx-in 安装 git 2.2.0

staller/files/git-2.15.0-intel-universal-mave
ricks.dmg/download?use\_mirror=nchc

境准备（Mac 版）

安装 GraphQL 的客户

请移至 Oinone 官网

https://www.oinone.top/对应页面下载或

-O i

3.1.1 环境准备&gt;环

端工具 Insomnia

安装 maven

联系 Oinone 官方客服

下载文件后修改文件 名去除.txt 后缀

https://archive.apache.org/dist/maven/ma ven-3/3.8.1/binaries/

克

https://archive.apache.org/dist/zookeeper

安装脚本 zk

/zookeeper-3.5.8/apache-zookeeper-3.5.8bin.tar.gz

杰

安装脚本 rocketmq

安装脚本 redis

安装 nvm

安装 JDK 1.8 安装 Apache Maven 3.1.1 环境搭建&gt;环 境准备（Windows 版）

3.8+ 下载 settings-develop.xml

https://archive.apache.org/dist/rocketmq/
4.7.1/rocketmq-all-4.7.1-bin-release.zip
https://download.redis.io/releases/redis-5. 0.2.tar.gz
https://github.com/nvm-sh/nvm/blob/mas ter/README.md
https://www.oracle.com/java/technologies /downloads/\#java8
https://maven.apache.org/download.cgi 请移至 Oinone 官网

下载到 C:\Users\你的

https://www.oinone.top/对应页面下载或 用户名.m2 目录中并 联系 Oinone
官方客服

重命名为 settings.xml

安装 Jetbrains IDEA https://www.jetbrains.com/idea/download 2020.2.4

/other.html

723

Oinone7 天从入门到精通 安装 Jetbrains IDEA
https://pan.baidu.com/share/init?surl=HNz 2020.2.4 需下载插件
SxxH0KncvglkfITUrsA 请移至 Oinone 官网 安装 idea 插件

安装 Git

根据各自 Idea 版本下

https://www.oinone.top/对应页面下载或 载对应插件，下载文件 联系 Oinone
官方客服

安装 MySQL 8

提取密码: mdji

后去除.txt 后缀

https://dev.mysql.com/downloads/mysql/

https://git-scm.com/download/win

安装 GraphQL 测试工具 https://github.com/Kong/insomnia/release

安装 RocketMQ

s https://rocketmq.apache.org/download/

no ne

Insomnia

安装 ElasticSearch 版 https://www.elastic.co/cn/downloads/past 本 8.4.1
安装 Redis

-releases/elasticsearch-7-6-1

https://download.redis.io/releases/

https://dlcdn.apache.org/zookeeper/zooke
eper-3.8.0/apache-zookeeper-3.8.0-bin.tar.

-O i

Zookeeper 安装

gz

安装 nodejs 版本 12.12.0

12.0-win-x64.zip

https://www.npmjs.com/package/cnpm

杰

克

安装 cnpm

https://nodejs.org/dist/v12.12.0/node-v12.

3.2.1Oinone 一模块 为组织&gt;构建第一 个 Module

安装

请移至 Oinone 官网

archetype-project-gene https://www.oinone.top/对应页面下载或 rate.sh
脚本

联系 Oinone 官方客服

安装 Docker

https://www.docker.com/get-started/

3.5.5Oinone 以交互 为外在&gt;设计器的 结合

724

Oinone7 天从入门到精通 请移至 Oinone 官网

下载结构包： Oinone-op-ds.zip

4.1.10 后端高级特 下载 canal 中间件：

https://www.oinone.top/对应页面下载或 联系 Oinone 官方客服

请移至 Oinone 官网

性&gt;函数之触发与 pamirs-middleware-can
https://www.oinone.top/对应页面下载或

al-deployer-3.0.1.zi

定时

联系 Oinone 官方客服

no ne

下载 tbSchedule 的控制 台 jar 包：

请移至 Oinone 官网

pamirs-middleware-sch https://www.oinone.top/对应页面下载或
edule-console-3.0.1.jar. 联系 Oinone 官方客服 4.1.11 后端高级特 txt
性&gt;函数之异步执

-O i

行

请移至 Oinone 官网

下载 schedule.json

https://www.oinone.top/对应页面下载或

pamirs-demo-boot 的 src/main/resources/ init 目录下

克

联系 Oinone 官方客服

下载以下文件放在

杰

方式一：官方下载安装包： https://www.elastic.co/cn/downloads/past
-releases/elasticsearch-8-4-1

4.1.25 后端高级特

下载后去除后缀.txt，

性&gt;框架之搜索引 ES 安装

然后解压文件

擎

方式二：请移至 Oinone 官网 https://www.oinone.top/对应页面下载或 联系
Oinone 官方客服

【其他说明】书籍第 3-6
章节部分源代码过长未展示完整版，如您需要了解完整代码可 参见云盘对应说明

725



[^1]: a-z0-9A-Z

[^2]: \u4e00-\u9fa5

[^3]: 0-9

[^4]: a-z0-9A-Z\_

[^5]: a-z0-9A-Z
